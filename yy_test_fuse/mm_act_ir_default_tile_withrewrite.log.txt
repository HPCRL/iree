Pass Manager with 1 passes:
builtin.module(hal.executable(hal.executable.variant(iree-llvmcpu-lower-executable-target{test-lowering-configuration=false use-lowering-pipeline=})))


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xca0490) {
  "flow.dispatch.tensor.store"(%10, %4) {operand_segment_sizes = array<i32: 1, 1, 0, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 512, 1024>, static_strides = array<i64: 1, 1>} : (tensor<512x1024xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xcb2fb0) {
  "linalg.yield"(%11) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xd13a70) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xd13d50) {
  %11 = "math.cos"(%arg0) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xd0dcf0) {
  "linalg.yield"(%12) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xcb2d90) {
  %12 = "arith.addf"(%arg2, %11) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xce11d0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xcb2e40) {
  %11 = "arith.mulf"(%arg0, %arg1) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xd09be0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xcb2ee0) {
  "linalg.yield"(%arg0) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xc876b0) {
  %7 = "tensor.empty"() : () -> tensor<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xd084b0) {
  %6 = "flow.dispatch.tensor.load"(%3) {operand_segment_sizes = array<i32: 1, 0, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 256, 1024>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>) -> tensor<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xd08400) {
  %5 = "flow.dispatch.tensor.load"(%2) {operand_segment_sizes = array<i32: 1, 0, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 512, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>) -> tensor<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %4 = "hal.interface.binding.subspan"(%0) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %3 = "hal.interface.binding.subspan"(%0) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %2 = "hal.interface.binding.subspan"(%0) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %1 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %0 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.return'(0xceab70) {
  "hal.return"(%0#0, %0#1, %0#2) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.workgroup_count_from_dag_root'(0xcea940) {
  %0:3 = "flow.dispatch.workgroup_count_from_dag_root"(%arg1, %arg2) : (index, index) -> (index, index, index)


  * Pattern mlir::iree_compiler::(anonymous namespace)::LowerDispatchWorkgroupCountForDagRootOp : 'flow.dispatch.workgroup_count_from_dag_root -> ()' {
    ** Insert  : 'arith.constant'(0xdf8e00)
    ** Insert  : 'arith.constant'(0xdfd7c0)
    ** Insert  : 'arith.constant'(0xdfd280)
    ** Replace : 'flow.dispatch.workgroup_count_from_dag_root'(0xcea940)
    ** Erase   : 'flow.dispatch.workgroup_count_from_dag_root'(0xcea940)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.return'(0xceab70) {
  "hal.return"(%0, %1, %2) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfd280) {
  %2 = "arith.constant"() {value = 1 : index} : () -> index

  ** Erase   : 'arith.constant'(0xdfd280)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.return'(0xceab70) {
  "hal.return"(%1, %2, %0) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfe1e0) {
  %0 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfd7c0) {
  %2 = "arith.constant"() {value = 2 : index} : () -> index

  ** Erase   : 'arith.constant'(0xdfd7c0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.return'(0xceab70) {
  "hal.return"(%2, %0, %1) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfd280) {
  %0 = "arith.constant"() {value = 2 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdf8e00) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0xdf8e00)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.return'(0xceab70) {
  "hal.return"(%0, %1, %2) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfd7c0) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.return'(0xceab70) {
  "hal.return"(%0, %1, %2) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfe1e0) {
  %2 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfd280) {
  %1 = "arith.constant"() {value = 2 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfd7c0) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%56, %9, %arg0, %arg1, %22, %25) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee4d20) {
  %60 = "affine.apply"(%25) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee4d20)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee4c90) {
  %59 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee4c90)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee4c00) {
  %58 = "affine.apply"(%25) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee4c00)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee4b70) {
  %57 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee4b70)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee49b0) {
  "linalg.yield"(%57) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xee4ab0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xe16430) {
  %57 = "math.cos"(%arg2) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xee3c80) {
  %55 = "tensor.extract_slice"(%12, %arg0, %arg1, %22, %25) {operand_segment_sizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<512x1024xf32>, index, index, index, index) -> tensor<?x?xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::SwapExtractSliceWithDispatchTensorLoad : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::(anonymous namespace)::SwapExtractSliceWithInitTensor : 'tensor.extract_slice -> ()' {
    ** Insert  : 'tensor.empty'(0xeee450)
    ** Replace : 'tensor.extract_slice'(0xee3c80)
    ** Erase   : 'tensor.extract_slice'(0xee3c80)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xee4ab0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeee450) {
  %55 = "tensor.empty"(%22, %25) : (index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xeea0c0) {
  %54 = "affine.apply"(%25) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xeea0c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xeea030) {
  %53 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xeea030)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee9fa0) {
  %52 = "affine.apply"(%25) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee9fa0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee9f10) {
  %51 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee9f10)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5200) {
  "linalg.yield"(%54) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %54 = "arith.addf"(%arg4, %53) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xd09ce0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xecf370) {
  %53 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xeea6f0) {
  %49 = "affine.apply"(%25) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xeea6f0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xeea660) {
  %48 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xeea660)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xeea5d0) {
  %47 = "affine.apply"(%25) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xeea5d0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xeea540) {
  %46 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xeea540)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee9de0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xbfa250) {
  %44 = "tensor.extract_slice"(%12, %arg0, %arg1, %22, %25) {operand_segment_sizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<512x1024xf32>, index, index, index, index) -> tensor<?x?xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::SwapExtractSliceWithDispatchTensorLoad : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::(anonymous namespace)::SwapExtractSliceWithInitTensor : 'tensor.extract_slice -> ()' {
    ** Insert  : 'tensor.empty'(0xeee500)
    ** Replace : 'tensor.extract_slice'(0xbfa250)
    ** Erase   : 'tensor.extract_slice'(0xbfa250)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeee500) {
  %44 = "tensor.empty"(%22, %25) : (index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xeea300) {
  %43 = "affine.apply"(%25) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xeea300)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xeea270) {
  %42 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xeea270)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xeea1e0) {
  %41 = "affine.apply"(%25) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xeea1e0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xeea150) {
  %40 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xeea150)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xee91a0) {
  %39 = "tensor.extract_slice"(%11, %arg1, %25) {operand_segment_sizes = array<i32: 1, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<256x1024xf32>, index, index) -> tensor<256x?xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::SwapExtractSliceWithDispatchTensorLoad : 'tensor.extract_slice -> ()' {
    ** Insert  : 'flow.dispatch.tensor.load'(0xeeb200)
    ** Replace : 'tensor.extract_slice'(0xee91a0)
    ** Erase   : 'tensor.extract_slice'(0xee91a0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xd09ce0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeeb200) {
  %39 = "flow.dispatch.tensor.load"(%8, %arg1, %25) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xee7ff0) {
  %38 = "tensor.extract_slice"(%10, %arg0, %22) {operand_segment_sizes = array<i32: 1, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (tensor<512x256xf32>, index, index) -> tensor<?x256xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::SwapExtractSliceWithDispatchTensorLoad : 'tensor.extract_slice -> ()' {
    ** Insert  : 'flow.dispatch.tensor.load'(0xee91a0)
    ** Replace : 'tensor.extract_slice'(0xee7ff0)
    ** Erase   : 'tensor.extract_slice'(0xee7ff0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xd09ce0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee91a0) {
  %38 = "flow.dispatch.tensor.load"(%7, %arg0, %22) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee6df0) {
  %37 = "affine.apply"(%25) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee6df0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee6d60) {
  %36 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee6d60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee6cd0) {
  %35 = "affine.apply"(%25) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee6cd0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee6c40) {
  %34 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee6c40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee6bb0) {
  %33 = "affine.apply"(%25) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee6bb0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee4db0) {
  %32 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee4db0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee2210) {
  %31 = "affine.apply"(%25) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee2210)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee2180) {
  %30 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee2180)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee20f0) {
  %29 = "affine.apply"(%25) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee20f0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xee0760) {
  %28 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xee0760)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xedef80) {
  %27 = "affine.apply"(%25) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xedef80)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecbcf0) {
  %26 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xecbcf0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0xecbb30) {
  %25 = "affine.min"(%arg1) {map = affine_map<(d0) -> (128, -d0 + 1024)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %24 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %23 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0xecc3d0) {
  %22 = "affine.min"(%arg0) {map = affine_map<(d0) -> (256, -d0 + 512)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %21 = "affine.apply"(%19) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %19 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %18 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %17 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %16 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf500) {
  %0 = "arith.constant"() {value = 128 : index} : () -> index

  ** Erase   : 'arith.constant'(0xecf500)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf4a0) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

  ** Erase   : 'arith.constant'(0xecf4a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %0 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdf7e20) {
  %1 = "arith.constant"() {value = 1 : index} : () -> index

  ** Erase   : 'arith.constant'(0xdf7e20)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %1 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xcb2fb0) {
  "linalg.yield"(%19) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xd13a70) {
  ** Erase   : 'linalg.generic'(0xd13a70)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xd0dcf0) {
  "linalg.yield"(%19) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xcb2d90) {
  %19 = "arith.addf"(%arg2, %18) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xce11d0) {
  ** Erase   : 'linalg.matmul'(0xce11d0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xd09be0) {
  ** Erase   : 'linalg.fill'(0xd09be0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xc876b0) {
  %9 = "tensor.empty"() : () -> tensor<512x1024xf32>

  ** Erase   : 'tensor.empty'(0xc876b0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xd084b0) {
  %8 = "flow.dispatch.tensor.load"(%5) {operand_segment_sizes = array<i32: 1, 0, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 256, 1024>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>) -> tensor<256x1024xf32>

  ** Erase   : 'flow.dispatch.tensor.load'(0xd084b0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xd08400) {
  %7 = "flow.dispatch.tensor.load"(%4) {operand_segment_sizes = array<i32: 1, 0, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 512, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>) -> tensor<512x256xf32>

  ** Erase   : 'flow.dispatch.tensor.load'(0xd08400)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %6 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %5 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %4 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %3 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %2 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%23, %6, %arg0, %arg1, %13, %16) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee49b0) {
  "linalg.yield"(%24) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xee4ab0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xe16430) {
  %24 = "math.cos"(%arg2) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeee450) {
  %22 = "tensor.empty"(%13, %16) : (index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5200) {
  "linalg.yield"(%25) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %25 = "arith.addf"(%arg4, %24) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xd09ce0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xecf370) {
  %24 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee9de0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeee500) {
  %19 = "tensor.empty"(%13, %16) : (index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeeb200) {
  %18 = "flow.dispatch.tensor.load"(%5, %arg1, %16) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee91a0) {
  %17 = "flow.dispatch.tensor.load"(%4, %arg0, %13) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0xecbb30) {
  %16 = "affine.min"(%arg1) {map = affine_map<(d0) -> (128, -d0 + 1024)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %15 = "affine.apply"(%8) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%7) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0xecc3d0) {
  %13 = "affine.min"(%arg0) {map = affine_map<(d0) -> (256, -d0 + 512)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %12 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %11 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %10 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %9 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %8 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %7 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %6 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %5 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %4 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %3 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %2 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %1 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %0 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
@@@@@@--- After Tile + Distribute ---
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c512 step %4 {
    %5 = affine.min affine_map<(d0) -> (256, -d0 + 512)>(%arg0)
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %6 to %c1024 step %7 {
      %8 = affine.min affine_map<(d0) -> (128, -d0 + 1024)>(%arg1)
      %9 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%5, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<?x256xf32>
      %10 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, %8], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x?xf32>
      %11 = tensor.empty(%5, %8) : tensor<?x?xf32>
      %12 = linalg.fill ins(%cst : f32) outs(%11 : tensor<?x?xf32>) -> tensor<?x?xf32>
      %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%9, %10 : tensor<?x256xf32>, tensor<256x?xf32>) outs(%12 : tensor<?x?xf32>) -> tensor<?x?xf32>
      %14 = tensor.empty(%5, %8) : tensor<?x?xf32>
      %15 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%13 : tensor<?x?xf32>) outs(%14 : tensor<?x?xf32>) {
      ^bb0(%in: f32, %out: f32):
        %16 = math.cos %in : f32
        linalg.yield %16 : f32
      } -> tensor<?x?xf32>
      flow.dispatch.tensor.store %15, %2, offsets = [%arg0, %arg1], sizes = [%5, %8], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%23, %6, %arg0, %arg1, %13, %16) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee49b0) {
  "linalg.yield"(%24) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xee4ab0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xe16430) {
  %24 = "math.cos"(%arg2) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeee450) {
  %22 = "tensor.empty"(%13, %16) : (index, index) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5200) {
  "linalg.yield"(%25) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %25 = "arith.addf"(%arg4, %24) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xd09ce0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xecf370) {
  %24 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee9de0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeee500) {
  %19 = "tensor.empty"(%13, %16) : (index, index) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeeb200) {
  %18 = "flow.dispatch.tensor.load"(%5, %arg1, %16) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee91a0) {
  %17 = "flow.dispatch.tensor.load"(%4, %arg0, %13) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0xecbb30) {
  %16 = "affine.min"(%arg1) {map = affine_map<(d0) -> (128, -d0 + 1024)>} : (index) -> index


  * Pattern CanonicalizeSingleResultAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern DeduplicateAffineMinMaxExpressions<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern MergeAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern CanonicalizeAffineMinMaxOpExprAndTermOrder<mlir::AffineMinOp> : 'affine.min -> ()' {
    ** Insert  : 'affine.min'(0xeea030)
    ** Replace : 'affine.min'(0xecbb30)
    ** Erase   : 'affine.min'(0xecbb30)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%23, %6, %arg0, %arg1, %13, %16) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeee450) {
  %22 = "tensor.empty"(%13, %16) : (index, index) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeee500) {
  %19 = "tensor.empty"(%13, %16) : (index, index) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeeb200) {
  %18 = "flow.dispatch.tensor.load"(%5, %arg1, %16) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0xeea030) {
  %16 = "affine.min"(%arg1) {map = affine_map<(d0) -> (-d0 + 1024, 128)>} : (index) -> index


  * Pattern CanonicalizeSingleResultAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern DeduplicateAffineMinMaxExpressions<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern MergeAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern CanonicalizeAffineMinMaxOpExprAndTermOrder<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::(anonymous namespace)::FoldAffineMinOverDistributedLoopInductionVariable : 'affine.min -> ()' {
    ** Insert  : 'affine.apply'(0xeec650)
    ** Replace : 'affine.min'(0xeea030)
    ** Erase   : 'affine.min'(0xeea030)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeeb200) {
  %18 = "flow.dispatch.tensor.load"(%5, %arg1, %16) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeee500) {
  %19 = "tensor.empty"(%13, %16) : (index, index) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeee450) {
  %22 = "tensor.empty"(%13, %16) : (index, index) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%23, %6, %arg0, %arg1, %13, %16) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xeec650) {
  %16 = "affine.apply"() {map = affine_map<() -> (128)>} : () -> index

  ** Erase   : 'affine.apply'(0xeec650)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%23, %7, %arg0, %arg1, %14, %0) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeee450) {
  %22 = "tensor.empty"(%14, %0) : (index, index) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
    ** Insert  : 'tensor.empty'(0xecbb30)
    ** Insert  : 'tensor.cast'(0xeea0c0)
    ** Replace : 'tensor.empty'(0xeee450)
    ** Erase   : 'tensor.empty'(0xeee450)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xee4ab0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xeea0c0) {
  %23 = "tensor.cast"(%22) : (tensor<?x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xecbb30) {
  %22 = "tensor.empty"(%14) : (index) -> tensor<?x128xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeee500) {
  %19 = "tensor.empty"(%14, %0) : (index, index) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
    ** Insert  : 'tensor.empty'(0xee4b70)
    ** Insert  : 'tensor.cast'(0xee4c00)
    ** Replace : 'tensor.empty'(0xeee500)
    ** Erase   : 'tensor.empty'(0xeee500)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xee4c00) {
  %20 = "tensor.cast"(%19) : (tensor<?x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xee4b70) {
  %19 = "tensor.empty"(%14) : (index) -> tensor<?x128xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeeb200) {
  %18 = "flow.dispatch.tensor.load"(%6, %arg1, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xee4e40) {
  %0 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %16 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %15 = "affine.apply"(%8) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0xecc3d0) {
  %14 = "affine.min"(%arg0) {map = affine_map<(d0) -> (256, -d0 + 512)>} : (index) -> index


  * Pattern CanonicalizeSingleResultAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern DeduplicateAffineMinMaxExpressions<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern MergeAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern CanonicalizeAffineMinMaxOpExprAndTermOrder<mlir::AffineMinOp> : 'affine.min -> ()' {
    ** Insert  : 'affine.min'(0xeea030)
    ** Replace : 'affine.min'(0xecc3d0)
    ** Erase   : 'affine.min'(0xecc3d0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%25, %7, %arg0, %arg1, %14, %0) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee91a0) {
  %17 = "flow.dispatch.tensor.load"(%5, %arg0, %14) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xecbb30) {
  %23 = "tensor.empty"(%14) : (index) -> tensor<?x128xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xee4b70) {
  %19 = "tensor.empty"(%14) : (index) -> tensor<?x128xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0xeea030) {
  %14 = "affine.min"(%arg0) {map = affine_map<(d0) -> (-d0 + 512, 256)>} : (index) -> index


  * Pattern CanonicalizeSingleResultAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern DeduplicateAffineMinMaxExpressions<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern MergeAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern CanonicalizeAffineMinMaxOpExprAndTermOrder<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::(anonymous namespace)::FoldAffineMinOverDistributedLoopInductionVariable : 'affine.min -> ()' {
    ** Insert  : 'affine.apply'(0xeec650)
    ** Replace : 'affine.min'(0xeea030)
    ** Erase   : 'affine.min'(0xeea030)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xee4b70) {
  %19 = "tensor.empty"(%14) : (index) -> tensor<?x128xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xecbb30) {
  %23 = "tensor.empty"(%14) : (index) -> tensor<?x128xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee91a0) {
  %17 = "flow.dispatch.tensor.load"(%5, %arg0, %14) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%25, %7, %arg0, %arg1, %14, %0) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xeec650) {
  %14 = "affine.apply"() {map = affine_map<() -> (256)>} : () -> index

  ** Erase   : 'affine.apply'(0xeec650)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%25, %8, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee91a0) {
  %17 = "flow.dispatch.tensor.load"(%6, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xecbb30) {
  %23 = "tensor.empty"(%0) : (index) -> tensor<?x128xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
    ** Insert  : 'tensor.empty'(0xeec650)
    ** Insert  : 'tensor.cast'(0xeea030)
    ** Replace : 'tensor.empty'(0xecbb30)
    ** Erase   : 'tensor.empty'(0xecbb30)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xeea0c0) {
  %25 = "tensor.cast"(%24) : (tensor<?x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
    ** Insert  : 'tensor.cast'(0xecbb30)
    ** Replace : 'tensor.cast'(0xeea0c0)
    ** Erase   : 'tensor.cast'(0xeea0c0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xee4ab0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xecbb30) {
  %25 = "tensor.cast"(%23) : (tensor<256x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xeea030) {
  %24 = "tensor.cast"(%23) : (tensor<256x128xf32>) -> tensor<?x128xf32>

  ** Erase   : 'tensor.cast'(0xeea030)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeec650) {
  %23 = "tensor.empty"() : () -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xee4b70) {
  %19 = "tensor.empty"(%0) : (index) -> tensor<?x128xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
    ** Insert  : 'tensor.empty'(0xeed0e0)
    ** Insert  : 'tensor.cast'(0xeea030)
    ** Replace : 'tensor.empty'(0xee4b70)
    ** Erase   : 'tensor.empty'(0xee4b70)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xee4c00) {
  %21 = "tensor.cast"(%20) : (tensor<?x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
    ** Insert  : 'tensor.cast'(0xee4b70)
    ** Replace : 'tensor.cast'(0xee4c00)
    ** Erase   : 'tensor.cast'(0xee4c00)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xee4b70) {
  %21 = "tensor.cast"(%19) : (tensor<256x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xeea030) {
  %20 = "tensor.cast"(%19) : (tensor<256x128xf32>) -> tensor<?x128xf32>

  ** Erase   : 'tensor.cast'(0xeea030)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeed0e0) {
  %19 = "tensor.empty"() : () -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfe910) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %12 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %10 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %9 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %5 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%25, %8, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee49b0) {
  "linalg.yield"(%26) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xee4ab0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xe16430) {
  %26 = "math.cos"(%arg2) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xecbb30) {
  %24 = "tensor.cast"(%23) : (tensor<256x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeec650) {
  %23 = "tensor.empty"() : () -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5200) {
  "linalg.yield"(%27) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %27 = "arith.addf"(%arg4, %26) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xd09ce0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xecf370) {
  %26 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee9de0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xee4b70) {
  %20 = "tensor.cast"(%19) : (tensor<256x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeed0e0) {
  %19 = "tensor.empty"() : () -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::ReplaceEmptyTensorStaticShapeDims : 'tensor.empty -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeeb200) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg1, %1) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee91a0) {
  %17 = "flow.dispatch.tensor.load"(%6, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %15 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %12 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %10 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %9 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %5 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xee4e40) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfe910) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%25, %8, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee49b0) {
  "linalg.yield"(%26) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xee4ab0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xe16430) {
  %26 = "math.cos"(%arg2) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xecbb30) {
  %24 = "tensor.cast"(%23) : (tensor<256x128xf32>) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeec650) {
  %23 = "tensor.empty"() : () -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5200) {
  "linalg.yield"(%27) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %27 = "arith.addf"(%arg4, %26) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xd09ce0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xecf370) {
  %26 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee9de0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xee4b70) {
  %20 = "tensor.cast"(%19) : (tensor<256x128xf32>) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeed0e0) {
  %19 = "tensor.empty"() : () -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeeb200) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg1, %1) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee91a0) {
  %17 = "flow.dispatch.tensor.load"(%6, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %15 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %12 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %10 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %9 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %5 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xee4e40) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfe910) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After TileAndDistributeToWorkgroups (iree-codegen-tile-and-distribute-to-workgroups) //----- //
hal.executable.variant public @embedded_elf_x86_64, target = <"llvm-cpu", "embedded-elf-x86_64", {cpu = "generic", cpu_features = "", data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", native_vector_size = 16 : index, target_triple = "x86_64-unknown-unknown-eabi-elf"}> {
  hal.executable.export public @mm_cosine_static_dispatch_0_matmul_512x1024x256 ordinal(0) layout(#hal.pipeline.layout<push_constants = 0, sets = [<0, bindings = [<0, storage_buffer, ReadOnly>, <1, storage_buffer, ReadOnly>, <2, storage_buffer>]>]>) attributes {translation_info = #iree_codegen.translation_info<CPUDoubleTilingPadExpert>} {
  ^bb0(%arg0: !hal.device, %arg1: index, %arg2: index):
    %c8 = arith.constant 8 : index
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    hal.return %c8, %c2, %c1 : index, index, index
  }
  builtin.module {
    func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
      %c256 = arith.constant 256 : index
      %c128 = arith.constant 128 : index
      %c1024 = arith.constant 1024 : index
      %c512 = arith.constant 512 : index
      %c0 = arith.constant 0 : index
      %cst = arith.constant 0.000000e+00 : f32
      %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
      %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
      %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_count_x = hal.interface.workgroup.count[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %workgroup_count_y = hal.interface.workgroup.count[1] : index
      %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
      %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
      scf.for %arg0 = %3 to %c512 step %4 {
        %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
        %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
        scf.for %arg1 = %5 to %c1024 step %6 {
          %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%c256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<?x256xf32>
          %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x?xf32>
          %9 = tensor.empty() : tensor<256x128xf32>
          %cast = tensor.cast %9 : tensor<256x128xf32> to tensor<?x?xf32>
          %10 = linalg.fill ins(%cst : f32) outs(%cast : tensor<?x?xf32>) -> tensor<?x?xf32>
          %11 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%7, %8 : tensor<?x256xf32>, tensor<256x?xf32>) outs(%10 : tensor<?x?xf32>) -> tensor<?x?xf32>
          %12 = tensor.empty() : tensor<256x128xf32>
          %cast_0 = tensor.cast %12 : tensor<256x128xf32> to tensor<?x?xf32>
          %13 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%11 : tensor<?x?xf32>) outs(%cast_0 : tensor<?x?xf32>) {
          ^bb0(%in: f32, %out: f32):
            %14 = math.cos %in : f32
            linalg.yield %14 : f32
          } -> tensor<?x?xf32>
          flow.dispatch.tensor.store %13, %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
        }
      }
      return
    }
  }
}

// -----// IR Dump After TileAndDecomposeAttention (iree-linalg-ext-tile-and-decompose-attention) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c512 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c1024 step %6 {
      %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%c256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<?x256xf32>
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x?xf32>
      %9 = tensor.empty() : tensor<256x128xf32>
      %cast = tensor.cast %9 : tensor<256x128xf32> to tensor<?x?xf32>
      %10 = linalg.fill ins(%cst : f32) outs(%cast : tensor<?x?xf32>) -> tensor<?x?xf32>
      %11 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%7, %8 : tensor<?x256xf32>, tensor<256x?xf32>) outs(%10 : tensor<?x?xf32>) -> tensor<?x?xf32>
      %12 = tensor.empty() : tensor<256x128xf32>
      %cast_0 = tensor.cast %12 : tensor<256x128xf32> to tensor<?x?xf32>
      %13 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%11 : tensor<?x?xf32>) outs(%cast_0 : tensor<?x?xf32>) {
      ^bb0(%in: f32, %out: f32):
        %14 = math.cos %in : f32
        linalg.yield %14 : f32
      } -> tensor<?x?xf32>
      flow.dispatch.tensor.store %13, %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After DecomposeSoftmax (iree-linalg-ext-decompose-softmax) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c512 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c1024 step %6 {
      %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%c256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<?x256xf32>
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x?xf32>
      %9 = tensor.empty() : tensor<256x128xf32>
      %cast = tensor.cast %9 : tensor<256x128xf32> to tensor<?x?xf32>
      %10 = linalg.fill ins(%cst : f32) outs(%cast : tensor<?x?xf32>) -> tensor<?x?xf32>
      %11 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%7, %8 : tensor<?x256xf32>, tensor<256x?xf32>) outs(%10 : tensor<?x?xf32>) -> tensor<?x?xf32>
      %12 = tensor.empty() : tensor<256x128xf32>
      %cast_0 = tensor.cast %12 : tensor<256x128xf32> to tensor<?x?xf32>
      %13 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%11 : tensor<?x?xf32>) outs(%cast_0 : tensor<?x?xf32>) {
      ^bb0(%in: f32, %out: f32):
        %14 = math.cos %in : f32
        linalg.yield %14 : f32
      } -> tensor<?x?xf32>
      flow.dispatch.tensor.store %13, %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%25, %8, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee49b0) {
  "linalg.yield"(%26) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xee4ab0) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::AdaptLinalgInputOperandToOutputOperand : 'linalg.generic -> ()' {
    ** Insert  : 'linalg.generic'(0xecbcf0)
    ** Replace : 'linalg.generic'(0xee4ab0)
    ** Erase   : 'linalg.generic'(0xee4ab0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%25, %8, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::AdaptLinalgInputOperandToOutputOperand : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveCstOutsDependency : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xe16430) {
  %26 = "math.cos"(%arg2) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xecbb30) {
  %24 = "tensor.cast"(%23) : (tensor<256x128xf32>) -> tensor<?x?xf32>

  ** Erase   : 'tensor.cast'(0xecbb30)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeec650) {
  %23 = "tensor.empty"() : () -> tensor<256x128xf32>

  ** Erase   : 'tensor.empty'(0xeec650)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5200) {
  "linalg.yield"(%25) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %25 = "arith.addf"(%arg4, %24) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xd09ce0) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveCstOutsDependency : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xecf370) {
  %24 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveCstOutsDependency : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee9de0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xee4b70) {
  %20 = "tensor.cast"(%19) : (tensor<256x128xf32>) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeed0e0) {
  %19 = "tensor.empty"() : () -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeeb200) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg1, %1) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee91a0) {
  %17 = "flow.dispatch.tensor.load"(%6, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %15 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %12 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %10 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %9 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %5 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xee4e40) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfe910) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%23, %8, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee49b0) {
  "linalg.yield"(%24) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::AdaptLinalgInputOperandToOutputOperand : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveCstOutsDependency : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xe16430) {
  %24 = "math.cos"(%arg2) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5200) {
  "linalg.yield"(%25) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %25 = "arith.addf"(%arg4, %24) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xd09ce0) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveCstOutsDependency : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xecf370) {
  %24 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveCstOutsDependency : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee9de0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xee4b70) {
  %20 = "tensor.cast"(%19) : (tensor<256x128xf32>) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeed0e0) {
  %19 = "tensor.empty"() : () -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeeb200) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg1, %1) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee91a0) {
  %17 = "flow.dispatch.tensor.load"(%6, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %15 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %12 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %10 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %9 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %5 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xee4e40) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfe910) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%25, %8, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee49b0) {
  "linalg.yield"(%26) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern (anonymous namespace)::DeduplicateAndRemoveDeadOperandsAndResults : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedCycleInGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xe16430) {
  %26 = "math.cos"(%arg2) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5200) {
  "linalg.yield"(%27) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %27 = "arith.addf"(%arg4, %26) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xd09ce0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xecf370) {
  %26 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee9de0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xee4b70) {
  %22 = "tensor.cast"(%18) : (tensor<256x128xf32>) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.empty'(0xeed0e0) {
  %21 = "tensor.empty"() : () -> tensor<256x128xf32>

  ** Erase   : 'tensor.empty'(0xeed0e0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeeb200) {
  %20 = "flow.dispatch.tensor.load"(%7, %arg1, %1) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee91a0) {
  %19 = "flow.dispatch.tensor.load"(%6, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xecbb30) {
  %18 = "tensor.cast"(%17) : (tensor<?x?xf32>) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1ce8ad0) {
  %17 = "flow.dispatch.tensor.load"(%8, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %15 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %12 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %10 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %9 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %5 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xee4e40) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfe910) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%24, %8, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee49b0) {
  "linalg.yield"(%25) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern (anonymous namespace)::DeduplicateAndRemoveDeadOperandsAndResults : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedCycleInGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xe16430) {
  %25 = "math.cos"(%arg2) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5200) {
  "linalg.yield"(%26) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %26 = "arith.addf"(%arg4, %25) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xd09ce0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xecf370) {
  %25 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee9de0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xee4b70) {
  %21 = "tensor.cast"(%18) : (tensor<256x128xf32>) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeeb200) {
  %20 = "flow.dispatch.tensor.load"(%7, %arg1, %1) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee91a0) {
  %19 = "flow.dispatch.tensor.load"(%6, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xecbb30) {
  %18 = "tensor.cast"(%17) : (tensor<?x?xf32>) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1ce8ad0) {
  %17 = "flow.dispatch.tensor.load"(%8, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %15 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %12 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %10 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %9 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %5 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xee4e40) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfe910) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After ConvertToDestinationPassingStyle (iree-codegen-convert-to-destination-passing-style) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c512 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c1024 step %6 {
      %7 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<?x?xf32>
      %cast = tensor.cast %7 : tensor<?x?xf32> to tensor<256x128xf32>
      %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%c256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<?x256xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x?xf32>
      %cast_0 = tensor.cast %cast : tensor<256x128xf32> to tensor<?x?xf32>
      %10 = linalg.fill ins(%cst : f32) outs(%cast_0 : tensor<?x?xf32>) -> tensor<?x?xf32>
      %11 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%8, %9 : tensor<?x256xf32>, tensor<256x?xf32>) outs(%10 : tensor<?x?xf32>) -> tensor<?x?xf32>
      %12 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%11 : tensor<?x?xf32>) {
      ^bb0(%out: f32):
        %13 = math.cos %out : f32
        linalg.yield %13 : f32
      } -> tensor<?x?xf32>
      flow.dispatch.tensor.store %12, %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%24, %8, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee49b0) {
  "linalg.yield"(%25) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xe16430) {
  %25 = "math.cos"(%arg2) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5200) {
  "linalg.yield"(%26) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %26 = "arith.addf"(%arg4, %25) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xd09ce0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xecf370) {
  %25 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee9de0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xee4b70) {
  %21 = "tensor.cast"(%18) : (tensor<256x128xf32>) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeeb200) {
  %20 = "flow.dispatch.tensor.load"(%7, %arg1, %1) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee91a0) {
  %19 = "flow.dispatch.tensor.load"(%6, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xecbb30) {
  %18 = "tensor.cast"(%17) : (tensor<?x?xf32>) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1ce8ad0) {
  %17 = "flow.dispatch.tensor.load"(%8, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %15 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %12 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %10 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %9 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %5 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xee4e40) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfe910) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After FoldAffineMinInDistributedLoops (iree-codegen-fold-affinemin-in-distributed-loops) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c512 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c1024 step %6 {
      %7 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<?x?xf32>
      %cast = tensor.cast %7 : tensor<?x?xf32> to tensor<256x128xf32>
      %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%c256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<?x256xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x?xf32>
      %cast_0 = tensor.cast %cast : tensor<256x128xf32> to tensor<?x?xf32>
      %10 = linalg.fill ins(%cst : f32) outs(%cast_0 : tensor<?x?xf32>) -> tensor<?x?xf32>
      %11 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%8, %9 : tensor<?x256xf32>, tensor<256x?xf32>) outs(%10 : tensor<?x?xf32>) -> tensor<?x?xf32>
      %12 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%11 : tensor<?x?xf32>) {
      ^bb0(%out: f32):
        %13 = math.cos %out : f32
        linalg.yield %13 : f32
      } -> tensor<?x?xf32>
      flow.dispatch.tensor.store %12, %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfe910) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xee4e40) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %5 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %9 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %10 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %12 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %15 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1ce8ad0) {
  %17 = "flow.dispatch.tensor.load"(%8, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
    ** Insert  : 'flow.dispatch.tensor.load'(0xee21b0)
    ** Insert  : 'tensor.cast'(0x1ce64a0)
    ** Replace : 'flow.dispatch.tensor.load'(0x1ce8ad0)
    ** Erase   : 'flow.dispatch.tensor.load'(0x1ce8ad0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x1ce64a0) {
  %18 = "tensor.cast"(%17) : (tensor<256x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %17 = "flow.dispatch.tensor.load"(%8, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xecbb30) {
  %19 = "tensor.cast"(%18) : (tensor<?x?xf32>) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
    ** Insert  : 'tensor.cast'(0x1ce65f0)
    ** Replace : 'tensor.cast'(0xecbb30)
    ** Erase   : 'tensor.cast'(0xecbb30)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x1ce64a0) {
  %18 = "tensor.cast"(%17) : (tensor<256x128xf32>) -> tensor<?x?xf32>

  ** Erase   : 'tensor.cast'(0x1ce64a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x1ce65f0) {
  %18 = "tensor.cast"(%17) : (tensor<256x128xf32>) -> tensor<256x128xf32>

  ** Erase   : 'tensor.cast'(0x1ce65f0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %17 = "flow.dispatch.tensor.load"(%8, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee91a0) {
  %18 = "flow.dispatch.tensor.load"(%6, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
    ** Insert  : 'flow.dispatch.tensor.load'(0xeee500)
    ** Insert  : 'tensor.cast'(0x1ce65f0)
    ** Replace : 'flow.dispatch.tensor.load'(0xee91a0)
    ** Erase   : 'flow.dispatch.tensor.load'(0xee91a0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x1ce65f0) {
  %19 = "tensor.cast"(%18) : (tensor<256x256xf32>) -> tensor<?x256xf32>


  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %18 = "flow.dispatch.tensor.load"(%6, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeeb200) {
  %20 = "flow.dispatch.tensor.load"(%7, %arg1, %1) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
    ** Insert  : 'flow.dispatch.tensor.load'(0xeee450)
    ** Insert  : 'tensor.cast'(0x1ce64a0)
    ** Replace : 'flow.dispatch.tensor.load'(0xeeb200)
    ** Erase   : 'flow.dispatch.tensor.load'(0xeeb200)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x1ce64a0) {
  %21 = "tensor.cast"(%20) : (tensor<256x128xf32>) -> tensor<256x?xf32>


  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %20 = "flow.dispatch.tensor.load"(%7, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xee4b70) {
  %22 = "tensor.cast"(%17) : (tensor<256x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
    ** Insert  : 'linalg.fill'(0xecef50)
    ** Insert  : 'tensor.cast'(0x1ce8370)
    ** Replace : 'linalg.fill'(0xeea480)
    ** Erase   : 'linalg.fill'(0xeea480)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xee4b70) {
  %22 = "tensor.cast"(%17) : (tensor<256x128xf32>) -> tensor<?x?xf32>

  ** Erase   : 'tensor.cast'(0xee4b70)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x1ce8370) {
  %23 = "tensor.cast"(%22) : (tensor<256x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xd09ce0) {

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
    ** Insert  : 'linalg.matmul'(0xce11d0)
    ** Insert  : 'tensor.cast'(0x1ceae60)
    ** Replace : 'linalg.matmul'(0xd09ce0)
    ** Erase   : 'linalg.matmul'(0xd09ce0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x1ce8370) {
  %23 = "tensor.cast"(%22) : (tensor<256x128xf32>) -> tensor<?x?xf32>

  ** Erase   : 'tensor.cast'(0x1ce8370)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x1ce64a0) {
  %21 = "tensor.cast"(%20) : (tensor<256x128xf32>) -> tensor<256x?xf32>

  ** Erase   : 'tensor.cast'(0x1ce64a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x1ce65f0) {
  %19 = "tensor.cast"(%18) : (tensor<256x256xf32>) -> tensor<?x256xf32>

  ** Erase   : 'tensor.cast'(0x1ce65f0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x1ceae60) {
  %22 = "tensor.cast"(%21) : (tensor<256x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xce11d0) {

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
    ** Insert  : 'linalg.generic'(0xca04a0)
    ** Insert  : 'tensor.cast'(0x1ce8370)
    ** Replace : 'linalg.generic'(0xecbcf0)
    ** Erase   : 'linalg.generic'(0xecbcf0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x1ceae60) {
  %22 = "tensor.cast"(%21) : (tensor<256x128xf32>) -> tensor<?x?xf32>

  ** Erase   : 'tensor.cast'(0x1ceae60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x1ce8370) {
  %23 = "tensor.cast"(%22) : (tensor<256x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xca04a0) {

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xee4f40) {
  "flow.dispatch.tensor.store"(%23, %8, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
    ** Insert  : 'tensor.cast'(0x1ceae60)
    ** Insert  : 'flow.dispatch.tensor.store'(0xd09cd0)
    ** Replace : 'flow.dispatch.tensor.store'(0xee4f40)
    ** Erase   : 'flow.dispatch.tensor.store'(0xee4f40)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xee4e40) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

  ** Erase   : 'arith.constant'(0xee4e40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfe910) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

  ** Erase   : 'arith.constant'(0xdfe910)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xd09cd0) {
  "flow.dispatch.tensor.store"(%22, %6, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorStoreShapeDims : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x1ceae60) {
  %22 = "tensor.cast"(%21) : (tensor<?x?xf32>) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
    ** Insert  : 'tensor.cast'(0xee22a0)
    ** Replace : 'tensor.cast'(0x1ceae60)
    ** Erase   : 'tensor.cast'(0x1ceae60)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x1ce8370) {
  %21 = "tensor.cast"(%20) : (tensor<256x128xf32>) -> tensor<?x?xf32>

  ** Erase   : 'tensor.cast'(0x1ce8370)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xd09cd0) {
  "flow.dispatch.tensor.store"(%21, %6, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
    ** Insert  : 'flow.dispatch.tensor.store'(0xcd3380)
    ** Replace : 'flow.dispatch.tensor.store'(0xd09cd0)
    ** Erase   : 'flow.dispatch.tensor.store'(0xd09cd0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%20, %6, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorStoreShapeDims : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0xee22a0) {
  %21 = "tensor.cast"(%20) : (tensor<256x128xf32>) -> tensor<256x128xf32>

  ** Erase   : 'tensor.cast'(0xee22a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %0 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %1 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %2 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %3 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %4 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %5 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %6 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %7 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %8 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %9 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %10 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %11 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %12 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %13 = "affine.apply"(%7) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %14 = "affine.apply"(%8) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %15 = "flow.dispatch.tensor.load"(%6, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %16 = "flow.dispatch.tensor.load"(%4, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %17 = "flow.dispatch.tensor.load"(%5, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x1ce87d0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xce11d0) {

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xeea810) {
  %21 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32


  * Pattern (anonymous namespace)::MulFOfNegF : 'arith.mulf -> (arith.mulf)' {
    ** Failure : There's no operation that defines operand 0 of castedOp0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xc876b0) {
  %22 = "arith.addf"(%arg4, %21) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32


  * Pattern CanonicalizeContractAdd<mlir::arith::AddFOp> : 'arith.addf -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee9de0) {
  "linalg.yield"(%22) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xca04a0) {

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xecf370) {
  %21 = "math.cos"(%arg2) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5200) {
  "linalg.yield"(%21) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%20, %6, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorStoreShapeDims : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
module {
  func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
    %c1024 = arith.constant 1024 : index
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
    %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
    %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
    scf.for %arg0 = %3 to %c512 step %4 {
      %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
      %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
      scf.for %arg1 = %5 to %c1024 step %6 {
        %7 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
        %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
        %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
        %10 = linalg.fill ins(%cst : f32) outs(%7 : tensor<256x128xf32>) -> tensor<256x128xf32>
        %11 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%8, %9 : tensor<256x256xf32>, tensor<256x128xf32>) outs(%10 : tensor<256x128xf32>) -> tensor<256x128xf32>
        %12 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%11 : tensor<256x128xf32>) {
        ^bb0(%out: f32):
          %13 = math.cos %out : f32
          linalg.yield %13 : f32
        } -> tensor<256x128xf32>
        flow.dispatch.tensor.store %12, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
      }
    }
    return
  }
}

// -----// IR Dump After CSE (cse) //----- //
module {
  func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
    %c1024 = arith.constant 1024 : index
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
    %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
    %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
    scf.for %arg0 = %3 to %c512 step %4 {
      %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
      %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
      scf.for %arg1 = %5 to %c1024 step %6 {
        %7 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
        %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
        %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
        %10 = linalg.fill ins(%cst : f32) outs(%7 : tensor<256x128xf32>) -> tensor<256x128xf32>
        %11 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%8, %9 : tensor<256x256xf32>, tensor<256x128xf32>) outs(%10 : tensor<256x128xf32>) -> tensor<256x128xf32>
        %12 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%11 : tensor<256x128xf32>) {
        ^bb0(%out: f32):
          %13 = math.cos %out : f32
          linalg.yield %13 : f32
        } -> tensor<256x128xf32>
        flow.dispatch.tensor.store %12, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
      }
    }
    return
  }
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%20, %6, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5200) {
  "linalg.yield"(%21) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xca04a0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xecf370) {
  %21 = "math.cos"(%arg2) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee9de0) {
  "linalg.yield"(%22) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xc876b0) {
  %22 = "arith.addf"(%arg4, %21) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xce11d0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xeea810) {
  %21 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x1ce87d0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %17 = "flow.dispatch.tensor.load"(%5, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %16 = "flow.dispatch.tensor.load"(%4, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %15 = "flow.dispatch.tensor.load"(%6, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %14 = "affine.apply"(%8) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %13 = "affine.apply"(%7) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %12 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %11 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %10 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %9 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %8 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %7 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %6 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %5 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %4 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %3 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %2 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %1 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %0 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After TileAndDecomposeWinogradTransform (iree-linalg-ext-tile-and-decompose-winograd) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c512 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c1024 step %6 {
      %7 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = linalg.fill ins(%cst : f32) outs(%7 : tensor<256x128xf32>) -> tensor<256x128xf32>
      %11 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%8, %9 : tensor<256x256xf32>, tensor<256x128xf32>) outs(%10 : tensor<256x128xf32>) -> tensor<256x128xf32>
      %12 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%11 : tensor<256x128xf32>) {
      ^bb0(%out: f32):
        %13 = math.cos %out : f32
        linalg.yield %13 : f32
      } -> tensor<256x128xf32>
      flow.dispatch.tensor.store %12, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%20, %6, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5200) {
  "linalg.yield"(%21) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xca04a0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTileAndFusePattern : 'linalg.generic -> ()' {
Yufan:: SCFTileAndFusePattern::matchAndRewrite 
    ** Insert  : 'arith.constant'(0x21f60e0)
    ** Insert  : 'arith.constant'(0x21f6140)
    ** Insert  : 'arith.constant'(0x21f7de0)
    ** Insert  : 'arith.constant'(0x21f7e40)
    ** Insert  : 'scf.yield'(0x21f7e90)
    ** Insert  : 'scf.for'(0xeeb1f0)
    ** Insert  : 'arith.constant'(0x21f7f00)
    ** Insert  : 'arith.constant'(0x21f7f60)
    ** Insert  : 'scf.yield'(0x21f7fb0)
    ** Insert  : 'scf.for'(0xee9190)
    ** Insert  : 'tensor.extract_slice'(0x21f80e0)
    ** Insert  : 'linalg.generic'(0xecbcf0)
    ** Insert  : 'scf.for'(0xd13c00)
    ** Insert  : 'scf.for'(0xc89d80)
    ** Insert  : 'tensor.insert_slice'(0xcb9190)
    ** Insert  : 'scf.yield'(0x21f8070)
    ** Insert  : 'scf.yield'(0x21f8330)
    ** Erase   : 'scf.for'(0xeeb1f0)
    ** Erase   : 'scf.for'(0xee9190)
 tiledOps linalg.generic
%15 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%extracted_slice : tensor<8x32xf32>) {
^bb0(%out: f32):
  %16 = math.cos %out : f32
  linalg.yield %16 : f32
} -> tensor<8x32xf32>
Yufan:: ??  
slice operand -->0x21f80e0
%extracted_slice = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
    ** Insert  : 'tensor.extract_slice'(0xcb2d90)
    ** Insert  : 'tensor.extract_slice'(0x21fd6a0)
    ** Insert  : 'tensor.extract_slice'(0xeeb200)
    ** Insert  : 'linalg.matmul'(0x1ce8840)
    ** Modified: 'linalg.generic'(0xecbcf0)
slice operand -->0xcb2d90
%extracted_slice = tensor.extract_slice %8[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
slice operand -->0x21fd6a0
%extracted_slice_2 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
slice operand -->0xeeb200
%extracted_slice_3 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
    ** Insert  : 'tensor.extract_slice'(0x21fee20)
    ** Insert  : 'linalg.fill'(0xeea480)
    ** Modified: 'linalg.matmul'(0x1ce8840)
slice operand -->0x21fee20
%extracted_slice_3 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
    ** Modified: 'flow.dispatch.tensor.store'(0xcd3380)
tiledOp linalg.generic
%17 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%16 : tensor<8x32xf32>) {
^bb0(%out: f32):
  %18 = math.cos %out : f32
  linalg.yield %18 : f32
} -> tensor<8x32xf32>
tiledOp linalg.matmul
%16 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_2 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%15 : tensor<8x32xf32>) -> tensor<8x32xf32>
tiledOp linalg.fill
%15 = linalg.fill ins(%cst : f32) outs(%extracted_slice_3 : tensor<8x32xf32>) -> tensor<8x32xf32>
origOp linalg.fill
%10 = linalg.fill ins(%cst : f32) outs(%7 : tensor<256x128xf32>) -> tensor<256x128xf32>
origOp linalg.generic
%12 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%11 : tensor<256x128xf32>) {
^bb0(%out: f32):
  %14 = math.cos %out : f32
  linalg.yield %14 : f32
} -> tensor<256x128xf32>
origOp linalg.matmul
%11 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%8, %9 : tensor<256x256xf32>, tensor<256x128xf32>) outs(%10 : tensor<256x128xf32>) -> tensor<256x128xf32>
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%25, %6, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTileAndFusePattern : 'linalg.fill -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %31 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTileAndFusePattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xeeb200) {
  %33 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

  ** Erase   : 'tensor.extract_slice'(0xeeb200)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %30 = "tensor.extract_slice"(%17, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %29 = "tensor.extract_slice"(%16, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %36 = "tensor.insert_slice"(%35, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTileAndFusePattern : 'linalg.generic -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f80e0) {
  %34 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x21f80e0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f60) {
  %27 = "arith.constant"() {value = 128 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7f60)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %0 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %27 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7f00)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7e40) {
  %25 = "arith.constant"() {value = 256 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7e40)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %25 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7de0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %24 = "arith.constant"() {value = 32 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f6140)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %0 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f60e0) {
  %24 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f60e0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xecf370) {
  %26 = "math.cos"(%arg2) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee9de0) {
  "linalg.yield"(%27) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xc876b0) {
  %27 = "arith.addf"(%arg4, %26) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0xce11d0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTileAndFusePattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xeea810) {
  %26 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTileAndFusePattern : 'linalg.fill -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x1ce87d0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %20 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %19 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
** Erase   : 'linalg.generic'(0xca04a0)
** Erase   : 'linalg.matmul'(0xce11d0)
** Erase   : 'linalg.fill'(0xecef50)

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8010) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTileAndFusePattern : 'linalg.generic -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd8b0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xeec650) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTileAndFusePattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xee9c60) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTileAndFusePattern : 'linalg.fill -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd850) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %24 = "tensor.extract_slice"(%20, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %20 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %19 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyTileAndFusePass (iree-linalg-strategy-tile-and-fuse-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c512 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c1024 step %6 {
      %7 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %8 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %7) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice = tensor.extract_slice %8[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill {__internal_linalg_transform__ = "1"} ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) attrs =  {__internal_linalg_transform__ = "1"} {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8010) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd8b0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xeec650) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xee9c60) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd850) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %24 = "tensor.extract_slice"(%20, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %20 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %19 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill {__internal_linalg_transform__ = "1"} ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) attrs =  {__internal_linalg_transform__ = "1"} {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill {__internal_linalg_transform__ = "1"} ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) attrs =  {__internal_linalg_transform__ = "1"} {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8010) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd8b0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xeec650) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xee9c60) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd850) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %20 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgFuse (linalg-fuse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %20 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd850) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xee9c60) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32


  * Pattern (anonymous namespace)::MulFOfNegF : 'arith.mulf -> (arith.mulf)' {
    ** Failure : There's no operation that defines operand 0 of castedOp0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xeec650) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32


  * Pattern CanonicalizeContractAdd<mlir::arith::AddFOp> : 'arith.addf -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd8b0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8010) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertSliceIntoTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SwapExtractSliceOfTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorStoreShapeDims : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8010) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd8b0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xeec650) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xee9c60) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.fill -> ()' {
    ** Insert  : 'arith.constant'(0x21f7e40)
    ** Insert  : 'arith.constant'(0x21f7f60)
    ** Insert  : 'arith.constant'(0x21fd800)
    ** Insert  : 'arith.constant'(0x21fd7a0)
    ** Insert  : 'linalg.fill'(0xecef50)
    ** Insert  : 'tensor.extract_slice'(0xee4b70)
    ** Replace : 'linalg.fill'(0xeea480)
    ** Erase   : 'linalg.fill'(0xeea480)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xee4b70) {
  %32 = "tensor.extract_slice"(%31) {operand_segment_sizes = array<i32: 1, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>) -> tensor<8x32xf32>

  ** Erase   : 'tensor.extract_slice'(0xee4b70)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.fill -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21fd7a0) {
  %30 = "arith.constant"() {value = 32 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21fd7a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21fd800) {
  %29 = "arith.constant"() {value = 1 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21fd800)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f60) {
  %28 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7f60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7e40) {
  %27 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7e40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %20 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8010) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd8b0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xeec650) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xee9c60) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.fill -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8330) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %20 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyPadPass (iree-linalg-strategy-pad-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill {__internal_linalg_transform__ = "1"} ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8010) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd8b0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xeec650) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xee9c60) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8330) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %20 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill {__internal_linalg_transform__ = "1"} ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill {__internal_linalg_transform__ = "1"} ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8010) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd8b0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xeec650) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xee9c60) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8330) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %20 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgFuse (linalg-fuse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8010) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd8b0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xeec650) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
    ** Insert  : 'arith.constant'(0x21f7e40)
    ** Insert  : 'arith.constant'(0x21f7f60)
    ** Insert  : 'linalg.matmul'(0x2200870)
    ** Insert  : 'tensor.extract_slice'(0x1ceadd0)
    ** Replace : 'linalg.matmul'(0x1ce8840)
    ** Erase   : 'linalg.matmul'(0x1ce8840)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x1ceadd0) {
  %31 = "tensor.extract_slice"(%30) {operand_segment_sizes = array<i32: 1, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>) -> tensor<8x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x1ceadd0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f60) {
  %29 = "arith.constant"() {value = 32 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7f60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7e40) {
  %28 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7e40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8330) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %20 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8010) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd7f0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xc876b0) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xeea810) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8330) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %20 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyPadPass (iree-linalg-strategy-pad-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8010) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd7f0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xc876b0) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xeea810) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8330) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %20 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8010) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd7f0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xc876b0) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xeea810) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8330) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %20 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgFuse (linalg-fuse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8010) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.generic -> ()' {
    ** Insert  : 'arith.constant'(0x21f7e40)
    ** Insert  : 'arith.constant'(0x21f7f60)
    ** Insert  : 'arith.constant'(0x21fd8c0)
    ** Insert  : 'arith.constant'(0x21fd7a0)
    ** Insert  : 'linalg.generic'(0xca04a0)
    ** Insert  : 'tensor.extract_slice'(0x2200d40)
    ** Replace : 'linalg.generic'(0xecbcf0)
    ** Erase   : 'linalg.generic'(0xecbcf0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %35 = "tensor.insert_slice"(%34, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x2200d40) {
  %34 = "tensor.extract_slice"(%33) {operand_segment_sizes = array<i32: 1, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>) -> tensor<8x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x2200d40)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %34 = "tensor.insert_slice"(%33, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xca04a0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.generic -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21fd7a0) {
  %32 = "arith.constant"() {value = 32 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21fd7a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21fd8c0) {
  %31 = "arith.constant"() {value = 1 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21fd8c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f60) {
  %30 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7f60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7e40) {
  %29 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7e40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd7f0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xc876b0) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xeea810) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8330) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %20 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd850) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xca04a0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.generic -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xee9c60) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd7f0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xc876b0) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xeea810) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8330) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %20 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyPadPass (iree-linalg-strategy-pad-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) attrs =  {__internal_linalg_transform__ = "1"} {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd850) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xca04a0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xee9c60) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd7f0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xc876b0) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xeea810) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8330) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %20 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) attrs =  {__internal_linalg_transform__ = "1"} {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) attrs =  {__internal_linalg_transform__ = "1"} {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd850) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xca04a0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xee9c60) {
  %31 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd7f0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xc876b0) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xeea810) {
  %31 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f8330) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %25 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %21 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %20 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgFuse (linalg-fuse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%12 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%30) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd850) {
  "linalg.yield"(%31) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xca04a0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.generic -> ()' {
    ** Insert  : 'arith.constant'(0x21f7e40)
    ** Insert  : 'arith.constant'(0x21f7f60)
    ** Insert  : 'arith.constant'(0x21fd8c0)
    ** Insert  : 'arith.constant'(0x21fd7a0)
    ** Insert  : 'arith.constant'(0x21f8020)
    ** Insert  : 'arith.constant'(0x21f8080)
    ** Insert  : 'tensor.extract_slice'(0x2200d40)
    ** Insert  : 'linalg.generic'(0xecbcf0)
    ** Replace : 'linalg.generic'(0xca04a0)
    ** Erase   : 'linalg.generic'(0xca04a0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %37 = "tensor.insert_slice"(%36, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.generic -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x2200d40) {
  %35 = "tensor.extract_slice"(%28) {operand_segment_sizes = array<i32: 1, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>) -> tensor<8x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x2200d40)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.generic -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f8080) {
  %34 = "arith.constant"() {value = 32 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f8080)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f8020) {
  %33 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f8020)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21fd7a0) {
  %32 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21fd7a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21fd8c0) {
  %31 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21fd8c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f60) {
  %30 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7f60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7e40) {
  %29 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7e40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21fd7f0) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xc876b0) {
  %32 = "arith.addf"(%arg8, %31) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.matmul -> ()' {
    ** Insert  : 'arith.constant'(0x21fd860)
    ** Insert  : 'arith.constant'(0x21f8080)
    ** Insert  : 'arith.constant'(0x21f8020)
    ** Insert  : 'arith.constant'(0x21fd7a0)
    ** Insert  : 'arith.constant'(0x21fd8c0)
    ** Insert  : 'arith.constant'(0x21f7f60)
    ** Insert  : 'arith.constant'(0x21f9c90)
    ** Insert  : 'arith.constant'(0x21f7e40)
    ** Insert  : 'arith.constant'(0x21f9d10)
    ** Insert  : 'scf.yield'(0x21f9d60)
    ** Insert  : 'scf.for'(0xeeb1f0)
    ** Insert  : 'tensor.extract_slice'(0x21f7bd0)
    ** Insert  : 'tensor.extract_slice'(0x21f4ef0)
    ** Insert  : 'tensor.extract_slice'(0x2200d40)
    ** Insert  : 'linalg.matmul'(0x1ce8840)
    ** Insert  : 'scf.for'(0x2200700)
    ** Insert  : 'tensor.insert_slice'(0x21f4fe0)
    ** Insert  : 'scf.yield'(0x21f9dc0)
    ** Erase   : 'scf.for'(0xeeb1f0)
    ** Replace : 'linalg.matmul'(0x2200870)
    ** Erase   : 'linalg.matmul'(0x2200870)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.generic -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x21f4fe0) {
  %44 = "tensor.insert_slice"(%43, %arg7) {operand_segment_sizes = array<i32: 1, 1, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<8x32xf32>) -> tensor<8x32xf32>

  ** Erase   : 'tensor.insert_slice'(0x21f4fe0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%43) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x2200d40) {
  %42 = "tensor.extract_slice"(%arg7) {operand_segment_sizes = array<i32: 1, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>) -> tensor<8x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x2200d40)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f4ef0) {
  %41 = "tensor.extract_slice"(%25, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f7bd0) {
  %40 = "tensor.extract_slice"(%23, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9d10) {
  %36 = "arith.constant"() {value = 256 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f9d10)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7e40) {
  %35 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7e40)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %34 = "arith.constant"() {value = 32 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f9c90)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f60) {
  %33 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7f60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21fd8c0) {
  %32 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21fd8c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21fd7a0) {
  %31 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21fd7a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f8020) {
  %30 = "arith.constant"() {value = 16 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f8020)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f8080) {
  %30 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f8080)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21fd860) {
  %29 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21fd860)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xecef50) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.fill -> ()' {
    ** Insert  : 'arith.constant'(0x21f8020)
    ** Insert  : 'arith.constant'(0x21f7e40)
    ** Insert  : 'arith.constant'(0x21f9d10)
    ** Insert  : 'arith.constant'(0x21fd800)
    ** Insert  : 'arith.constant'(0x21f9dd0)
    ** Insert  : 'arith.constant'(0x21f9e30)
    ** Insert  : 'tensor.extract_slice'(0x2200d40)
    ** Insert  : 'linalg.fill'(0xeea480)
    ** Replace : 'linalg.fill'(0xecef50)
    ** Erase   : 'linalg.fill'(0xecef50)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.fill -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x2200d40) {
  %34 = "tensor.extract_slice"(%27) {operand_segment_sizes = array<i32: 1, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>) -> tensor<8x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x2200d40)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.fill -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9e30) {
  %33 = "arith.constant"() {value = 32 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f9e30)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9dd0) {
  %32 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f9dd0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21fd800) {
  %31 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21fd800)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9d10) {
  %30 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f9d10)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7e40) {
  %29 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f7e40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f8020) {
  %28 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f8020)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %27 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %26 = "tensor.extract_slice"(%22, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %24 = "tensor.extract_slice"(%20, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %22 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %21 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %11 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %8 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%31) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %31 = "tensor.insert_slice"(%30, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9c20) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.generic -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %32 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%34) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f4e80) {
  "linalg.yield"(%36) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %36 = "arith.addf"(%arg10, %35) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x21f9e90) {
  %35 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f4ef0) {
  %33 = "tensor.extract_slice"(%26, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f7bd0) {
  %32 = "tensor.extract_slice"(%24, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.fill -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2200670) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %27 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %26 = "tensor.extract_slice"(%22, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %24 = "tensor.extract_slice"(%20, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %22 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %21 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %11 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %8 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyTilePass (iree-linalg-strategy-tile-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill {__internal_linalg_transform__ = "1"} ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) attrs =  {__internal_linalg_transform__ = "1"} {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%31) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %31 = "tensor.insert_slice"(%30, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9c20) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %32 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%34) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f4e80) {
  "linalg.yield"(%36) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %36 = "arith.addf"(%arg10, %35) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x21f9e90) {
  %35 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f4ef0) {
  %33 = "tensor.extract_slice"(%26, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f7bd0) {
  %32 = "tensor.extract_slice"(%24, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2200670) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %27 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %26 = "tensor.extract_slice"(%22, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %24 = "tensor.extract_slice"(%20, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %22 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %21 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %11 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %8 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill {__internal_linalg_transform__ = "1"} ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) attrs =  {__internal_linalg_transform__ = "1"} {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill {__internal_linalg_transform__ = "1"} ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) attrs =  {__internal_linalg_transform__ = "1"} {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%31) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %31 = "tensor.insert_slice"(%30, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9c20) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %32 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%34) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f4e80) {
  "linalg.yield"(%36) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %36 = "arith.addf"(%arg10, %35) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x21f9e90) {
  %35 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f4ef0) {
  %33 = "tensor.extract_slice"(%26, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f7bd0) {
  %32 = "tensor.extract_slice"(%24, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2200670) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %27 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %26 = "tensor.extract_slice"(%22, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %24 = "tensor.extract_slice"(%20, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %22 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %21 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %11 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %8 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgSingleTilingExpert (linalg-single-tiling-expert-driver) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %8 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %11 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %21 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %22 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %24 = "tensor.extract_slice"(%20, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %26 = "tensor.extract_slice"(%22, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %27 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2200670) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f7bd0) {
  %32 = "tensor.extract_slice"(%24, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f4ef0) {
  %33 = "tensor.extract_slice"(%26, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x21f9e90) {
  %35 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32


  * Pattern (anonymous namespace)::MulFOfNegF : 'arith.mulf -> (arith.mulf)' {
    ** Failure : There's no operation that defines operand 0 of castedOp0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %36 = "arith.addf"(%arg10, %35) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32


  * Pattern CanonicalizeContractAdd<mlir::arith::AddFOp> : 'arith.addf -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f4e80) {
  "linalg.yield"(%36) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%34) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %32 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9c20) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %31 = "tensor.insert_slice"(%30, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertSliceIntoTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SwapExtractSliceOfTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%31) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorStoreShapeDims : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%31) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %31 = "tensor.insert_slice"(%30, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9c20) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %32 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%34) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f4e80) {
  "linalg.yield"(%36) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xee9c60) {
  %36 = "arith.addf"(%arg10, %35) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1ce8840) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
    ** Insert  : 'arith.constant'(0x21f9d10)
    ** Insert  : 'arith.constant'(0x21fd800)
    ** Insert  : 'linalg.matmul'(0x2200870)
    ** Insert  : 'tensor.extract_slice'(0x2200b60)
    ** Replace : 'linalg.matmul'(0x1ce8840)
    ** Erase   : 'linalg.matmul'(0x1ce8840)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%37) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x2200b60) {
  %37 = "tensor.extract_slice"(%36) {operand_segment_sizes = array<i32: 1, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>) -> tensor<8x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x2200b60)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%36) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21fd800) {
  %35 = "arith.constant"() {value = 32 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21fd800)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9d10) {
  %34 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f9d10)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f4ef0) {
  %33 = "tensor.extract_slice"(%26, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f7bd0) {
  %32 = "tensor.extract_slice"(%24, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2200670) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %27 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %26 = "tensor.extract_slice"(%22, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %24 = "tensor.extract_slice"(%20, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %22 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %21 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %11 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %8 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%31) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %31 = "tensor.insert_slice"(%30, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9c20) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %32 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%34) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9dc0) {
  "linalg.yield"(%36) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xeec650) {
  %36 = "arith.addf"(%arg10, %35) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xc876b0) {
  %35 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f4ef0) {
  %33 = "tensor.extract_slice"(%26, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f7bd0) {
  %32 = "tensor.extract_slice"(%24, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2200670) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %27 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %26 = "tensor.extract_slice"(%22, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %24 = "tensor.extract_slice"(%20, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %22 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %21 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %11 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %8 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyPadPass (iree-linalg-strategy-pad-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%31) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %31 = "tensor.insert_slice"(%30, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9c20) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %32 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%34) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9dc0) {
  "linalg.yield"(%36) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xeec650) {
  %36 = "arith.addf"(%arg10, %35) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xc876b0) {
  %35 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f4ef0) {
  %33 = "tensor.extract_slice"(%26, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f7bd0) {
  %32 = "tensor.extract_slice"(%24, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2200670) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %27 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %26 = "tensor.extract_slice"(%22, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %24 = "tensor.extract_slice"(%20, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %22 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %21 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %11 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %8 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%31) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %31 = "tensor.insert_slice"(%30, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9c20) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %32 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%34) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9dc0) {
  "linalg.yield"(%36) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xeec650) {
  %36 = "arith.addf"(%arg10, %35) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xc876b0) {
  %35 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f4ef0) {
  %33 = "tensor.extract_slice"(%26, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f7bd0) {
  %32 = "tensor.extract_slice"(%24, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.fill -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2200670) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %27 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %26 = "tensor.extract_slice"(%22, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %24 = "tensor.extract_slice"(%20, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %22 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %21 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %11 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %8 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgFuse (linalg-fuse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %15 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %15 : tensor<8x32xf32>
          }
          %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
          ^bb0(%out: f32):
            %15 = math.cos %out : f32
            linalg.yield %15 : f32
          } -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%31) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %31 = "tensor.insert_slice"(%30, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9c20) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0xeea880) {
  %32 = "math.cos"(%arg6) {fastmath = #arith.fastmath<none>} : (f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%34) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9dc0) {
  "linalg.yield"(%36) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xeec650) {
  %36 = "arith.addf"(%arg10, %35) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xc876b0) {
  %35 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f4ef0) {
  %33 = "tensor.extract_slice"(%26, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f7bd0) {
  %32 = "tensor.extract_slice"(%24, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2200670) {
  "linalg.yield"(%arg6) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %27 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %26 = "tensor.extract_slice"(%22, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %24 = "tensor.extract_slice"(%20, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %22 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %21 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %11 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %8 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After ResolveShapedTypeResultDims (resolve-shaped-type-result-dims) //----- //
module {
  func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
    %c16 = arith.constant 16 : index
    %c8 = arith.constant 8 : index
    %c32 = arith.constant 32 : index
    %c256 = arith.constant 256 : index
    %c128 = arith.constant 128 : index
    %c1024 = arith.constant 1024 : index
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
    %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
    %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg0 = %3 to %c512 step %4 {
      %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
      scf.for %arg1 = %5 to %c1024 step %6 {
        %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
        %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
        %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
          %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
          %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
            %extracted_slice_0 = tensor.extract_slice %9[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
            %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
            %12 = linalg.fill ins(%cst : f32) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
            %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
              %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
              %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
              %15 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
              scf.yield %15 : tensor<8x32xf32>
            }
            %14 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} outs(%13 : tensor<8x32xf32>) {
            ^bb0(%out: f32):
              %15 = math.cos %out : f32
              linalg.yield %15 : f32
            } -> tensor<8x32xf32>
            %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
            scf.yield %inserted_slice : tensor<256x128xf32>
          }
          scf.yield %11 : tensor<256x128xf32>
        }
        flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
      }
    }
    return
  }
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%31) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %31 = "tensor.insert_slice"(%30, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::FoldInsertSliceIntoTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SwapExtractSliceOfTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9c20) {
  "linalg.yield"(%32) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xecbcf0) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgVectorizationPattern : 'linalg.generic -> ()' {
    ** Failure : failed to match conv::Nwc 3-par 2-red
    ** Failure : failed to match conv::Ncw 3-par 2-red
    ** Failure : failed to match pooling 3-par 1-red
    ** Failure : failed to match pooling 3-par 1-red
    ** Failure : failed to match depthwise::Nwc conv 3-par 1-red
    ** Insert  : 'arith.constant'(0x2321700)
    ** Insert  : 'arith.constant'(0x2321760)
    ** Insert  : 'vector.transfer_read'(0x21f97d0)
    ** Insert  : 'math.cos'(0x231a5a0)
    ** Insert  : 'arith.constant'(0x231dc20)
    ** Insert  : 'vector.transfer_write'(0xc8fbb0)
    ** Replace : 'linalg.generic'(0xecbcf0)
    ** Erase   : 'linalg.generic'(0xecbcf0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %36 = "tensor.insert_slice"(%35, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::FoldInsertSliceIntoTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SwapExtractSliceOfTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc8fbb0) {
  %35 = "vector.transfer_write"(%33, %29, %34, %34) {operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
  ** Failure : source not a view or alloc
} -> failure : pattern failed to match

* Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
} -> failure : pattern failed to match

* Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
} -> failure : pattern failed to match

* Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x231dc20) {
  %34 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x231dc20)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc8fbb0) {
  %34 = "vector.transfer_write"(%33, %29, %7, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %33 = "math.cos"(%32) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::ReorderElementwiseOpsOnTranspose : 'math.cos -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x21f97d0) {
  %32 = "vector.transfer_read"(%29, %30, %30, %31) {operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
  ** Failure : source not a view or alloc
} -> failure : pattern failed to match

* Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
} -> failure : pattern failed to match

* Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
} -> failure : pattern failed to match

* Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
} -> failure : pattern failed to match

* Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2321760) {
  %31 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

  ** Erase   : 'arith.constant'(0x2321760)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x21f97d0) {
  %31 = "vector.transfer_read"(%29, %30, %30, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2321700) {
  %30 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2321700)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x21f97d0) {
  %30 = "vector.transfer_read"(%29, %7, %7, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%36) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x21f9dc0) {
  "linalg.yield"(%38) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0xeec650) {
  %38 = "arith.addf"(%arg10, %37) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32


  * Pattern (anonymous namespace)::ReorderElementwiseOpsOnTranspose : 'arith.addf -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2200870) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgVectorizationPattern : 'linalg.matmul -> ()' {
    ** Failure : failed to match conv::Nwc 3-par 2-red
    ** Failure : failed to match conv::Ncw 3-par 2-red
    ** Failure : failed to match pooling 3-par 1-red
    ** Failure : failed to match pooling 3-par 1-red
    ** Failure : failed to match depthwise::Nwc conv 3-par 1-red
    ** Insert  : 'arith.constant'(0x2321700)
    ** Insert  : 'arith.constant'(0x231dc20)
    ** Insert  : 'vector.transfer_read'(0xc82930)
    ** Insert  : 'arith.constant'(0x21f9c30)
    ** Insert  : 'vector.transfer_read'(0xc827e0)
    ** Insert  : 'arith.constant'(0x2321650)
    ** Insert  : 'vector.transfer_read'(0xc82690)
    ** Insert  : 'arith.mulf'(0xcb2e40)
    ** Insert  : 'vector.multi_reduction'(0x21f4fe0)
    ** Insert  : 'arith.constant'(0x231e000)
    ** Insert  : 'vector.transfer_write'(0xc68a50)
    ** Replace : 'linalg.matmul'(0x2200870)
    ** Erase   : 'linalg.matmul'(0x2200870)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%46) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc68a50) {
  %46 = "vector.transfer_write"(%44, %arg7, %45, %45) {operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
  ** Failure : source not a view or alloc
} -> failure : pattern failed to match

* Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
} -> failure : pattern failed to match

* Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
} -> failure : pattern failed to match

* Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x231e000) {
  %45 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x231e000)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc68a50) {
  %45 = "vector.transfer_write"(%44, %arg7, %7, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.multi_reduction'(0x21f4fe0) {
  %44 = "vector.multi_reduction"(%43, %42) {kind = #vector.kind<add>, reduction_dims = [2]} : (vector<8x32x16xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::MultiReduceToContract : 'vector.multi_reduction -> ()' {
    ** Insert  : 'vector.contract'(0x231e130)
    ** Replace : 'vector.multi_reduction'(0x21f4fe0)
    ** Erase   : 'vector.multi_reduction'(0x21f4fe0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc68a50) {
  %45 = "vector.transfer_write"(%44, %arg7, %7, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x231e130) {
  %44 = "vector.contract"(%38, %40, %42) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<8x32x16xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0xcb2e40) {
  %43 = "arith.mulf"(%38, %40) {fastmath = #arith.fastmath<none>} : (vector<8x32x16xf32>, vector<8x32x16xf32>) -> vector<8x32x16xf32>

  ** Erase   : 'arith.mulf'(0xcb2e40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %42 = "vector.transfer_read"(%arg7, %36, %36, %41) {operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
  ** Failure : source not a view or alloc
} -> failure : pattern failed to match

* Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
} -> failure : pattern failed to match

* Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
} -> failure : pattern failed to match

* Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
} -> failure : pattern failed to match

* Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2321650) {
  %41 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

  ** Erase   : 'arith.constant'(0x2321650)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %41 = "vector.transfer_read"(%arg7, %36, %36, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %40 = "vector.transfer_read"(%35, %36, %36, %39) {operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (0, d1, d0)>} : (tensor<16x32xf32>, index, index, f32) -> vector<8x32x16xf32>

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
  ** Failure : source not a view or alloc
} -> failure : pattern failed to match

* Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  ** Insert  : 'vector.transfer_read'(0xc28af0)
  ** Insert  : 'vector.transpose'(0x21f3660)
  ** Replace : 'vector.transfer_read'(0xc827e0)
  ** Erase   : 'vector.transfer_read'(0xc827e0)
} -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x231e130) {
  %43 = "vector.contract"(%38, %41, %42) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<8x32x16xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
    ** Insert  : 'vector.contract'(0x232b460)
    ** Replace : 'vector.contract'(0x231e130)
    ** Erase   : 'vector.contract'(0x231e130)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc68a50) {
  %44 = "vector.transfer_write"(%43, %arg7, %7, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b460) {
  %43 = "vector.contract"(%38, %40, %42) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<8x16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x21f3660) {
  %41 = "vector.transpose"(%40) {transp = [0, 2, 1]} : (vector<8x16x32xf32>) -> vector<8x32x16xf32>

  ** Erase   : 'vector.transpose'(0x21f3660)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %40 = "vector.transfer_read"(%35, %36, %36, %39) {in_bounds = [true, true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (0, d0, d1)>} : (tensor<16x32xf32>, index, index, f32) -> vector<8x16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.transfer_read'(0xc827e0)
    ** Insert  : 'vector.broadcast'(0x21f3660)
    ** Replace : 'vector.transfer_read'(0xc28af0)
    ** Erase   : 'vector.transfer_read'(0xc28af0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b460) {
  %43 = "vector.contract"(%38, %41, %42) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<8x16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
    ** Insert  : 'vector.contract'(0x232b530)
    ** Replace : 'vector.contract'(0x232b460)
    ** Erase   : 'vector.contract'(0x232b460)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc68a50) {
  %44 = "vector.transfer_write"(%43, %arg7, %7, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %43 = "vector.contract"(%38, %40, %42) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.broadcast'(0x21f3660) {
  %41 = "vector.broadcast"(%40) : (vector<16x32xf32>) -> vector<8x16x32xf32>

  ** Erase   : 'vector.broadcast'(0x21f3660)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %40 = "vector.transfer_read"(%35, %36, %36, %39) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<16x32xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
    ** Insert  : 'arith.addi'(0xcb2e40)
    ** Insert  : 'arith.constant'(0x2321650)
    ** Insert  : 'arith.addi'(0x21f4fe0)
    ** Insert  : 'vector.transfer_read'(0xc28af0)
    ** Replace : 'vector.transfer_read'(0xc827e0)
    ** Erase   : 'vector.transfer_read'(0xc827e0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %45 = "vector.contract"(%38, %43, %44) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %43 = "vector.transfer_read"(%26, %40, %42, %39) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x32xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
    ** Insert  : 'arith.constant'(0x231e000)
    ** Insert  : 'arith.addi'(0x232b600)
    ** Insert  : 'arith.addi'(0x232b6b0)
    ** Insert  : 'vector.transfer_read'(0xc827e0)
    ** Replace : 'vector.transfer_read'(0xc28af0)
    ** Erase   : 'vector.transfer_read'(0xc28af0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %48 = "vector.contract"(%38, %46, %47) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %46 = "vector.transfer_read"(%22, %44, %45, %39) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x232b6b0) {
  %45 = "arith.addi"(%42, %arg4) : (index, index) -> index


  * Pattern (anonymous namespace)::ReorderElementwiseOpsOnTranspose : 'arith.addi -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x232b600) {
  %44 = "arith.addi"(%40, %43) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x232b600)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %45 = "vector.transfer_read"(%22, %40, %44, %39) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x231e000) {
  %43 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x231e000)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x21f4fe0) {
  %42 = "arith.addi"(%36, %41) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x21f4fe0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x232b6b0) {
  %42 = "arith.addi"(%36, %arg4) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x232b6b0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %42 = "vector.transfer_read"(%22, %40, %arg4, %39) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2321650) {
  %41 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2321650)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0xcb2e40) {
  %40 = "arith.addi"(%36, %arg6) : (index, index) -> index

  ** Erase   : 'arith.addi'(0xcb2e40)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %40 = "vector.transfer_read"(%22, %arg6, %arg4, %39) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c30) {
  %39 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

  ** Erase   : 'arith.constant'(0x21f9c30)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %39 = "vector.transfer_read"(%22, %arg6, %arg4, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %38 = "vector.transfer_read"(%34, %36, %36, %37) {operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, 0, d1)>} : (tensor<8x16xf32>, index, index, f32) -> vector<8x32x16xf32>

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
  ** Failure : source not a view or alloc
} -> failure : pattern failed to match

* Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  ** Insert  : 'vector.transfer_read'(0xc28af0)
  ** Insert  : 'vector.transpose'(0x21f3660)
  ** Replace : 'vector.transfer_read'(0xc82930)
  ** Erase   : 'vector.transfer_read'(0xc82930)
} -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %42 = "vector.contract"(%39, %40, %41) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
    ** Insert  : 'vector.contract'(0x232b460)
    ** Replace : 'vector.contract'(0x232b530)
    ** Erase   : 'vector.contract'(0x232b530)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc68a50) {
  %43 = "vector.transfer_write"(%42, %arg7, %7, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b460) {
  %42 = "vector.contract"(%38, %40, %41) {indexing_maps = [affine_map<(d0, d1, d2) -> (d1, d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<32x8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x21f3660) {
  %39 = "vector.transpose"(%38) {transp = [1, 0, 2]} : (vector<32x8x16xf32>) -> vector<8x32x16xf32>

  ** Erase   : 'vector.transpose'(0x21f3660)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %38 = "vector.transfer_read"(%34, %36, %36, %37) {in_bounds = [true, true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (0, d0, d1)>} : (tensor<8x16xf32>, index, index, f32) -> vector<32x8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.transfer_read'(0xc82930)
    ** Insert  : 'vector.broadcast'(0x21f3660)
    ** Replace : 'vector.transfer_read'(0xc28af0)
    ** Erase   : 'vector.transfer_read'(0xc28af0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b460) {
  %42 = "vector.contract"(%39, %40, %41) {indexing_maps = [affine_map<(d0, d1, d2) -> (d1, d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<32x8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
    ** Insert  : 'vector.contract'(0x232b530)
    ** Replace : 'vector.contract'(0x232b460)
    ** Erase   : 'vector.contract'(0x232b460)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc68a50) {
  %43 = "vector.transfer_write"(%42, %arg7, %7, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %42 = "vector.contract"(%38, %40, %41) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.broadcast'(0x21f3660) {
  %39 = "vector.broadcast"(%38) : (vector<8x16xf32>) -> vector<32x8x16xf32>

  ** Erase   : 'vector.broadcast'(0x21f3660)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %38 = "vector.transfer_read"(%34, %36, %36, %37) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x16xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
    ** Insert  : 'arith.constant'(0x21f9c30)
    ** Insert  : 'arith.addi'(0xcb2e40)
    ** Insert  : 'arith.addi'(0x232b6b0)
    ** Insert  : 'vector.transfer_read'(0xc28af0)
    ** Replace : 'vector.transfer_read'(0xc82930)
    ** Erase   : 'vector.transfer_read'(0xc82930)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %44 = "vector.contract"(%41, %42, %43) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %41 = "vector.transfer_read"(%24, %39, %40, %37) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
    ** Insert  : 'arith.addi'(0x21f4fe0)
    ** Insert  : 'arith.constant'(0x2321650)
    ** Insert  : 'arith.addi'(0x232b600)
    ** Insert  : 'vector.transfer_read'(0xc82930)
    ** Replace : 'vector.transfer_read'(0xc28af0)
    ** Erase   : 'vector.transfer_read'(0xc28af0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %47 = "vector.contract"(%44, %45, %46) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %44 = "vector.transfer_read"(%20, %41, %43, %37) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x232b600) {
  %43 = "arith.addi"(%40, %42) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x232b600)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %43 = "vector.transfer_read"(%20, %41, %40, %37) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2321650) {
  %42 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2321650)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x21f4fe0) {
  %41 = "arith.addi"(%39, %arg2) : (index, index) -> index


  * Pattern (anonymous namespace)::ReorderElementwiseOpsOnTranspose : 'arith.addi -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x232b6b0) {
  %40 = "arith.addi"(%36, %arg6) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x232b6b0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %41 = "vector.transfer_read"(%20, %40, %arg6, %37) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0xcb2e40) {
  %39 = "arith.addi"(%36, %38) : (index, index) -> index

  ** Erase   : 'arith.addi'(0xcb2e40)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x21f4fe0) {
  %39 = "arith.addi"(%36, %arg2) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x21f4fe0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %39 = "vector.transfer_read"(%20, %arg2, %arg6, %37) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c30) {
  %38 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f9c30)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x231dc20) {
  %37 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

  ** Erase   : 'arith.constant'(0x231dc20)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %37 = "vector.transfer_read"(%20, %arg2, %arg6, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2321700) {
  %36 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2321700)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %38 = "vector.transfer_read"(%arg7, %7, %7, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f4ef0) {
  %35 = "tensor.extract_slice"(%26, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x21f4ef0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21f7bd0) {
  %34 = "tensor.extract_slice"(%24, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>

  ** Erase   : 'tensor.extract_slice'(0x21f7bd0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.fill'(0xeea480) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgVectorizationPattern : 'linalg.fill -> ()' {
    ** Failure : failed to match conv::Nwc 3-par 2-red
    ** Failure : failed to match conv::Ncw 3-par 2-red
    ** Failure : failed to match pooling 3-par 1-red
    ** Failure : failed to match pooling 3-par 1-red
    ** Failure : failed to match depthwise::Nwc conv 3-par 1-red
    ** Insert  : 'arith.constant'(0x2321700)
    ** Insert  : 'arith.constant'(0x231dc20)
    ** Insert  : 'vector.transfer_read'(0xc28af0)
    ** Insert  : 'arith.constant'(0x21f9c30)
    ** Insert  : 'arith.constant'(0x2321650)
    ** Insert  : 'vector.transfer_write'(0x232b760)
    ** Replace : 'linalg.fill'(0xeea480)
    ** Erase   : 'linalg.fill'(0xeea480)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x232b760) {
  %33 = "vector.transfer_write"(%32, %27, %31, %31) {operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
  ** Failure : source not a view or alloc
} -> failure : pattern failed to match

* Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
} -> failure : pattern failed to match

* Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
} -> failure : pattern failed to match

* Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2321650) {
  %32 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

  ** Erase   : 'arith.constant'(0x2321650)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x232b760) {
  %33 = "vector.transfer_write"(%0, %28, %32, %32) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c30) {
  %32 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x21f9c30)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x232b760) {
  %32 = "vector.transfer_write"(%0, %28, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %31 = "vector.transfer_read"(%28, %29, %29, %30) {operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

  ** Erase   : 'vector.transfer_read'(0xc28af0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x231dc20) {
  %30 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

  ** Erase   : 'arith.constant'(0x231dc20)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2321700) {
  %29 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2321700)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %28 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fd6a0) {
  %27 = "tensor.extract_slice"(%23, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x21fd6a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0xcb2d90) {
  %25 = "tensor.extract_slice"(%21, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

  ** Erase   : 'tensor.extract_slice'(0xcb2d90)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %23 = "flow.dispatch.tensor.load"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %22 = "flow.dispatch.tensor.load"(%12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %20 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %18 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %16 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %15 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %14 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %13 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%24, %12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%32) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0xcb9190) {
  %32 = "tensor.insert_slice"(%31, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::FoldInsertSliceIntoTransferWrite : 'tensor.insert_slice -> ()' {
    ** Insert  : 'vector.transfer_write'(0xc28af0)
    ** Replace : 'tensor.insert_slice'(0xcb9190)
    ** Erase   : 'tensor.insert_slice'(0xcb9190)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%32) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc28af0) {
  %32 = "vector.transfer_write"(%30, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc8fbb0) {
  %31 = "vector.transfer_write"(%30, %28, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>

  ** Erase   : 'vector.transfer_write'(0xc8fbb0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %30 = "math.cos"(%29) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::ReorderElementwiseOpsOnTranspose : 'math.cos -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x21f97d0) {
  %29 = "vector.transfer_read"(%28, %8, %8, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%36) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc68a50) {
  %36 = "vector.transfer_write"(%35, %arg7, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %35 = "vector.contract"(%32, %33, %34) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %34 = "vector.transfer_read"(%arg7, %8, %8, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %33 = "vector.transfer_read"(%23, %arg6, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %32 = "vector.transfer_read"(%21, %arg2, %arg6, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x232b760) {
  %27 = "vector.transfer_write"(%0, %26, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %23 = "flow.dispatch.tensor.load"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %22 = "flow.dispatch.tensor.load"(%12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %20 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %18 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %16 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %15 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %14 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %13 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%24, %12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%31) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc28af0) {
  %31 = "vector.transfer_write"(%30, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %30 = "math.cos"(%29) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::ReorderElementwiseOpsOnTranspose : 'math.cos -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x21f97d0) {
  %29 = "vector.transfer_read"(%28, %8, %8, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%36) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc68a50) {
  %36 = "vector.transfer_write"(%35, %arg7, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %35 = "vector.contract"(%32, %33, %34) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %34 = "vector.transfer_read"(%arg7, %8, %8, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %33 = "vector.transfer_read"(%23, %arg6, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %32 = "vector.transfer_read"(%21, %arg2, %arg6, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x232b760) {
  %27 = "vector.transfer_write"(%0, %26, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %23 = "flow.dispatch.tensor.load"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %22 = "flow.dispatch.tensor.load"(%12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %20 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %18 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %16 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %15 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %14 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %13 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%24, %12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%31) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc28af0) {
  %31 = "vector.transfer_write"(%30, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %30 = "math.cos"(%29) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x21f97d0) {
  %29 = "vector.transfer_read"(%28, %8, %8, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%36) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc68a50) {
  %36 = "vector.transfer_write"(%35, %arg7, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %35 = "vector.contract"(%32, %33, %34) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %34 = "vector.transfer_read"(%arg7, %8, %8, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %33 = "vector.transfer_read"(%23, %arg6, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %32 = "vector.transfer_read"(%21, %arg2, %arg6, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x232b760) {
  %27 = "vector.transfer_write"(%0, %26, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %23 = "flow.dispatch.tensor.load"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %22 = "flow.dispatch.tensor.load"(%12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %20 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %18 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %16 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %15 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %14 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %13 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyVectorizePass (iree-linalg-strategy-vectorize-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = vector.transfer_write %cst, %extracted_slice[%c0, %c0] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (tensor<8x32xf32>) {
            %17 = vector.transfer_read %7[%arg2, %arg6], %cst_0 {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %18 = vector.transfer_read %9[%arg6, %arg4], %cst_0 {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %19 = vector.transfer_read %arg7[%c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<8x32xf32>, vector<8x32xf32>
            %20 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %17, %18, %19 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            %21 = vector.transfer_write %20, %arg7[%c0, %c0] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<8x32xf32>
            scf.yield %21 : tensor<8x32xf32>
          }
          %14 = vector.transfer_read %13[%c0, %c0], %cst_0 {in_bounds = [true, true]} : tensor<8x32xf32>, vector<8x32xf32>
          %15 = math.cos %14 : vector<8x32xf32>
          %16 = vector.transfer_write %15, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
          scf.yield %16 : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%24, %12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%31) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc28af0) {
  %31 = "vector.transfer_write"(%30, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %30 = "math.cos"(%29) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x21f97d0) {
  %29 = "vector.transfer_read"(%28, %8, %8, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%36) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc68a50) {
  %36 = "vector.transfer_write"(%35, %arg7, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %35 = "vector.contract"(%32, %33, %34) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %34 = "vector.transfer_read"(%arg7, %8, %8, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %33 = "vector.transfer_read"(%23, %arg6, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %32 = "vector.transfer_read"(%21, %arg2, %arg6, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x232b760) {
  %27 = "vector.transfer_write"(%0, %26, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %23 = "flow.dispatch.tensor.load"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %22 = "flow.dispatch.tensor.load"(%12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %20 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %18 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %16 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %15 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %14 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %13 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%24, %12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%33) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc28af0) {
  %33 = "vector.transfer_write"(%32, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %32 = "math.cos"(%31) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x21f97d0) {
  %31 = "vector.transfer_read"(%30, %8, %8, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

  ** Erase   : 'vector.transfer_read'(0x21f97d0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %31 = "math.cos"(%29#1) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc68a50) {
  %30 = "vector.transfer_write"(%29#1, %29#0, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>

  ** Erase   : 'vector.transfer_write'(0xc68a50)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f9d60) {
  "scf.yield"(%arg7, %34) : (tensor<8x32xf32>, vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %34 = "vector.contract"(%32, %33, %arg8) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %33 = "vector.transfer_read"(%23, %arg6, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x231a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
    ** Insert  : 'scf.for'(0x2200700)
    ** Insert  : 'scf.yield'(0xeedef0)
    ** Erase   : 'scf.yield'(0x21f9d60)
    ** Replace : 'scf.for'(0x231a790)
    ** Erase   : 'scf.for'(0x231a790)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %30 = "math.cos"(%29) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%34) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %32 = "vector.transfer_read"(%21, %arg2, %arg6, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %28 = "vector.transfer_read"(%27, %8, %8, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

  ** Erase   : 'vector.transfer_read'(0xc82690)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x232b760) {
  %27 = "vector.transfer_write"(%0, %26, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>

  ** Erase   : 'vector.transfer_write'(0x232b760)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x21fee20) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x21fee20)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %23 = "flow.dispatch.tensor.load"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %22 = "flow.dispatch.tensor.load"(%12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %20 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %18 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %16 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %15 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %14 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %13 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%24, %12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%28) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc28af0) {
  %28 = "vector.transfer_write"(%27, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %27 = "math.cos"(%26) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%31) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %31 = "vector.contract"(%29, %30, %arg7) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %30 = "vector.transfer_read"(%23, %arg6, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %29 = "vector.transfer_read"(%21, %arg2, %arg6, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %23 = "flow.dispatch.tensor.load"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %22 = "flow.dispatch.tensor.load"(%12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %20 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %18 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %16 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %15 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %14 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %13 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %cst) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst_0 {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %9[%arg6, %arg4], %cst_0 {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %13 = math.cos %12 : vector<8x32xf32>
          %14 = vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
          scf.yield %14 : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %cst) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst_0 {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %9[%arg6, %arg4], %cst_0 {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %13 = math.cos %12 : vector<8x32xf32>
          %14 = vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
          scf.yield %14 : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %cst) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst_0 {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %9[%arg6, %arg4], %cst_0 {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %13 = math.cos %12 : vector<8x32xf32>
          %14 = vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
          scf.yield %14 : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%24, %12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%28) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc28af0) {
  %28 = "vector.transfer_write"(%27, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %27 = "math.cos"(%26) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%31) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %31 = "vector.contract"(%29, %30, %arg7) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %30 = "vector.transfer_read"(%23, %arg6, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %29 = "vector.transfer_read"(%21, %arg2, %arg6, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %23 = "flow.dispatch.tensor.load"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %22 = "flow.dispatch.tensor.load"(%12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %20 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %18 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %16 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %15 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %14 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %13 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %cst) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst_0 {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %9[%arg6, %arg4], %cst_0 {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %13 = math.cos %12 : vector<8x32xf32>
          %14 = vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
          scf.yield %14 : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %cst) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst_0 {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %9[%arg6, %arg4], %cst_0 {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %13 = math.cos %12 : vector<8x32xf32>
          %14 = vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
          scf.yield %14 : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgSingleTilingExpert (linalg-single-tiling-expert-driver) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %cst) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst_0 {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %9[%arg6, %arg4], %cst_0 {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %13 = math.cos %12 : vector<8x32xf32>
          %14 = vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
          scf.yield %14 : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %13 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %14 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %15 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %16 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %18 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %20 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %22 = "flow.dispatch.tensor.load"(%12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %23 = "flow.dispatch.tensor.load"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %29 = "vector.transfer_read"(%21, %arg2, %arg6, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %30 = "vector.transfer_read"(%23, %arg6, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %31 = "vector.contract"(%29, %30, %arg7) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%31) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %27 = "math.cos"(%26) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc28af0) {
  %28 = "vector.transfer_write"(%27, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%28) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%24, %12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorStoreShapeDims : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %cst) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst_0 {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %9[%arg6, %arg4], %cst_0 {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %13 = math.cos %12 : vector<8x32xf32>
          %14 = vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
          scf.yield %14 : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %cst) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst_0 {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %9[%arg6, %arg4], %cst_0 {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %13 = math.cos %12 : vector<8x32xf32>
          %14 = vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
          scf.yield %14 : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After EliminateEmptyTensors (iree-eliminate-empty-tensors) //----- //
module {
  func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
    %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
    %c16 = arith.constant 16 : index
    %c8 = arith.constant 8 : index
    %c32 = arith.constant 32 : index
    %c256 = arith.constant 256 : index
    %c128 = arith.constant 128 : index
    %c1024 = arith.constant 1024 : index
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
    %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
    %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg0 = %3 to %c512 step %4 {
      %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
      scf.for %arg1 = %5 to %c1024 step %6 {
        %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
        %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
        %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
          %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
            %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %cst) -> (vector<8x32xf32>) {
              %15 = vector.transfer_read %7[%arg2, %arg6], %cst_0 {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
              %16 = vector.transfer_read %9[%arg6, %arg4], %cst_0 {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
              %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
              scf.yield %17 : vector<8x32xf32>
            }
            %13 = math.cos %12 : vector<8x32xf32>
            %14 = vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
            scf.yield %14 : tensor<256x128xf32>
          }
          scf.yield %11 : tensor<256x128xf32>
        }
        flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
      }
    }
    return
  }
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0xcd3380) {
  "flow.dispatch.tensor.store"(%24, %12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7e90) {
  "scf.yield"(%25) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x21f7fb0) {
  "scf.yield"(%28) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xc28af0) {
  %28 = "vector.transfer_write"(%27, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %27 = "math.cos"(%26) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%31) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %31 = "vector.contract"(%29, %30, %arg7) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %30 = "vector.transfer_read"(%23, %arg6, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xd13c00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %29 = "vector.transfer_read"(%21, %arg2, %arg6, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee450) {
  %23 = "flow.dispatch.tensor.load"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xee21b0) {
  %22 = "flow.dispatch.tensor.load"(%12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0xeee500) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %20 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %18 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %16 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %15 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %14 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %13 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After EmptyTensorToAllocTensor (empty-tensor-to-alloc-tensor) //----- //
module {
  func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
    %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
    %c16 = arith.constant 16 : index
    %c8 = arith.constant 8 : index
    %c32 = arith.constant 32 : index
    %c256 = arith.constant 256 : index
    %c128 = arith.constant 128 : index
    %c1024 = arith.constant 1024 : index
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
    %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
    %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg0 = %3 to %c512 step %4 {
      %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
      scf.for %arg1 = %5 to %c1024 step %6 {
        %8 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>> -> tensor<256x128xf32>
        %9 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
        %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %8) -> (tensor<256x128xf32>) {
          %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
            %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %cst) -> (vector<8x32xf32>) {
              %15 = vector.transfer_read %7[%arg2, %arg6], %cst_0 {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
              %16 = vector.transfer_read %9[%arg6, %arg4], %cst_0 {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
              %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
              scf.yield %17 : vector<8x32xf32>
            }
            %13 = math.cos %12 : vector<8x32xf32>
            %14 = vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
            scf.yield %14 : tensor<256x128xf32>
          }
          scf.yield %11 : tensor<256x128xf32>
        }
        flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
      }
    }
    return
  }
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xeee440) {

  * Pattern (anonymous namespace)::DeduplicateAndRemoveDeadOperandsAndResults : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedCycleInGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5060) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x231d7e0) {
  %28 = "memref.subview"(%14, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeee610) {
  "scf.yield"(%29) : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xcb2fb0) {
  "scf.yield"(%arg5) : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1ce8830) {
  "vector.transfer_write"(%31, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %31 = "math.cos"(%30) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%34) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %34 = "vector.contract"(%32, %33, %arg7) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %33 = "vector.transfer_read"(%26, %arg6, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x231a630) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %32 = "vector.transfer_read"(%24, %arg2, %arg6, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee500) {
  %26 = "memref.subview"(%12, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x231cb50) {
  %25 = "memref.subview"(%14, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21fd6a0) {
  %24 = "memref.subview"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %23 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %22 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %21 = "affine.apply"(%19) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %19 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %18 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %17 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %16 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %15 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2ee0) {
  "memref.assume_alignment"(%14) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2200d40) {
  %14 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %13 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xd0dcf0) {
  "memref.assume_alignment"(%12) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f3b60) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xef1cd0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xee4b70) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After IREEComprehensiveBufferize (iree-codegen-iree-comprehensive-bufferize) //----- //
module {
  func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
    %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
    %c16 = arith.constant 16 : index
    %c8 = arith.constant 8 : index
    %c32 = arith.constant 32 : index
    %c256 = arith.constant 256 : index
    %c128 = arith.constant 128 : index
    %c1024 = arith.constant 1024 : index
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
    memref.assume_alignment %0, 64 : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
    %1 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
    %2 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
    memref.assume_alignment %2, 64 : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
    %3 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
    %4 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
    memref.assume_alignment %4, 64 : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
    %5 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %6 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg0 = %6 to %c512 step %7 {
      %subview = memref.subview %0[%arg0, 0] [256, 256] [1, 1] : memref<512x256xf32, #hal.descriptor_type<storage_buffer>> to memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      scf.for %arg1 = %8 to %c1024 step %9 {
        %subview_1 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        %subview_2 = memref.subview %2[0, %arg1] [256, 128] [1, 1] : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %subview_1) -> (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
          %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
            %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %cst) -> (vector<8x32xf32>) {
              %14 = vector.transfer_read %subview[%arg2, %arg6], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x16xf32>
              %15 = vector.transfer_read %subview_2[%arg6, %arg4], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<16x32xf32>
              %16 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %14, %15, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
              scf.yield %16 : vector<8x32xf32>
            }
            %13 = math.cos %12 : vector<8x32xf32>
            vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
            scf.yield %arg5 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
          }
          scf.yield %11 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        }
        %subview_3 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%10 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) outs(%subview_3 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
        ^bb0(%in: f32, %out: f32):
          linalg.yield %in : f32
        }
      }
    }
    return
  }
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xeee440) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5060) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x231d7e0) {
  %28 = "memref.subview"(%14, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeee610) {
  "scf.yield"(%29) : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xcb2fb0) {
  "scf.yield"(%arg5) : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1ce8830) {
  "vector.transfer_write"(%31, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %31 = "math.cos"(%30) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%34) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %34 = "vector.contract"(%32, %33, %arg7) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %33 = "vector.transfer_read"(%26, %arg6, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x231a630) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %32 = "vector.transfer_read"(%24, %arg2, %arg6, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee500) {
  %26 = "memref.subview"(%12, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x231cb50) {
  %25 = "memref.subview"(%14, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21fd6a0) {
  %24 = "memref.subview"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %23 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %22 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %21 = "affine.apply"(%19) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %19 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %18 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %17 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %16 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %15 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2ee0) {
  "memref.assume_alignment"(%14) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2200d40) {
  %14 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %13 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xd0dcf0) {
  "memref.assume_alignment"(%12) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f3b60) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xef1cd0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xee4b70) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0xcf06e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After ResolveShapedTypeResultDims (resolve-shaped-type-result-dims) //----- //
module {
  func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
    %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
    %c16 = arith.constant 16 : index
    %c8 = arith.constant 8 : index
    %c32 = arith.constant 32 : index
    %c256 = arith.constant 256 : index
    %c128 = arith.constant 128 : index
    %c1024 = arith.constant 1024 : index
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 0.000000e+00 : f32
    %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
    memref.assume_alignment %0, 64 : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
    %1 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
    %2 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
    memref.assume_alignment %2, 64 : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
    %3 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
    %4 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
    memref.assume_alignment %4, 64 : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
    %5 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %6 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg0 = %6 to %c512 step %7 {
      %subview = memref.subview %0[%arg0, 0] [256, 256] [1, 1] : memref<512x256xf32, #hal.descriptor_type<storage_buffer>> to memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      scf.for %arg1 = %8 to %c1024 step %9 {
        %subview_1 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        %subview_2 = memref.subview %2[0, %arg1] [256, 128] [1, 1] : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %subview_1) -> (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
          %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
            %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %cst) -> (vector<8x32xf32>) {
              %14 = vector.transfer_read %subview[%arg2, %arg6], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x16xf32>
              %15 = vector.transfer_read %subview_2[%arg6, %arg4], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<16x32xf32>
              %16 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %14, %15, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
              scf.yield %16 : vector<8x32xf32>
            }
            %13 = math.cos %12 : vector<8x32xf32>
            vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
            scf.yield %arg5 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
          }
          scf.yield %11 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        }
        %subview_3 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%10 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) outs(%subview_3 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
        ^bb0(%in: f32, %out: f32):
          linalg.yield %in : f32
        }
      }
    }
    return
  }
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xee4b70) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xef1cd0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f3b60) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xd0dcf0) {
  "memref.assume_alignment"(%12) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %13 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2200d40) {
  %14 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2ee0) {
  "memref.assume_alignment"(%14) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %15 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %16 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %17 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %18 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %19 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %21 = "affine.apply"(%19) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %22 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %23 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21fd6a0) {
  %24 = "memref.subview"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x231cb50) {
  %25 = "memref.subview"(%14, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee500) {
  %26 = "memref.subview"(%12, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x231a630) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
    ** Insert  : 'scf.yield'(0x297b850)
    ** Insert  : 'scf.for'(0x2323f00)
    ** Erase   : 'scf.yield'(0xcb2fb0)
    ** Replace : 'scf.for'(0x231a630)
    ** Erase   : 'scf.for'(0x231a630)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xc89d80) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
    ** Insert  : 'scf.yield'(0x297b930)
    ** Insert  : 'scf.for'(0x297b990)
    ** Erase   : 'scf.yield'(0xeee610)
    ** Replace : 'scf.for'(0xc89d80)
    ** Erase   : 'scf.for'(0xc89d80)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %30 = "vector.transfer_read"(%24, %arg2, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %31 = "vector.transfer_read"(%26, %arg4, %arg3, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %32 = "vector.contract"(%30, %31, %arg5) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%32) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %29 = "math.cos"(%28) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1ce8830) {
  "vector.transfer_write"(%29, %25, %arg2, %arg3) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x231d7e0) {
  %27 = "memref.subview"(%14, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xeee440) {

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5060) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xee4b70) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xef1cd0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f3b60) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xd0dcf0) {
  "memref.assume_alignment"(%12) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %13 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2200d40) {
  %14 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2ee0) {
  "memref.assume_alignment"(%14) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %15 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %16 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %17 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %18 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %19 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %21 = "affine.apply"(%19) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %22 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %23 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21fd6a0) {
  %24 = "memref.subview"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x231cb50) {
  %25 = "memref.subview"(%14, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee500) {
  %26 = "memref.subview"(%12, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %30 = "vector.transfer_read"(%24, %arg2, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %31 = "vector.transfer_read"(%26, %arg4, %arg3, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %32 = "vector.contract"(%30, %31, %arg5) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%32) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %29 = "math.cos"(%28) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1ce8830) {
  "vector.transfer_write"(%29, %25, %arg2, %arg3) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x231d7e0) {
  %27 = "memref.subview"(%14, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xeee440) {

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0xee5060) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %0, 64 : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  %1 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %2, 64 : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  %3 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %4 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %4, 64 : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  %5 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %6 to %c512 step %7 {
    %subview = memref.subview %0[%arg0, 0] [256, 256] [1, 1] : memref<512x256xf32, #hal.descriptor_type<storage_buffer>> to memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
    scf.for %arg1 = %8 to %c1024 step %9 {
      %subview_1 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      %subview_2 = memref.subview %2[0, %arg1] [256, 128] [1, 1] : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      scf.for %arg2 = %c0 to %c256 step %c8 {
        scf.for %arg3 = %c0 to %c128 step %c32 {
          %10 = scf.for %arg4 = %c0 to %c256 step %c16 iter_args(%arg5 = %cst) -> (vector<8x32xf32>) {
            %12 = vector.transfer_read %subview[%arg2, %arg4], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x16xf32>
            %13 = vector.transfer_read %subview_2[%arg4, %arg3], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<16x32xf32>
            %14 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %12, %13, %arg5 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %14 : vector<8x32xf32>
          }
          %11 = math.cos %10 : vector<8x32xf32>
          vector.transfer_write %11, %subview_1[%arg2, %arg3] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        }
      }
      %subview_3 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%subview_1 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) outs(%subview_3 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
      ^bb0(%in: f32, %out: f32):
        linalg.yield %in : f32
      }
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %0, 64 : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  %1 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %2, 64 : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  %3 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %4 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %4, 64 : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  %5 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %6 to %c512 step %7 {
    %subview = memref.subview %0[%arg0, 0] [256, 256] [1, 1] : memref<512x256xf32, #hal.descriptor_type<storage_buffer>> to memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
    scf.for %arg1 = %8 to %c1024 step %9 {
      %subview_1 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      %subview_2 = memref.subview %2[0, %arg1] [256, 128] [1, 1] : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      scf.for %arg2 = %c0 to %c256 step %c8 {
        scf.for %arg3 = %c0 to %c128 step %c32 {
          %10 = scf.for %arg4 = %c0 to %c256 step %c16 iter_args(%arg5 = %cst) -> (vector<8x32xf32>) {
            %12 = vector.transfer_read %subview[%arg2, %arg4], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x16xf32>
            %13 = vector.transfer_read %subview_2[%arg4, %arg3], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<16x32xf32>
            %14 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %12, %13, %arg5 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %14 : vector<8x32xf32>
          }
          %11 = math.cos %10 : vector<8x32xf32>
          vector.transfer_write %11, %subview_1[%arg2, %arg3] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        }
      }
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%subview_1 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) outs(%subview_1 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
      ^bb0(%in: f32, %out: f32):
        linalg.yield %in : f32
      }
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xee4b70) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xef1cd0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f3b60) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xd0dcf0) {
  "memref.assume_alignment"(%12) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %13 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2200d40) {
  %14 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2ee0) {
  "memref.assume_alignment"(%14) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %15 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %16 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %17 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %18 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %19 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %21 = "affine.apply"(%19) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %22 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %23 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21fd6a0) {
  %24 = "memref.subview"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x231cb50) {
  %25 = "memref.subview"(%14, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee500) {
  %26 = "memref.subview"(%12, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %29 = "vector.transfer_read"(%24, %arg2, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %30 = "vector.transfer_read"(%26, %arg4, %arg3, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %31 = "vector.contract"(%29, %30, %arg5) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%31) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %28 = "math.cos"(%27) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1ce8830) {
  "vector.transfer_write"(%28, %25, %arg2, %arg3) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0xeee440) {

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
    ** Erase   : 'linalg.generic'(0xeee440)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xee4b70) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xef1cd0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f3b60) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xd0dcf0) {
  "memref.assume_alignment"(%12) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %13 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2200d40) {
  %14 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2ee0) {
  "memref.assume_alignment"(%14) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %15 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %16 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %17 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %18 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %19 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %21 = "affine.apply"(%19) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %22 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %23 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21fd6a0) {
  %24 = "memref.subview"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x231cb50) {
  %25 = "memref.subview"(%14, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee500) {
  %26 = "memref.subview"(%12, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %29 = "vector.transfer_read"(%24, %arg2, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %30 = "vector.transfer_read"(%26, %arg4, %arg3, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %31 = "vector.contract"(%29, %30, %arg5) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%31) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %28 = "math.cos"(%27) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1ce8830) {
  "vector.transfer_write"(%28, %25, %arg2, %arg3) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %0, 64 : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  %1 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %2, 64 : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  %3 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %4 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %4, 64 : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  %5 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %6 to %c512 step %7 {
    %subview = memref.subview %0[%arg0, 0] [256, 256] [1, 1] : memref<512x256xf32, #hal.descriptor_type<storage_buffer>> to memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
    scf.for %arg1 = %8 to %c1024 step %9 {
      %subview_1 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      %subview_2 = memref.subview %2[0, %arg1] [256, 128] [1, 1] : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      scf.for %arg2 = %c0 to %c256 step %c8 {
        scf.for %arg3 = %c0 to %c128 step %c32 {
          %10 = scf.for %arg4 = %c0 to %c256 step %c16 iter_args(%arg5 = %cst) -> (vector<8x32xf32>) {
            %12 = vector.transfer_read %subview[%arg2, %arg4], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x16xf32>
            %13 = vector.transfer_read %subview_2[%arg4, %arg3], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<16x32xf32>
            %14 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %12, %13, %arg5 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %14 : vector<8x32xf32>
          }
          %11 = math.cos %10 : vector<8x32xf32>
          vector.transfer_write %11, %subview_1[%arg2, %arg3] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        }
      }
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1ce8830) {
  "vector.transfer_write"(%28, %25, %arg2, %arg3) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %28 = "math.cos"(%27) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'math.cos -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%31) : (vector<8x32xf32>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %31 = "vector.contract"(%29, %30, %arg5) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %30 = "vector.transfer_read"(%26, %arg4, %arg3, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %29 = "vector.transfer_read"(%24, %arg2, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee500) {
  %26 = "memref.subview"(%12, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x231cb50) {
  %25 = "memref.subview"(%14, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21fd6a0) {
  %24 = "memref.subview"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %23 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %22 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %21 = "affine.apply"(%19) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %19 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.count -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %18 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %17 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.count -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %16 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %15 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<writeonly:tensor<512x1024xf32>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
    ** Erase   : 'hal.interface.binding.subspan'(0xd01aa0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2ee0) {
  "memref.assume_alignment"(%14) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2200d40) {
  %14 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcff010) {
  %13 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
    ** Erase   : 'hal.interface.binding.subspan'(0xcff010)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xd0dcf0) {
  "memref.assume_alignment"(%12) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f3b60) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xcfb090) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
    ** Erase   : 'hal.interface.binding.subspan'(0xcfb090)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xef1cd0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xee4b70) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1ce8830) {
  "vector.transfer_write"(%25, %22, %arg2, %arg3) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %25 = "math.cos"(%24) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'math.cos -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%28) : (vector<8x32xf32>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %28 = "vector.contract"(%26, %27, %arg5) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %27 = "vector.transfer_read"(%23, %arg4, %arg3, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %26 = "vector.transfer_read"(%21, %arg2, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee500) {
  %23 = "memref.subview"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x231cb50) {
  %22 = "memref.subview"(%12, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21fd6a0) {
  %21 = "memref.subview"(%10, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %20 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %18 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %16 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.count -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %15 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %14 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.count -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %13 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2ee0) {
  "memref.assume_alignment"(%12) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2200d40) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xd0dcf0) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f3b60) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xef1cd0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xee4b70) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CleanupBufferAllocView (iree-codegen-cleanup-buffer-alloc-view) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %0, 64 : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %1, 64 : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %2, 64 : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %subview = memref.subview %0[%arg0, 0] [256, 256] [1, 1] : memref<512x256xf32, #hal.descriptor_type<storage_buffer>> to memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %subview_1 = memref.subview %2[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      %subview_2 = memref.subview %1[0, %arg1] [256, 128] [1, 1] : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      scf.for %arg2 = %c0 to %c256 step %c8 {
        scf.for %arg3 = %c0 to %c128 step %c32 {
          %7 = scf.for %arg4 = %c0 to %c256 step %c16 iter_args(%arg5 = %cst) -> (vector<8x32xf32>) {
            %9 = vector.transfer_read %subview[%arg2, %arg4], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x16xf32>
            %10 = vector.transfer_read %subview_2[%arg4, %arg3], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<16x32xf32>
            %11 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %9, %10, %arg5 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %11 : vector<8x32xf32>
          }
          %8 = math.cos %7 : vector<8x32xf32>
          vector.transfer_write %8, %subview_1[%arg2, %arg3] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        }
      }
    }
  }
  return
}

// -----// IR Dump After EraseHALDescriptorTypeFromMemRef (iree-codegen-erase-hal-descriptor-type-from-memref) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %subview = memref.subview %0[%arg0, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %subview_1 = memref.subview %2[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
      %subview_2 = memref.subview %1[0, %arg1] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
      scf.for %arg2 = %c0 to %c256 step %c8 {
        scf.for %arg3 = %c0 to %c128 step %c32 {
          %7 = scf.for %arg4 = %c0 to %c256 step %c16 iter_args(%arg5 = %cst) -> (vector<8x32xf32>) {
            %9 = vector.transfer_read %subview[%arg2, %arg4], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
            %10 = vector.transfer_read %subview_2[%arg4, %arg3], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
            %11 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %9, %10, %arg5 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %11 : vector<8x32xf32>
          }
          %8 = math.cos %7 : vector<8x32xf32>
          vector.transfer_write %8, %subview_1[%arg2, %arg3] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
        }
      }
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecc450) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xecbbb0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%25, %22, %arg2, %arg3) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %25 = "math.cos"(%24) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%28) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %28 = "vector.contract"(%26, %27, %arg5) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %27 = "vector.transfer_read"(%23, %arg4, %arg3, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %26 = "vector.transfer_read"(%21, %arg2, %arg4, %9) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %23 = "memref.subview"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecbc10) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
    ** Replace : 'scf.for'(0xecbc10)
    ** Erase   : 'scf.for'(0xecbc10)
    ** Erase   : 'scf.yield'(0xecbbb0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %22 = "memref.subview"(%12, %arg0, %19) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0xecc4b0) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
    ** Replace : 'scf.for'(0xecc4b0)
    ** Erase   : 'scf.for'(0xecc4b0)
    ** Erase   : 'scf.yield'(0xecc450)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %21 = "memref.subview"(%10, %17) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %20 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xecd7a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %18 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xecc270)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2340) {
  %16 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

  ** Erase   : 'hal.interface.workgroup.count'(0xed2340)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %15 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0xed2280) {
  %14 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

  ** Erase   : 'hal.interface.workgroup.count'(0xed2280)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %13 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%12) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %9 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

  ** Erase   : 'arith.constant'(0xdfdf30)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xecf3e0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

  ** Erase   : 'arith.constant'(0xecf3e0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%22) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %22 = "vector.contract"(%20, %21, %arg3) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After RemoveSingleIterationLoop (iree-codegen-remove-single-iteration-loop) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %7, %8, %arg3 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
        scf.yield %9 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%22) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x232b530) {
  %22 = "vector.contract"(%20, %21, %arg3) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::ContractionOpToOuterProductOpLowering : 'vector.contract -> ()' {
    ** Insert  : 'vector.transpose'(0x2200d40)
    ** Insert  : 'vector.extract'(0xecbb30)
    ** Insert  : 'vector.extract'(0x21f3660)
    ** Insert  : 'vector.outerproduct'(0xecbc20)
    ** Insert  : 'vector.extract'(0x21f82b0)
    ** Insert  : 'vector.extract'(0x231dc80)
    ** Insert  : 'vector.outerproduct'(0x231cb50)
    ** Insert  : 'vector.extract'(0xcfb090)
    ** Insert  : 'vector.extract'(0xcff010)
    ** Insert  : 'vector.outerproduct'(0x29781a0)
    ** Insert  : 'vector.extract'(0xee4b70)
    ** Insert  : 'vector.extract'(0xecc270)
    ** Insert  : 'vector.outerproduct'(0xbcce30)
    ** Insert  : 'vector.extract'(0x2977de0)
    ** Insert  : 'vector.extract'(0xbccf00)
    ** Insert  : 'vector.outerproduct'(0x297b5b0)
    ** Insert  : 'vector.extract'(0x297b680)
    ** Insert  : 'vector.extract'(0xbccf90)
    ** Insert  : 'vector.outerproduct'(0x2977ee0)
    ** Insert  : 'vector.extract'(0x2977fb0)
    ** Insert  : 'vector.extract'(0x2978040)
    ** Insert  : 'vector.outerproduct'(0x297c420)
    ** Insert  : 'vector.extract'(0x297b710)
    ** Insert  : 'vector.extract'(0x297c4f0)
    ** Insert  : 'vector.outerproduct'(0x297c580)
    ** Insert  : 'vector.extract'(0x297c650)
    ** Insert  : 'vector.extract'(0x2978700)
    ** Insert  : 'vector.outerproduct'(0x2978790)
    ** Insert  : 'vector.extract'(0x2978860)
    ** Insert  : 'vector.extract'(0x29788f0)
    ** Insert  : 'vector.outerproduct'(0x2980400)
    ** Insert  : 'vector.extract'(0x29804d0)
    ** Insert  : 'vector.extract'(0x2980560)
    ** Insert  : 'vector.outerproduct'(0x29805f0)
    ** Insert  : 'vector.extract'(0x29806c0)
    ** Insert  : 'vector.extract'(0x2980750)
    ** Insert  : 'vector.outerproduct'(0x29807e0)
    ** Insert  : 'vector.extract'(0x29808b0)
    ** Insert  : 'vector.extract'(0x2980940)
    ** Insert  : 'vector.outerproduct'(0x29809d0)
    ** Insert  : 'vector.extract'(0x2980aa0)
    ** Insert  : 'vector.extract'(0x2980b30)
    ** Insert  : 'vector.outerproduct'(0x2980bc0)
    ** Insert  : 'vector.extract'(0x2980c90)
    ** Insert  : 'vector.extract'(0x2980d20)
    ** Insert  : 'vector.outerproduct'(0x2980db0)
    ** Insert  : 'vector.extract'(0x2980e80)
    ** Insert  : 'vector.extract'(0x2980f10)
    ** Insert  : 'vector.outerproduct'(0x2980fa0)
    ** Replace : 'vector.contract'(0x232b530)
    ** Erase   : 'vector.contract'(0x232b530)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyLowerVectorsPass (iree-linalg-strategy-lower-vectors-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgVectorLowering (linalg-vector-lowering) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::FoldTransposedScalarBroadcast : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTransposeSplat : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyLowerVectorsPass (iree-linalg-strategy-lower-vectors-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgVectorLowering (linalg-vector-lowering) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::FoldTransposedScalarBroadcast : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTransposeSplat : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'math.cos -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyLowerVectorsPass (iree-linalg-strategy-lower-vectors-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgVectorLowering (linalg-vector-lowering) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::FoldTransposedScalarBroadcast : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTransposeSplat : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Failure : rank exceeds maxTransferRank: vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'math.cos -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyLowerVectorsPass (iree-linalg-strategy-lower-vectors-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgVectorLowering (linalg-vector-lowering) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %7 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %20 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %21 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %22 = "vector.transpose"(%20) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::FoldTransposedScalarBroadcast : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTransposeSplat : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %23 = "vector.extract"(%22) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %24 = "vector.extract"(%21) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %25 = "vector.outerproduct"(%23, %24, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %26 = "vector.extract"(%22) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %27 = "vector.extract"(%21) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %28 = "vector.outerproduct"(%26, %27, %25) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %29 = "vector.extract"(%22) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %30 = "vector.extract"(%21) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %31 = "vector.outerproduct"(%29, %30, %28) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %32 = "vector.extract"(%22) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %33 = "vector.extract"(%21) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %34 = "vector.outerproduct"(%32, %33, %31) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %35 = "vector.extract"(%22) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %36 = "vector.extract"(%21) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %37 = "vector.outerproduct"(%35, %36, %34) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %38 = "vector.extract"(%22) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %39 = "vector.extract"(%21) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %40 = "vector.outerproduct"(%38, %39, %37) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %41 = "vector.extract"(%22) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %42 = "vector.extract"(%21) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %44 = "vector.extract"(%22) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %45 = "vector.extract"(%21) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %47 = "vector.extract"(%22) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %48 = "vector.extract"(%21) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %50 = "vector.extract"(%22) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %51 = "vector.extract"(%21) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %53 = "vector.extract"(%22) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %54 = "vector.extract"(%21) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %56 = "vector.extract"(%22) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %57 = "vector.extract"(%21) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %59 = "vector.extract"(%22) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %60 = "vector.extract"(%21) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %62 = "vector.extract"(%22) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %63 = "vector.extract"(%21) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %65 = "vector.extract"(%22) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %66 = "vector.extract"(%21) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %68 = "vector.extract"(%22) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %69 = "vector.extract"(%21) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%70) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %cst_0 = arith.constant 0.000000e+00 : f32
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst_0 {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_2[%arg2, %arg1], %cst_0 {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcd3380) {
  "vector.transfer_write"(%19, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Failure : rank exceeds maxTransferRank: vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::lowering_n_d_unrolled::UnrollTransferWriteConversion : 'vector.transfer_write -> ()' {
    ** Insert  : 'arith.constant'(0x297acf0)
    ** Insert  : 'affine.apply'(0xecd7a0)
    ** Insert  : 'vector.extract'(0x21f3b60)
    ** Insert  : 'vector.transfer_write'(0x1ce8830)
    ** Insert  : 'arith.constant'(0x2978ca0)
    ** Insert  : 'affine.apply'(0x2983ab0)
    ** Insert  : 'vector.extract'(0x2984750)
    ** Insert  : 'vector.transfer_write'(0xd09cd0)
    ** Insert  : 'arith.constant'(0x2978440)
    ** Insert  : 'affine.apply'(0x29847e0)
    ** Insert  : 'vector.extract'(0x297a390)
    ** Insert  : 'vector.transfer_write'(0xcc3cd0)
    ** Insert  : 'arith.constant'(0x2978140)
    ** Insert  : 'affine.apply'(0x297a420)
    ** Insert  : 'vector.extract'(0x297a4b0)
    ** Insert  : 'vector.transfer_write'(0xbad430)
    ** Insert  : 'arith.constant'(0x2977d80)
    ** Insert  : 'affine.apply'(0x297fbf0)
    ** Insert  : 'vector.extract'(0x297fc80)
    ** Insert  : 'vector.transfer_write'(0xbacce0)
    ** Insert  : 'arith.constant'(0xdfdf30)
    ** Insert  : 'affine.apply'(0x297fe30)
    ** Insert  : 'vector.extract'(0x297fec0)
    ** Insert  : 'vector.transfer_write'(0xba1190)
    ** Insert  : 'arith.constant'(0xdfb0a0)
    ** Insert  : 'affine.apply'(0x2980020)
    ** Insert  : 'vector.extract'(0x2986390)
    ** Insert  : 'vector.transfer_write'(0xba34b0)
    ** Insert  : 'arith.constant'(0xed2280)
    ** Insert  : 'affine.apply'(0x2986420)
    ** Insert  : 'vector.extract'(0x29864b0)
    ** Insert  : 'vector.transfer_write'(0x2986530)
    ** Erase   : 'vector.transfer_write'(0xcd3380)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x2986530) {
  "vector.transfer_write"(%43, %16, %42, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0xcd3380)
    ** Replace : 'vector.transfer_write'(0x2986530)
    ** Erase   : 'vector.transfer_write'(0x2986530)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%43, %16, %42, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %43 = "vector.extract"(%19) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2986420) {
  %42 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xed2280) {
  %41 = "arith.constant"() {value = 7 : index} : () -> index

  ** Erase   : 'arith.constant'(0xed2280)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xba34b0) {
  "vector.transfer_write"(%40, %16, %39, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0x2986530)
    ** Replace : 'vector.transfer_write'(0xba34b0)
    ** Erase   : 'vector.transfer_write'(0xba34b0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%40, %16, %39, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %40 = "vector.extract"(%19) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2980020) {
  %39 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfb0a0) {
  %38 = "arith.constant"() {value = 6 : index} : () -> index

  ** Erase   : 'arith.constant'(0xdfb0a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xba1190) {
  "vector.transfer_write"(%37, %16, %36, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0xba34b0)
    ** Replace : 'vector.transfer_write'(0xba1190)
    ** Erase   : 'vector.transfer_write'(0xba1190)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%37, %16, %36, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %37 = "vector.extract"(%19) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297fe30) {
  %36 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %35 = "arith.constant"() {value = 5 : index} : () -> index

  ** Erase   : 'arith.constant'(0xdfdf30)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xbacce0) {
  "vector.transfer_write"(%34, %16, %33, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0xba1190)
    ** Replace : 'vector.transfer_write'(0xbacce0)
    ** Erase   : 'vector.transfer_write'(0xbacce0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%34, %16, %33, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %34 = "vector.extract"(%19) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297fbf0) {
  %33 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2977d80) {
  %32 = "arith.constant"() {value = 4 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2977d80)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xbad430) {
  "vector.transfer_write"(%31, %16, %30, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0xbacce0)
    ** Replace : 'vector.transfer_write'(0xbad430)
    ** Erase   : 'vector.transfer_write'(0xbad430)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%31, %16, %30, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %31 = "vector.extract"(%19) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297a420) {
  %30 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978140) {
  %29 = "arith.constant"() {value = 3 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2978140)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xcc3cd0) {
  "vector.transfer_write"(%28, %16, %27, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0xbad430)
    ** Replace : 'vector.transfer_write'(0xcc3cd0)
    ** Erase   : 'vector.transfer_write'(0xcc3cd0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%28, %16, %27, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %28 = "vector.extract"(%19) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29847e0) {
  %27 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978440) {
  %26 = "arith.constant"() {value = 2 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2978440)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0xd09cd0) {
  "vector.transfer_write"(%25, %16, %24, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0xcc3cd0)
    ** Replace : 'vector.transfer_write'(0xd09cd0)
    ** Erase   : 'vector.transfer_write'(0xd09cd0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%25, %16, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %25 = "vector.extract"(%19) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2983ab0) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978ca0) {
  %23 = "arith.constant"() {value = 1 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2978ca0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1ce8830) {
  "vector.transfer_write"(%22, %16, %21, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0xd09cd0)
    ** Replace : 'vector.transfer_write'(0x1ce8830)
    ** Erase   : 'vector.transfer_write'(0x1ce8830)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%22, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %22 = "vector.extract"(%19) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xecd7a0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%21, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x297acf0) {
  %20 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x297acf0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'math.cos -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%85) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %85 = "vector.outerproduct"(%83, %84, %82) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %84 = "vector.extract"(%36) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %83 = "vector.extract"(%37) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %82 = "vector.outerproduct"(%80, %81, %79) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %81 = "vector.extract"(%36) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %80 = "vector.extract"(%37) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %79 = "vector.outerproduct"(%77, %78, %76) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %78 = "vector.extract"(%36) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %77 = "vector.extract"(%37) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %76 = "vector.outerproduct"(%74, %75, %73) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %75 = "vector.extract"(%36) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %74 = "vector.extract"(%37) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %73 = "vector.outerproduct"(%71, %72, %70) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %72 = "vector.extract"(%36) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %71 = "vector.extract"(%37) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %70 = "vector.outerproduct"(%68, %69, %67) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %69 = "vector.extract"(%36) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %68 = "vector.extract"(%37) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %67 = "vector.outerproduct"(%65, %66, %64) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %66 = "vector.extract"(%36) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %65 = "vector.extract"(%37) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %64 = "vector.outerproduct"(%62, %63, %61) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %63 = "vector.extract"(%36) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %62 = "vector.extract"(%37) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %61 = "vector.outerproduct"(%59, %60, %58) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %60 = "vector.extract"(%36) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %59 = "vector.extract"(%37) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %58 = "vector.outerproduct"(%56, %57, %55) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %57 = "vector.extract"(%36) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %56 = "vector.extract"(%37) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %55 = "vector.outerproduct"(%53, %54, %52) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %54 = "vector.extract"(%36) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %53 = "vector.extract"(%37) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %52 = "vector.outerproduct"(%50, %51, %49) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %51 = "vector.extract"(%36) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %50 = "vector.extract"(%37) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %49 = "vector.outerproduct"(%47, %48, %46) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %48 = "vector.extract"(%36) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %47 = "vector.extract"(%37) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %46 = "vector.outerproduct"(%44, %45, %43) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %45 = "vector.extract"(%36) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %44 = "vector.extract"(%37) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %43 = "vector.outerproduct"(%41, %42, %40) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %42 = "vector.extract"(%36) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %41 = "vector.extract"(%37) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %40 = "vector.outerproduct"(%38, %39, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %39 = "vector.extract"(%36) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %38 = "vector.extract"(%37) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %37 = "vector.transpose"(%35) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %36 = "vector.transfer_read"(%17, %arg2, %arg1, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::lowering_n_d_unrolled::UnrollTransferReadConversion : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.splat'(0xecd7a0)
    ** Insert  : 'arith.constant'(0x2978440)
    ** Insert  : 'affine.apply'(0x29871b0)
    ** Insert  : 'vector.transfer_read'(0xc82690)
    ** Insert  : 'vector.insert'(0x21fd6a0)
    ** Insert  : 'arith.constant'(0x2978140)
    ** Insert  : 'affine.apply'(0x29859a0)
    ** Insert  : 'vector.transfer_read'(0xc82930)
    ** Insert  : 'vector.insert'(0xeee500)
    ** Insert  : 'arith.constant'(0x2977d80)
    ** Insert  : 'affine.apply'(0x2985a30)
    ** Insert  : 'vector.transfer_read'(0xc68a50)
    ** Insert  : 'vector.insert'(0x21f4ef0)
    ** Insert  : 'arith.constant'(0xdfdf30)
    ** Insert  : 'affine.apply'(0x2985ac0)
    ** Insert  : 'vector.transfer_read'(0x21f97d0)
    ** Insert  : 'vector.insert'(0x21f4fe0)
    ** Insert  : 'arith.constant'(0xdfb0a0)
    ** Insert  : 'affine.apply'(0x2985b50)
    ** Insert  : 'vector.transfer_read'(0xc8fbb0)
    ** Insert  : 'vector.insert'(0xcb2e40)
    ** Insert  : 'arith.constant'(0xed2280)
    ** Insert  : 'affine.apply'(0x2985be0)
    ** Insert  : 'vector.transfer_read'(0xcb9190)
    ** Insert  : 'vector.insert'(0x232b6b0)
    ** Insert  : 'arith.constant'(0xed2340)
    ** Insert  : 'affine.apply'(0x297e520)
    ** Insert  : 'vector.transfer_read'(0x297e5b0)
    ** Insert  : 'vector.insert'(0x232b600)
    ** Insert  : 'arith.constant'(0x29800b0)
    ** Insert  : 'affine.apply'(0x297e6a0)
    ** Insert  : 'vector.transfer_read'(0x297e730)
    ** Insert  : 'vector.insert'(0x297e820)
    ** Insert  : 'arith.constant'(0x297acf0)
    ** Insert  : 'affine.apply'(0x297e8d0)
    ** Insert  : 'vector.transfer_read'(0x297e960)
    ** Insert  : 'vector.insert'(0x297ea50)
    ** Insert  : 'arith.constant'(0x2978ca0)
    ** Insert  : 'affine.apply'(0x297eb00)
    ** Insert  : 'vector.transfer_read'(0x297d1b0)
    ** Insert  : 'vector.insert'(0x297d2a0)
    ** Insert  : 'arith.constant'(0x297d350)
    ** Insert  : 'affine.apply'(0x297d3b0)
    ** Insert  : 'vector.transfer_read'(0x297d440)
    ** Insert  : 'vector.insert'(0x297d530)
    ** Insert  : 'arith.constant'(0x297d5e0)
    ** Insert  : 'affine.apply'(0x297d640)
    ** Insert  : 'vector.transfer_read'(0x297d6d0)
    ** Insert  : 'vector.insert'(0x297d7c0)
    ** Insert  : 'arith.constant'(0x2986620)
    ** Insert  : 'affine.apply'(0x2988f30)
    ** Insert  : 'vector.transfer_read'(0x2988fc0)
    ** Insert  : 'vector.insert'(0x29890b0)
    ** Insert  : 'arith.constant'(0x2985c70)
    ** Insert  : 'affine.apply'(0x2989160)
    ** Insert  : 'vector.transfer_read'(0x29891f0)
    ** Insert  : 'vector.insert'(0x29892e0)
    ** Insert  : 'arith.constant'(0x2989390)
    ** Insert  : 'affine.apply'(0x29893f0)
    ** Insert  : 'vector.transfer_read'(0x2989480)
    ** Insert  : 'vector.insert'(0x2989570)
    ** Insert  : 'arith.constant'(0x2989620)
    ** Insert  : 'affine.apply'(0x2989680)
    ** Insert  : 'vector.transfer_read'(0x1ce7480)
    ** Insert  : 'vector.insert'(0x1ce7570)
    ** Replace : 'vector.transfer_read'(0xc827e0)
    ** Erase   : 'vector.transfer_read'(0xc827e0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3660) {
  %103 = "vector.extract"(%100) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x21f3660)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %103 = "vector.outerproduct"(%102, %39, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x231dc80) {
  %105 = "vector.extract"(%100) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x231dc80)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %105 = "vector.outerproduct"(%104, %43, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcff010) {
  %107 = "vector.extract"(%100) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0xcff010)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %107 = "vector.outerproduct"(%106, %47, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecc270) {
  %109 = "vector.extract"(%100) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0xecc270)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %109 = "vector.outerproduct"(%108, %51, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf00) {
  %111 = "vector.extract"(%100) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0xbccf00)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %111 = "vector.outerproduct"(%110, %55, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xbccf90) {
  %113 = "vector.extract"(%100) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0xbccf90)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %113 = "vector.outerproduct"(%112, %59, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978040) {
  %115 = "vector.extract"(%100) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x2978040)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %115 = "vector.outerproduct"(%114, %63, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c4f0) {
  %117 = "vector.extract"(%100) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x297c4f0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %117 = "vector.outerproduct"(%116, %67, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978700) {
  %119 = "vector.extract"(%100) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x2978700)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %119 = "vector.outerproduct"(%118, %71, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29788f0) {
  %121 = "vector.extract"(%100) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x29788f0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %121 = "vector.outerproduct"(%120, %75, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980560) {
  %123 = "vector.extract"(%100) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x2980560)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %123 = "vector.outerproduct"(%122, %79, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980750) {
  %125 = "vector.extract"(%100) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x2980750)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %125 = "vector.outerproduct"(%124, %83, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980940) {
  %127 = "vector.extract"(%100) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x2980940)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %127 = "vector.outerproduct"(%126, %87, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980b30) {
  %129 = "vector.extract"(%100) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x2980b30)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %129 = "vector.outerproduct"(%128, %91, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980d20) {
  %131 = "vector.extract"(%100) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x2980d20)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %131 = "vector.outerproduct"(%130, %95, %129) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %133 = "vector.extract"(%100) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x2980f10)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %133 = "vector.outerproduct"(%132, %99, %131) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7570) {
  %100 = "vector.insert"(%99, %96) {position = [15]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x1ce7570)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1ce7480) {
  %99 = "vector.transfer_read"(%17, %98, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x29858d0)
    ** Replace : 'vector.transfer_read'(0x1ce7480)
    ** Erase   : 'vector.transfer_read'(0x1ce7480)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %132 = "vector.outerproduct"(%131, %99, %130) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %99 = "vector.load"(%17, %98, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %98 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2989620) {
  %97 = "arith.constant"() {value = 15 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2989620)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2989570) {
  %96 = "vector.insert"(%95, %92) {position = [14]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x2989570)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x2989480) {
  %95 = "vector.transfer_read"(%17, %94, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x1ce7620)
    ** Replace : 'vector.transfer_read'(0x2989480)
    ** Erase   : 'vector.transfer_read'(0x2989480)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %128 = "vector.outerproduct"(%127, %95, %126) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %95 = "vector.load"(%17, %94, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %94 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2989390) {
  %93 = "arith.constant"() {value = 14 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2989390)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29892e0) {
  %92 = "vector.insert"(%91, %88) {position = [13]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x29892e0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x29891f0) {
  %91 = "vector.transfer_read"(%17, %90, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x1ce76f0)
    ** Replace : 'vector.transfer_read'(0x29891f0)
    ** Erase   : 'vector.transfer_read'(0x29891f0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %124 = "vector.outerproduct"(%123, %91, %122) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %91 = "vector.load"(%17, %90, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %90 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2985c70) {
  %89 = "arith.constant"() {value = 13 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2985c70)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29890b0) {
  %88 = "vector.insert"(%87, %84) {position = [12]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x29890b0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x2988fc0) {
  %87 = "vector.transfer_read"(%17, %86, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x1ce77c0)
    ** Replace : 'vector.transfer_read'(0x2988fc0)
    ** Erase   : 'vector.transfer_read'(0x2988fc0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %120 = "vector.outerproduct"(%119, %87, %118) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %87 = "vector.load"(%17, %86, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %86 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2986620) {
  %85 = "arith.constant"() {value = 12 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2986620)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d7c0) {
  %84 = "vector.insert"(%83, %80) {position = [11]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x297d7c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x297d6d0) {
  %83 = "vector.transfer_read"(%17, %82, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x1ce7890)
    ** Replace : 'vector.transfer_read'(0x297d6d0)
    ** Erase   : 'vector.transfer_read'(0x297d6d0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %116 = "vector.outerproduct"(%115, %83, %114) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %83 = "vector.load"(%17, %82, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %82 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x297d5e0) {
  %81 = "arith.constant"() {value = 11 : index} : () -> index

  ** Erase   : 'arith.constant'(0x297d5e0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d530) {
  %80 = "vector.insert"(%79, %76) {position = [10]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x297d530)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x297d440) {
  %79 = "vector.transfer_read"(%17, %78, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x1ce7960)
    ** Replace : 'vector.transfer_read'(0x297d440)
    ** Erase   : 'vector.transfer_read'(0x297d440)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %112 = "vector.outerproduct"(%111, %79, %110) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %79 = "vector.load"(%17, %78, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %78 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x297d350) {
  %77 = "arith.constant"() {value = 10 : index} : () -> index

  ** Erase   : 'arith.constant'(0x297d350)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d2a0) {
  %76 = "vector.insert"(%75, %72) {position = [9]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x297d2a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x297d1b0) {
  %75 = "vector.transfer_read"(%17, %74, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x1ce7a30)
    ** Replace : 'vector.transfer_read'(0x297d1b0)
    ** Erase   : 'vector.transfer_read'(0x297d1b0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %108 = "vector.outerproduct"(%107, %75, %106) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %75 = "vector.load"(%17, %74, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %74 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978ca0) {
  %73 = "arith.constant"() {value = 9 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2978ca0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297ea50) {
  %72 = "vector.insert"(%71, %68) {position = [8]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x297ea50)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x297e960) {
  %71 = "vector.transfer_read"(%17, %70, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x297d1b0)
    ** Replace : 'vector.transfer_read'(0x297e960)
    ** Erase   : 'vector.transfer_read'(0x297e960)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %104 = "vector.outerproduct"(%103, %71, %102) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %71 = "vector.load"(%17, %70, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %70 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x297acf0) {
  %69 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x297acf0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297e820) {
  %68 = "vector.insert"(%67, %64) {position = [7]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x297e820)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x297e730) {
  %67 = "vector.transfer_read"(%17, %66, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x1ce7b00)
    ** Replace : 'vector.transfer_read'(0x297e730)
    ** Erase   : 'vector.transfer_read'(0x297e730)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %100 = "vector.outerproduct"(%99, %67, %98) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %67 = "vector.load"(%17, %66, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %66 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x29800b0) {
  %65 = "arith.constant"() {value = 7 : index} : () -> index

  ** Erase   : 'arith.constant'(0x29800b0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x232b600) {
  %64 = "vector.insert"(%63, %60) {position = [6]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x232b600)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x297e5b0) {
  %63 = "vector.transfer_read"(%17, %62, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x297e960)
    ** Replace : 'vector.transfer_read'(0x297e5b0)
    ** Erase   : 'vector.transfer_read'(0x297e5b0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %96 = "vector.outerproduct"(%95, %63, %94) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %63 = "vector.load"(%17, %62, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %62 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xed2340) {
  %61 = "arith.constant"() {value = 6 : index} : () -> index

  ** Erase   : 'arith.constant'(0xed2340)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x232b6b0) {
  %60 = "vector.insert"(%59, %56) {position = [5]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x232b6b0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xcb9190) {
  %59 = "vector.transfer_read"(%17, %58, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x297ea30)
    ** Replace : 'vector.transfer_read'(0xcb9190)
    ** Erase   : 'vector.transfer_read'(0xcb9190)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %92 = "vector.outerproduct"(%91, %59, %90) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %59 = "vector.load"(%17, %58, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %58 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xed2280) {
  %57 = "arith.constant"() {value = 5 : index} : () -> index

  ** Erase   : 'arith.constant'(0xed2280)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0xcb2e40) {
  %56 = "vector.insert"(%55, %52) {position = [4]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0xcb2e40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc8fbb0) {
  %55 = "vector.transfer_read"(%17, %54, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x297e5b0)
    ** Replace : 'vector.transfer_read'(0xc8fbb0)
    ** Erase   : 'vector.transfer_read'(0xc8fbb0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %88 = "vector.outerproduct"(%87, %55, %86) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %55 = "vector.load"(%17, %54, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %54 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfb0a0) {
  %53 = "arith.constant"() {value = 4 : index} : () -> index

  ** Erase   : 'arith.constant'(0xdfb0a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x21f4fe0) {
  %52 = "vector.insert"(%51, %48) {position = [3]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x21f4fe0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x21f97d0) {
  %51 = "vector.transfer_read"(%17, %50, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0xcb9190)
    ** Replace : 'vector.transfer_read'(0x21f97d0)
    ** Erase   : 'vector.transfer_read'(0x21f97d0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %84 = "vector.outerproduct"(%83, %51, %82) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %51 = "vector.load"(%17, %50, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %50 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %49 = "arith.constant"() {value = 3 : index} : () -> index

  ** Erase   : 'arith.constant'(0xdfdf30)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x21f4ef0) {
  %48 = "vector.insert"(%47, %44) {position = [2]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x21f4ef0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc68a50) {
  %47 = "vector.transfer_read"(%17, %46, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0xc8fbb0)
    ** Replace : 'vector.transfer_read'(0xc68a50)
    ** Erase   : 'vector.transfer_read'(0xc68a50)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %80 = "vector.outerproduct"(%79, %47, %78) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %47 = "vector.load"(%17, %46, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %46 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2977d80) {
  %45 = "arith.constant"() {value = 2 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2977d80)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0xeee500) {
  %44 = "vector.insert"(%43, %40) {position = [1]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0xeee500)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82930) {
  %43 = "vector.transfer_read"(%17, %42, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x21f97d0)
    ** Replace : 'vector.transfer_read'(0xc82930)
    ** Erase   : 'vector.transfer_read'(0xc82930)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %76 = "vector.outerproduct"(%75, %43, %74) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %43 = "vector.load"(%17, %42, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %42 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978140) {
  %41 = "arith.constant"() {value = 1 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2978140)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x21fd6a0) {
  %40 = "vector.insert"(%39, %36) {position = [0]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x21fd6a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %39 = "vector.transfer_read"(%17, %38, %arg1, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0xc68a50)
    ** Replace : 'vector.transfer_read'(0xc82690)
    ** Erase   : 'vector.transfer_read'(0xc82690)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %72 = "vector.outerproduct"(%71, %39, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %39 = "vector.load"(%17, %38, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29871b0) {
  %38 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x29871b0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %38 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978440) {
  %37 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2978440)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.splat'(0xecd7a0) {
  %36 = "vector.splat"(%7) : (f32) -> vector<16x32xf32>

  ** Erase   : 'vector.splat'(0xecd7a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc28af0) {
  %35 = "vector.transfer_read"(%15, %arg0, %arg2, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::lowering_n_d_unrolled::UnrollTransferReadConversion : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.splat'(0x2978040)
    ** Insert  : 'arith.constant'(0x297acf0)
    ** Insert  : 'affine.apply'(0xbccf90)
    ** Insert  : 'vector.transfer_read'(0x297d440)
    ** Insert  : 'vector.insert'(0x297d2a0)
    ** Insert  : 'arith.constant'(0x2978ca0)
    ** Insert  : 'affine.apply'(0xbccf00)
    ** Insert  : 'vector.transfer_read'(0x297d6d0)
    ** Insert  : 'vector.insert'(0x297d530)
    ** Insert  : 'arith.constant'(0x297d350)
    ** Insert  : 'affine.apply'(0xecc270)
    ** Insert  : 'vector.transfer_read'(0x2988fc0)
    ** Insert  : 'vector.insert'(0x297d7c0)
    ** Insert  : 'arith.constant'(0x297d5e0)
    ** Insert  : 'affine.apply'(0xcff010)
    ** Insert  : 'vector.transfer_read'(0x29891f0)
    ** Insert  : 'vector.insert'(0x29890b0)
    ** Insert  : 'arith.constant'(0x2985c70)
    ** Insert  : 'affine.apply'(0x231dc80)
    ** Insert  : 'vector.transfer_read'(0x2989480)
    ** Insert  : 'vector.insert'(0x29892e0)
    ** Insert  : 'arith.constant'(0x2989390)
    ** Insert  : 'affine.apply'(0x21f3660)
    ** Insert  : 'vector.transfer_read'(0x1ce7480)
    ** Insert  : 'vector.insert'(0x2989570)
    ** Insert  : 'arith.constant'(0x2989620)
    ** Insert  : 'affine.apply'(0x29788f0)
    ** Insert  : 'vector.transfer_read'(0xc827e0)
    ** Insert  : 'vector.insert'(0x1ce7570)
    ** Insert  : 'arith.constant'(0x29800b0)
    ** Insert  : 'affine.apply'(0xecd7a0)
    ** Insert  : 'vector.transfer_read'(0xc82690)
    ** Insert  : 'vector.insert'(0x1ce7bd0)
    ** Replace : 'vector.transfer_read'(0xc28af0)
    ** Erase   : 'vector.transfer_read'(0xc28af0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %99 = "vector.transpose"(%67) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7bd0) {
  %67 = "vector.insert"(%66, %63) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc82690) {
  %66 = "vector.transfer_read"(%15, %65, %arg2, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0xc82930)
    ** Replace : 'vector.transfer_read'(0xc82690)
    ** Erase   : 'vector.transfer_read'(0xc82690)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7bd0) {
  %67 = "vector.insert"(%66, %63) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %66 = "vector.load"(%15, %65, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %65 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x29800b0) {
  %64 = "arith.constant"() {value = 7 : index} : () -> index

  ** Erase   : 'arith.constant'(0x29800b0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7570) {
  %63 = "vector.insert"(%62, %59) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0xc827e0) {
  %62 = "vector.transfer_read"(%15, %61, %arg2, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x232b600)
    ** Replace : 'vector.transfer_read'(0xc827e0)
    ** Erase   : 'vector.transfer_read'(0xc827e0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7570) {
  %63 = "vector.insert"(%62, %59) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %62 = "vector.load"(%15, %61, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %61 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2989620) {
  %60 = "arith.constant"() {value = 6 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2989620)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2989570) {
  %59 = "vector.insert"(%58, %55) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1ce7480) {
  %58 = "vector.transfer_read"(%15, %57, %arg2, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x297e730)
    ** Replace : 'vector.transfer_read'(0x1ce7480)
    ** Erase   : 'vector.transfer_read'(0x1ce7480)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2989570) {
  %59 = "vector.insert"(%58, %55) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %58 = "vector.load"(%15, %57, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %57 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2989390) {
  %56 = "arith.constant"() {value = 5 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2989390)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29892e0) {
  %55 = "vector.insert"(%54, %51) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x2989480) {
  %54 = "vector.transfer_read"(%15, %53, %arg2, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x297e800)
    ** Replace : 'vector.transfer_read'(0x2989480)
    ** Erase   : 'vector.transfer_read'(0x2989480)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29892e0) {
  %55 = "vector.insert"(%54, %51) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %54 = "vector.load"(%15, %53, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %53 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2985c70) {
  %52 = "arith.constant"() {value = 4 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2985c70)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29890b0) {
  %51 = "vector.insert"(%50, %47) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x29891f0) {
  %50 = "vector.transfer_read"(%15, %49, %arg2, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x2990fb0)
    ** Replace : 'vector.transfer_read'(0x29891f0)
    ** Erase   : 'vector.transfer_read'(0x29891f0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29890b0) {
  %51 = "vector.insert"(%50, %47) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %50 = "vector.load"(%15, %49, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %49 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x297d5e0) {
  %48 = "arith.constant"() {value = 3 : index} : () -> index

  ** Erase   : 'arith.constant'(0x297d5e0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d7c0) {
  %47 = "vector.insert"(%46, %43) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x2988fc0) {
  %46 = "vector.transfer_read"(%15, %45, %arg2, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x2991080)
    ** Replace : 'vector.transfer_read'(0x2988fc0)
    ** Erase   : 'vector.transfer_read'(0x2988fc0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d7c0) {
  %47 = "vector.insert"(%46, %43) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %46 = "vector.load"(%15, %45, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %45 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x297d350) {
  %44 = "arith.constant"() {value = 2 : index} : () -> index

  ** Erase   : 'arith.constant'(0x297d350)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d530) {
  %43 = "vector.insert"(%42, %39) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x297d6d0) {
  %42 = "vector.transfer_read"(%15, %41, %arg2, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x2991150)
    ** Replace : 'vector.transfer_read'(0x297d6d0)
    ** Erase   : 'vector.transfer_read'(0x297d6d0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d530) {
  %43 = "vector.insert"(%42, %39) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %42 = "vector.load"(%15, %41, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %41 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978ca0) {
  %40 = "arith.constant"() {value = 1 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2978ca0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d2a0) {
  %39 = "vector.insert"(%38, %35) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x297d440) {
  %38 = "vector.transfer_read"(%15, %37, %arg2, %7) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x297d6d0)
    ** Replace : 'vector.transfer_read'(0x297d440)
    ** Erase   : 'vector.transfer_read'(0x297d440)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d2a0) {
  %39 = "vector.insert"(%38, %35) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %38 = "vector.load"(%15, %37, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf90) {
  %37 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0)>} : (index) -> index

  ** Erase   : 'affine.apply'(0xbccf90)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %37 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x297acf0) {
  %36 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x297acf0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.splat'(0x2978040) {
  %35 = "vector.splat"(%7) : (f32) -> vector<8x16xf32>

  ** Erase   : 'vector.splat'(0x2978040)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d2a0) {
  %37 = "vector.insert"(%36, %0) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978440) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %18 = "memref.subview"(%10, %15) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %17 = "memref.subview"(%11, %14, %15) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %15 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %14 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %11 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcf31d0) {
  %8 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

  ** Erase   : 'arith.constant'(0xcf31d0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%34, %16, %33, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %34 = "vector.extract"(%19) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2986420) {
  %33 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%32, %16, %31, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %32 = "vector.extract"(%19) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2980020) {
  %31 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%30, %16, %29, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %30 = "vector.extract"(%19) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297fe30) {
  %29 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%28, %16, %27, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %28 = "vector.extract"(%19) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297fbf0) {
  %27 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%26, %16, %25, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %26 = "vector.extract"(%19) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297a420) {
  %25 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%24, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %24 = "vector.extract"(%19) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29847e0) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%22, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %22 = "vector.extract"(%19) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2983ab0) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%20, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %20 = "vector.extract"(%19) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'math.cos -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%121) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %121 = "vector.outerproduct"(%120, %88, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %120 = "vector.extract"(%89) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %119 = "vector.outerproduct"(%118, %86, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %118 = "vector.extract"(%89) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %117 = "vector.outerproduct"(%116, %84, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %116 = "vector.extract"(%89) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %115 = "vector.outerproduct"(%114, %82, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %114 = "vector.extract"(%89) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %113 = "vector.outerproduct"(%112, %80, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %112 = "vector.extract"(%89) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %111 = "vector.outerproduct"(%110, %78, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %110 = "vector.extract"(%89) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %109 = "vector.outerproduct"(%108, %76, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %108 = "vector.extract"(%89) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %107 = "vector.outerproduct"(%106, %74, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %106 = "vector.extract"(%89) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %105 = "vector.outerproduct"(%104, %72, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %104 = "vector.extract"(%89) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %103 = "vector.outerproduct"(%102, %70, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %102 = "vector.extract"(%89) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %101 = "vector.outerproduct"(%100, %68, %99) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %100 = "vector.extract"(%89) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %99 = "vector.outerproduct"(%98, %66, %97) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %98 = "vector.extract"(%89) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %97 = "vector.outerproduct"(%96, %64, %95) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %96 = "vector.extract"(%89) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %95 = "vector.outerproduct"(%94, %62, %93) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %94 = "vector.extract"(%89) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %93 = "vector.outerproduct"(%92, %60, %91) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %92 = "vector.extract"(%89) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %91 = "vector.outerproduct"(%90, %58, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %90 = "vector.extract"(%89) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %89 = "vector.transpose"(%57) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %88 = "vector.load"(%17, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %86 = "vector.load"(%17, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %84 = "vector.load"(%17, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %82 = "vector.load"(%17, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %80 = "vector.load"(%17, %79, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %79 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %78 = "vector.load"(%17, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %76 = "vector.load"(%17, %75, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %75 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %74 = "vector.load"(%17, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %72 = "vector.load"(%17, %71, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %71 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %70 = "vector.load"(%17, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %68 = "vector.load"(%17, %67, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %67 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %66 = "vector.load"(%17, %65, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %65 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %64 = "vector.load"(%17, %63, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %63 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %62 = "vector.load"(%17, %61, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %61 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %60 = "vector.load"(%17, %59, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %59 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %58 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7bd0) {
  %57 = "vector.insert"(%56, %54) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %56 = "vector.load"(%15, %55, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %55 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7570) {
  %54 = "vector.insert"(%53, %51) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %53 = "vector.load"(%15, %52, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %52 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2989570) {
  %51 = "vector.insert"(%50, %48) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %50 = "vector.load"(%15, %49, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %49 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29892e0) {
  %48 = "vector.insert"(%47, %45) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %47 = "vector.load"(%15, %46, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %46 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29890b0) {
  %45 = "vector.insert"(%44, %42) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %44 = "vector.load"(%15, %43, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %43 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d7c0) {
  %42 = "vector.insert"(%41, %39) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %41 = "vector.load"(%15, %40, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %40 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d530) {
  %39 = "vector.insert"(%38, %36) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %38 = "vector.load"(%15, %37, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %37 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d2a0) {
  %36 = "vector.insert"(%35, %0) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %35 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978440) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyLowerVectorsPass (iree-linalg-strategy-lower-vectors-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
        %25 = vector.load %subview[%24, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %26 = vector.insert %25, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %27 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
        %28 = vector.load %subview[%27, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %26 [2] : vector<16xf32> into vector<8x16xf32>
        %30 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
        %31 = vector.load %subview[%30, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %32 = vector.insert %31, %29 [3] : vector<16xf32> into vector<8x16xf32>
        %33 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
        %34 = vector.load %subview[%33, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %32 [4] : vector<16xf32> into vector<8x16xf32>
        %36 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
        %37 = vector.load %subview[%36, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %35 [5] : vector<16xf32> into vector<8x16xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
        %40 = vector.load %subview[%39, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %41 = vector.insert %40, %38 [6] : vector<16xf32> into vector<8x16xf32>
        %42 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
        %43 = vector.load %subview[%42, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %41 [7] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %46 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %47 = vector.load %subview_2[%46, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %48 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %49 = vector.load %subview_2[%48, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %50 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %51 = vector.load %subview_2[%50, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %52 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %53 = vector.load %subview_2[%52, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %55 = vector.load %subview_2[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %57 = vector.load %subview_2[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %59 = vector.load %subview_2[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %61 = vector.load %subview_2[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %63 = vector.load %subview_2[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %65 = vector.load %subview_2[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %67 = vector.load %subview_2[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %69 = vector.load %subview_2[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %71 = vector.load %subview_2[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %73 = vector.load %subview_2[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %75 = vector.load %subview_2[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = vector.transpose %44, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %77 = vector.extract %76[0] : vector<16x8xf32>
        %78 = vector.outerproduct %77, %45, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %79 = vector.extract %76[1] : vector<16x8xf32>
        %80 = vector.outerproduct %79, %47, %78 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %81 = vector.extract %76[2] : vector<16x8xf32>
        %82 = vector.outerproduct %81, %49, %80 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %83 = vector.extract %76[3] : vector<16x8xf32>
        %84 = vector.outerproduct %83, %51, %82 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %85 = vector.extract %76[4] : vector<16x8xf32>
        %86 = vector.outerproduct %85, %53, %84 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.extract %76[5] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %55, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %76[6] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %57, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %76[7] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %59, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %76[8] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %61, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %76[9] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %63, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %76[10] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %65, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %76[11] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %67, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %76[12] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %69, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %76[13] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %71, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %76[14] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %73, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %76[15] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %75, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %108 : vector<8x32xf32>
      }
      %6 = math.cos %5 : vector<8x32xf32>
      %7 = vector.extract %6[0] : vector<8x32xf32>
      vector.store %7, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %8 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
      %9 = vector.extract %6[1] : vector<8x32xf32>
      vector.store %9, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %10 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
      %11 = vector.extract %6[2] : vector<8x32xf32>
      vector.store %11, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %12 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
      %13 = vector.extract %6[3] : vector<8x32xf32>
      vector.store %13, %subview_1[%12, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %14 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
      %15 = vector.extract %6[4] : vector<8x32xf32>
      vector.store %15, %subview_1[%14, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
      %17 = vector.extract %6[5] : vector<8x32xf32>
      vector.store %17, %subview_1[%16, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
      %19 = vector.extract %6[6] : vector<8x32xf32>
      vector.store %19, %subview_1[%18, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
      %21 = vector.extract %6[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%20, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%34, %16, %33, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %34 = "vector.extract"(%19) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2986420) {
  %33 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%32, %16, %31, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %32 = "vector.extract"(%19) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2980020) {
  %31 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%30, %16, %29, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %30 = "vector.extract"(%19) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297fe30) {
  %29 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%28, %16, %27, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %28 = "vector.extract"(%19) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297fbf0) {
  %27 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%26, %16, %25, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %26 = "vector.extract"(%19) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297a420) {
  %25 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%24, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %24 = "vector.extract"(%19) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29847e0) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%22, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %22 = "vector.extract"(%19) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2983ab0) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%20, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %20 = "vector.extract"(%19) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %19 = "math.cos"(%18) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%121) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %121 = "vector.outerproduct"(%120, %88, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %120 = "vector.extract"(%89) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %119 = "vector.outerproduct"(%118, %86, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %118 = "vector.extract"(%89) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %117 = "vector.outerproduct"(%116, %84, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %116 = "vector.extract"(%89) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %115 = "vector.outerproduct"(%114, %82, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %114 = "vector.extract"(%89) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %113 = "vector.outerproduct"(%112, %80, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %112 = "vector.extract"(%89) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %111 = "vector.outerproduct"(%110, %78, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %110 = "vector.extract"(%89) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %109 = "vector.outerproduct"(%108, %76, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %108 = "vector.extract"(%89) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %107 = "vector.outerproduct"(%106, %74, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %106 = "vector.extract"(%89) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %105 = "vector.outerproduct"(%104, %72, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %104 = "vector.extract"(%89) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %103 = "vector.outerproduct"(%102, %70, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %102 = "vector.extract"(%89) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %101 = "vector.outerproduct"(%100, %68, %99) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %100 = "vector.extract"(%89) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %99 = "vector.outerproduct"(%98, %66, %97) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %98 = "vector.extract"(%89) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %97 = "vector.outerproduct"(%96, %64, %95) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %96 = "vector.extract"(%89) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %95 = "vector.outerproduct"(%94, %62, %93) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %94 = "vector.extract"(%89) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %93 = "vector.outerproduct"(%92, %60, %91) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %92 = "vector.extract"(%89) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %91 = "vector.outerproduct"(%90, %58, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %90 = "vector.extract"(%89) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %89 = "vector.transpose"(%57) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %88 = "vector.load"(%17, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %86 = "vector.load"(%17, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %84 = "vector.load"(%17, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %82 = "vector.load"(%17, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %80 = "vector.load"(%17, %79, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %79 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %78 = "vector.load"(%17, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %76 = "vector.load"(%17, %75, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %75 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %74 = "vector.load"(%17, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %72 = "vector.load"(%17, %71, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %71 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %70 = "vector.load"(%17, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %68 = "vector.load"(%17, %67, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %67 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %66 = "vector.load"(%17, %65, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %65 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %64 = "vector.load"(%17, %63, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %63 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %62 = "vector.load"(%17, %61, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %61 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %60 = "vector.load"(%17, %59, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %59 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %58 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7bd0) {
  %57 = "vector.insert"(%56, %54) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %56 = "vector.load"(%15, %55, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %55 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7570) {
  %54 = "vector.insert"(%53, %51) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %53 = "vector.load"(%15, %52, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %52 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2989570) {
  %51 = "vector.insert"(%50, %48) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %50 = "vector.load"(%15, %49, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %49 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29892e0) {
  %48 = "vector.insert"(%47, %45) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %47 = "vector.load"(%15, %46, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %46 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29890b0) {
  %45 = "vector.insert"(%44, %42) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %44 = "vector.load"(%15, %43, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %43 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d7c0) {
  %42 = "vector.insert"(%41, %39) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %41 = "vector.load"(%15, %40, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %40 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d530) {
  %39 = "vector.insert"(%38, %36) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %38 = "vector.load"(%15, %37, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %37 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d2a0) {
  %36 = "vector.insert"(%35, %0) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %35 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978440) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.transpose %37, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %70 = vector.extract %69[0] : vector<16x8xf32>
        %71 = vector.outerproduct %70, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %72 = vector.extract %69[1] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %40, %71 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %69[2] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %42, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %69[3] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %44, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %69[4] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %46, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %69[5] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %48, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %69[6] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %50, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %69[7] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %52, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %69[8] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %54, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %69[9] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %56, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %69[10] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %58, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %69[11] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %60, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %69[12] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %62, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %69[13] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %64, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %69[14] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %66, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %69[15] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %68, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.transpose %37, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %70 = vector.extract %69[0] : vector<16x8xf32>
        %71 = vector.outerproduct %70, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %72 = vector.extract %69[1] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %40, %71 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %69[2] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %42, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %69[3] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %44, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %69[4] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %46, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %69[5] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %48, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %69[6] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %50, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %69[7] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %52, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %69[8] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %54, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %69[9] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %56, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %69[10] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %58, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %69[11] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %60, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %69[12] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %62, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %69[13] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %64, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %69[14] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %66, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %69[15] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %68, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.transpose %37, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %70 = vector.extract %69[0] : vector<16x8xf32>
        %71 = vector.outerproduct %70, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %72 = vector.extract %69[1] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %40, %71 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %69[2] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %42, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %69[3] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %44, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %69[4] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %46, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %69[5] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %48, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %69[6] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %50, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %69[7] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %52, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %69[8] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %54, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %69[9] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %56, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %69[10] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %58, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %69[11] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %60, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %69[12] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %62, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %69[13] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %64, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %69[14] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %66, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %69[15] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %68, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%34, %16, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %34 = "vector.extract"(%26) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%33, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %33 = "vector.extract"(%26) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%32, %16, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %32 = "vector.extract"(%26) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%31, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %31 = "vector.extract"(%26) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%30, %16, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %30 = "vector.extract"(%26) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%29, %16, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %29 = "vector.extract"(%26) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%28, %16, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %28 = "vector.extract"(%26) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%27, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %27 = "vector.extract"(%26) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %26 = "math.cos"(%25) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%114) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %114 = "vector.outerproduct"(%113, %81, %112) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %113 = "vector.extract"(%82) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %112 = "vector.outerproduct"(%111, %79, %110) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %111 = "vector.extract"(%82) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %110 = "vector.outerproduct"(%109, %77, %108) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %109 = "vector.extract"(%82) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %108 = "vector.outerproduct"(%107, %75, %106) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %107 = "vector.extract"(%82) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %106 = "vector.outerproduct"(%105, %73, %104) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %105 = "vector.extract"(%82) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %104 = "vector.outerproduct"(%103, %71, %102) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %103 = "vector.extract"(%82) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %102 = "vector.outerproduct"(%101, %69, %100) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %101 = "vector.extract"(%82) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %100 = "vector.outerproduct"(%99, %67, %98) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %99 = "vector.extract"(%82) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %98 = "vector.outerproduct"(%97, %65, %96) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %97 = "vector.extract"(%82) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %96 = "vector.outerproduct"(%95, %63, %94) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %95 = "vector.extract"(%82) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %94 = "vector.outerproduct"(%93, %61, %92) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %93 = "vector.extract"(%82) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %92 = "vector.outerproduct"(%91, %59, %90) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %91 = "vector.extract"(%82) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %90 = "vector.outerproduct"(%89, %57, %88) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %89 = "vector.extract"(%82) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %88 = "vector.outerproduct"(%87, %55, %86) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %87 = "vector.extract"(%82) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %86 = "vector.outerproduct"(%85, %53, %84) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %85 = "vector.extract"(%82) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %84 = "vector.outerproduct"(%83, %51, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %83 = "vector.extract"(%82) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %82 = "vector.transpose"(%50) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %81 = "vector.load"(%17, %80, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %80 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %79 = "vector.load"(%17, %78, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %78 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %77 = "vector.load"(%17, %76, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %76 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %75 = "vector.load"(%17, %74, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %74 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %73 = "vector.load"(%17, %72, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %72 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %71 = "vector.load"(%17, %70, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %70 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %69 = "vector.load"(%17, %68, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %68 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %67 = "vector.load"(%17, %66, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %66 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %65 = "vector.load"(%17, %64, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %64 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %63 = "vector.load"(%17, %62, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %62 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %61 = "vector.load"(%17, %60, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %60 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %59 = "vector.load"(%17, %58, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %58 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %57 = "vector.load"(%17, %56, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %56 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %55 = "vector.load"(%17, %54, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %54 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %53 = "vector.load"(%17, %52, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %52 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %51 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7bd0) {
  %50 = "vector.insert"(%49, %48) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %49 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7570) {
  %48 = "vector.insert"(%47, %46) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %47 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2989570) {
  %46 = "vector.insert"(%45, %44) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %45 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29892e0) {
  %44 = "vector.insert"(%43, %42) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %43 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29890b0) {
  %42 = "vector.insert"(%41, %40) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %41 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d7c0) {
  %40 = "vector.insert"(%39, %38) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %39 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d530) {
  %38 = "vector.insert"(%37, %36) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %37 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d2a0) {
  %36 = "vector.insert"(%35, %0) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %35 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978440) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.transpose %37, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %70 = vector.extract %69[0] : vector<16x8xf32>
        %71 = vector.outerproduct %70, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %72 = vector.extract %69[1] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %40, %71 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %69[2] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %42, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %69[3] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %44, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %69[4] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %46, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %69[5] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %48, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %69[6] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %50, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %69[7] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %52, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %69[8] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %54, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %69[9] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %56, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %69[10] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %58, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %69[11] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %60, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %69[12] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %62, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %69[13] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %64, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %69[14] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %66, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %69[15] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %68, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.transpose %37, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %70 = vector.extract %69[0] : vector<16x8xf32>
        %71 = vector.outerproduct %70, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %72 = vector.extract %69[1] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %40, %71 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %69[2] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %42, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %69[3] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %44, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %69[4] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %46, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %69[5] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %48, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %69[6] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %50, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %69[7] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %52, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %69[8] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %54, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %69[9] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %56, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %69[10] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %58, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %69[11] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %60, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %69[12] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %62, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %69[13] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %64, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %69[14] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %66, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %69[15] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %68, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgVectorLowering (linalg-vector-lowering) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.transpose %37, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %70 = vector.extract %69[0] : vector<16x8xf32>
        %71 = vector.outerproduct %70, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %72 = vector.extract %69[1] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %40, %71 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %69[2] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %42, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %69[3] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %44, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %69[4] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %46, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %69[5] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %48, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %69[6] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %50, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %69[7] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %52, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %69[8] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %54, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %69[9] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %56, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %69[10] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %58, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %69[11] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %60, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %69[12] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %62, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %69[13] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %64, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %69[14] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %66, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %69[15] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %68, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978440) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %35 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d2a0) {
  %36 = "vector.insert"(%35, %0) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %37 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d530) {
  %38 = "vector.insert"(%37, %36) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %39 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d7c0) {
  %40 = "vector.insert"(%39, %38) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %41 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29890b0) {
  %42 = "vector.insert"(%41, %40) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %43 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29892e0) {
  %44 = "vector.insert"(%43, %42) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %45 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2989570) {
  %46 = "vector.insert"(%45, %44) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %47 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7570) {
  %48 = "vector.insert"(%47, %46) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %49 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7bd0) {
  %50 = "vector.insert"(%49, %48) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %51 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %52 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %53 = "vector.load"(%17, %52, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %54 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %55 = "vector.load"(%17, %54, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %56 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %57 = "vector.load"(%17, %56, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %58 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %59 = "vector.load"(%17, %58, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %60 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %61 = "vector.load"(%17, %60, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %62 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %63 = "vector.load"(%17, %62, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %64 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %65 = "vector.load"(%17, %64, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %66 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %67 = "vector.load"(%17, %66, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %68 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %69 = "vector.load"(%17, %68, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %70 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %71 = "vector.load"(%17, %70, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %72 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %73 = "vector.load"(%17, %72, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %74 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %75 = "vector.load"(%17, %74, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %76 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %77 = "vector.load"(%17, %76, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %78 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %79 = "vector.load"(%17, %78, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %80 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %81 = "vector.load"(%17, %80, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %82 = "vector.transpose"(%50) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::FoldTransposedScalarBroadcast : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTransposeSplat : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %83 = "vector.extract"(%82) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %84 = "vector.outerproduct"(%83, %51, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %85 = "vector.extract"(%82) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %86 = "vector.outerproduct"(%85, %53, %84) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %87 = "vector.extract"(%82) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %88 = "vector.outerproduct"(%87, %55, %86) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %89 = "vector.extract"(%82) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %90 = "vector.outerproduct"(%89, %57, %88) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %91 = "vector.extract"(%82) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %92 = "vector.outerproduct"(%91, %59, %90) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %93 = "vector.extract"(%82) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %94 = "vector.outerproduct"(%93, %61, %92) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %95 = "vector.extract"(%82) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %96 = "vector.outerproduct"(%95, %63, %94) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %97 = "vector.extract"(%82) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %98 = "vector.outerproduct"(%97, %65, %96) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %99 = "vector.extract"(%82) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %100 = "vector.outerproduct"(%99, %67, %98) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %101 = "vector.extract"(%82) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %102 = "vector.outerproduct"(%101, %69, %100) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %103 = "vector.extract"(%82) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %104 = "vector.outerproduct"(%103, %71, %102) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %105 = "vector.extract"(%82) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %106 = "vector.outerproduct"(%105, %73, %104) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %107 = "vector.extract"(%82) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %108 = "vector.outerproduct"(%107, %75, %106) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %109 = "vector.extract"(%82) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %110 = "vector.outerproduct"(%109, %77, %108) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %111 = "vector.extract"(%82) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %112 = "vector.outerproduct"(%111, %79, %110) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %113 = "vector.extract"(%82) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %114 = "vector.outerproduct"(%113, %81, %112) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%114) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %26 = "math.cos"(%25) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %27 = "vector.extract"(%26) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%27, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %28 = "vector.extract"(%26) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%28, %16, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %29 = "vector.extract"(%26) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%29, %16, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %30 = "vector.extract"(%26) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%30, %16, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %31 = "vector.extract"(%26) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%31, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %32 = "vector.extract"(%26) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%32, %16, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %33 = "vector.extract"(%26) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%33, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %34 = "vector.extract"(%26) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%34, %16, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.transpose %37, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %70 = vector.extract %69[0] : vector<16x8xf32>
        %71 = vector.outerproduct %70, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %72 = vector.extract %69[1] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %40, %71 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %69[2] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %42, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %69[3] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %44, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %69[4] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %46, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %69[5] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %48, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %69[6] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %50, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %69[7] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %52, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %69[8] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %54, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %69[9] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %56, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %69[10] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %58, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %69[11] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %60, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %69[12] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %62, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %69[13] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %64, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %69[14] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %66, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %69[15] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %68, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.transpose %37, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %70 = vector.extract %69[0] : vector<16x8xf32>
        %71 = vector.outerproduct %70, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %72 = vector.extract %69[1] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %40, %71 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %69[2] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %42, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %69[3] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %44, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %69[4] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %46, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %69[5] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %48, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %69[6] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %50, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %69[7] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %52, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %69[8] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %54, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %69[9] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %56, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %69[10] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %58, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %69[11] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %60, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %69[12] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %62, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %69[13] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %64, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %69[14] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %66, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %69[15] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %68, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%34, %16, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %34 = "vector.extract"(%26) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%33, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %33 = "vector.extract"(%26) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%32, %16, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %32 = "vector.extract"(%26) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%31, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %31 = "vector.extract"(%26) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%30, %16, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %30 = "vector.extract"(%26) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%29, %16, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %29 = "vector.extract"(%26) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%28, %16, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %28 = "vector.extract"(%26) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%27, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %27 = "vector.extract"(%26) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %26 = "math.cos"(%25) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'math.cos -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%114) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %114 = "vector.outerproduct"(%113, %81, %112) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %113 = "vector.extract"(%82) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %112 = "vector.outerproduct"(%111, %79, %110) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %111 = "vector.extract"(%82) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %110 = "vector.outerproduct"(%109, %77, %108) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %109 = "vector.extract"(%82) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %108 = "vector.outerproduct"(%107, %75, %106) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %107 = "vector.extract"(%82) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %106 = "vector.outerproduct"(%105, %73, %104) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %105 = "vector.extract"(%82) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %104 = "vector.outerproduct"(%103, %71, %102) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %103 = "vector.extract"(%82) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %102 = "vector.outerproduct"(%101, %69, %100) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %101 = "vector.extract"(%82) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %100 = "vector.outerproduct"(%99, %67, %98) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %99 = "vector.extract"(%82) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %98 = "vector.outerproduct"(%97, %65, %96) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %97 = "vector.extract"(%82) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %96 = "vector.outerproduct"(%95, %63, %94) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %95 = "vector.extract"(%82) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %94 = "vector.outerproduct"(%93, %61, %92) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %93 = "vector.extract"(%82) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %92 = "vector.outerproduct"(%91, %59, %90) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %91 = "vector.extract"(%82) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %90 = "vector.outerproduct"(%89, %57, %88) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %89 = "vector.extract"(%82) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %88 = "vector.outerproduct"(%87, %55, %86) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %87 = "vector.extract"(%82) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %86 = "vector.outerproduct"(%85, %53, %84) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %85 = "vector.extract"(%82) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %84 = "vector.outerproduct"(%83, %51, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %83 = "vector.extract"(%82) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2200d40) {
  %82 = "vector.transpose"(%50) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransposeOpLowering : 'vector.transpose -> ()' {
    ** Failure : Options specifies lowering to shuffle
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransposeOp2DToShuffleLowering : 'vector.transpose -> ()' {
    ** Insert  : 'vector.shape_cast'(0xbccf90)
    ** Insert  : 'vector.shuffle'(0x21fd6a0)
    ** Insert  : 'vector.shape_cast'(0x2980f10)
    ** Replace : 'vector.transpose'(0x2200d40)
    ** Erase   : 'vector.transpose'(0x2200d40)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %85 = "vector.extract"(%84) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %87 = "vector.extract"(%84) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %89 = "vector.extract"(%84) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %91 = "vector.extract"(%84) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %93 = "vector.extract"(%84) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %95 = "vector.extract"(%84) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %97 = "vector.extract"(%84) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %99 = "vector.extract"(%84) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %101 = "vector.extract"(%84) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %103 = "vector.extract"(%84) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %105 = "vector.extract"(%84) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %107 = "vector.extract"(%84) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %109 = "vector.extract"(%84) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %111 = "vector.extract"(%84) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %113 = "vector.extract"(%84) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %115 = "vector.extract"(%84) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x2980f10) {
  %84 = "vector.shape_cast"(%83) : (vector<128xf32>) -> vector<16x8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x21fd6a0) {
  %83 = "vector.shuffle"(%82, %82) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0xbccf90) {
  %82 = "vector.shape_cast"(%50) : (vector<8x16xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %81 = "vector.load"(%17, %80, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %80 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %79 = "vector.load"(%17, %78, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %78 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %77 = "vector.load"(%17, %76, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %76 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %75 = "vector.load"(%17, %74, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %74 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %73 = "vector.load"(%17, %72, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %72 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %71 = "vector.load"(%17, %70, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %70 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %69 = "vector.load"(%17, %68, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %68 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %67 = "vector.load"(%17, %66, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %66 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %65 = "vector.load"(%17, %64, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %64 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %63 = "vector.load"(%17, %62, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %62 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %61 = "vector.load"(%17, %60, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %60 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %59 = "vector.load"(%17, %58, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %58 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %57 = "vector.load"(%17, %56, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %56 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %55 = "vector.load"(%17, %54, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %54 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %53 = "vector.load"(%17, %52, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %52 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %51 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7bd0) {
  %50 = "vector.insert"(%49, %48) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %49 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7570) {
  %48 = "vector.insert"(%47, %46) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %47 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2989570) {
  %46 = "vector.insert"(%45, %44) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %45 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29892e0) {
  %44 = "vector.insert"(%43, %42) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %43 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29890b0) {
  %42 = "vector.insert"(%41, %40) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %41 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d7c0) {
  %40 = "vector.insert"(%39, %38) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %39 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d530) {
  %38 = "vector.insert"(%37, %36) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %37 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d2a0) {
  %36 = "vector.insert"(%35, %0) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %35 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978440) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%34, %16, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %34 = "vector.extract"(%26) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%33, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %33 = "vector.extract"(%26) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%32, %16, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %32 = "vector.extract"(%26) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%31, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %31 = "vector.extract"(%26) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%30, %16, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %30 = "vector.extract"(%26) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%29, %16, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %29 = "vector.extract"(%26) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%28, %16, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %28 = "vector.extract"(%26) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%27, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %27 = "vector.extract"(%26) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %26 = "math.cos"(%25) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'math.cos -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%116) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %116 = "vector.outerproduct"(%115, %81, %114) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %115 = "vector.extract"(%84) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %114 = "vector.outerproduct"(%113, %79, %112) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %113 = "vector.extract"(%84) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %112 = "vector.outerproduct"(%111, %77, %110) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %111 = "vector.extract"(%84) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %110 = "vector.outerproduct"(%109, %75, %108) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %109 = "vector.extract"(%84) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %108 = "vector.outerproduct"(%107, %73, %106) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %107 = "vector.extract"(%84) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %106 = "vector.outerproduct"(%105, %71, %104) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %105 = "vector.extract"(%84) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %104 = "vector.outerproduct"(%103, %69, %102) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %103 = "vector.extract"(%84) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %102 = "vector.outerproduct"(%101, %67, %100) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %101 = "vector.extract"(%84) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %100 = "vector.outerproduct"(%99, %65, %98) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %99 = "vector.extract"(%84) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %98 = "vector.outerproduct"(%97, %63, %96) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %97 = "vector.extract"(%84) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %96 = "vector.outerproduct"(%95, %61, %94) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %95 = "vector.extract"(%84) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %94 = "vector.outerproduct"(%93, %59, %92) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %93 = "vector.extract"(%84) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %92 = "vector.outerproduct"(%91, %57, %90) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %91 = "vector.extract"(%84) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %90 = "vector.outerproduct"(%89, %55, %88) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %89 = "vector.extract"(%84) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %88 = "vector.outerproduct"(%87, %53, %86) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %87 = "vector.extract"(%84) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %86 = "vector.outerproduct"(%85, %51, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %85 = "vector.extract"(%84) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x2980f10) {
  %84 = "vector.shape_cast"(%83) : (vector<128xf32>) -> vector<16x8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x21fd6a0) {
  %83 = "vector.shuffle"(%82, %82) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0xbccf90) {
  %82 = "vector.shape_cast"(%50) : (vector<8x16xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %81 = "vector.load"(%17, %80, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %80 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %79 = "vector.load"(%17, %78, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %78 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %77 = "vector.load"(%17, %76, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %76 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %75 = "vector.load"(%17, %74, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %74 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %73 = "vector.load"(%17, %72, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %72 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %71 = "vector.load"(%17, %70, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %70 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %69 = "vector.load"(%17, %68, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %68 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %67 = "vector.load"(%17, %66, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %66 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %65 = "vector.load"(%17, %64, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %64 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %63 = "vector.load"(%17, %62, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %62 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %61 = "vector.load"(%17, %60, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %60 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %59 = "vector.load"(%17, %58, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %58 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %57 = "vector.load"(%17, %56, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %56 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %55 = "vector.load"(%17, %54, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %54 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %53 = "vector.load"(%17, %52, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %52 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %51 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7bd0) {
  %50 = "vector.insert"(%49, %48) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %49 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7570) {
  %48 = "vector.insert"(%47, %46) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %47 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2989570) {
  %46 = "vector.insert"(%45, %44) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %45 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29892e0) {
  %44 = "vector.insert"(%43, %42) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %43 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29890b0) {
  %42 = "vector.insert"(%41, %40) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %41 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d7c0) {
  %40 = "vector.insert"(%39, %38) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %39 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d530) {
  %38 = "vector.insert"(%37, %36) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %37 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d2a0) {
  %36 = "vector.insert"(%35, %0) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %35 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978440) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyLowerVectorsPass (iree-linalg-strategy-lower-vectors-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.shape_cast %37 : vector<8x16xf32> to vector<128xf32>
        %70 = vector.shuffle %69, %69 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %71 = vector.shape_cast %70 : vector<128xf32> to vector<16x8xf32>
        %72 = vector.extract %71[0] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %71[1] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %40, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %71[2] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %42, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %71[3] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %44, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %71[4] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %46, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %71[5] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %48, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %71[6] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %50, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %71[7] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %52, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %71[8] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %54, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %71[9] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %56, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %71[10] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %58, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %71[11] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %60, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %71[12] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %62, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %71[13] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %64, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %71[14] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %66, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.extract %71[15] : vector<16x8xf32>
        %103 = vector.outerproduct %102, %68, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %103 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%34, %16, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %34 = "vector.extract"(%26) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%33, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %33 = "vector.extract"(%26) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%32, %16, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %32 = "vector.extract"(%26) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%31, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %31 = "vector.extract"(%26) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%30, %16, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %30 = "vector.extract"(%26) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%29, %16, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %29 = "vector.extract"(%26) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%28, %16, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %28 = "vector.extract"(%26) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%27, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %27 = "vector.extract"(%26) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %26 = "math.cos"(%25) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%116) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %116 = "vector.outerproduct"(%115, %81, %114) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %115 = "vector.extract"(%84) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %114 = "vector.outerproduct"(%113, %79, %112) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %113 = "vector.extract"(%84) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %112 = "vector.outerproduct"(%111, %77, %110) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %111 = "vector.extract"(%84) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %110 = "vector.outerproduct"(%109, %75, %108) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %109 = "vector.extract"(%84) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %108 = "vector.outerproduct"(%107, %73, %106) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %107 = "vector.extract"(%84) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %106 = "vector.outerproduct"(%105, %71, %104) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %105 = "vector.extract"(%84) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %104 = "vector.outerproduct"(%103, %69, %102) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %103 = "vector.extract"(%84) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %102 = "vector.outerproduct"(%101, %67, %100) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %101 = "vector.extract"(%84) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %100 = "vector.outerproduct"(%99, %65, %98) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %99 = "vector.extract"(%84) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %98 = "vector.outerproduct"(%97, %63, %96) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %97 = "vector.extract"(%84) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %96 = "vector.outerproduct"(%95, %61, %94) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %95 = "vector.extract"(%84) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %94 = "vector.outerproduct"(%93, %59, %92) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %93 = "vector.extract"(%84) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %92 = "vector.outerproduct"(%91, %57, %90) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %91 = "vector.extract"(%84) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %90 = "vector.outerproduct"(%89, %55, %88) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %89 = "vector.extract"(%84) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %88 = "vector.outerproduct"(%87, %53, %86) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %87 = "vector.extract"(%84) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %86 = "vector.outerproduct"(%85, %51, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %85 = "vector.extract"(%84) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x2980f10) {
  %84 = "vector.shape_cast"(%83) : (vector<128xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x21fd6a0) {
  %83 = "vector.shuffle"(%82, %82) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0xbccf90) {
  %82 = "vector.shape_cast"(%50) : (vector<8x16xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %81 = "vector.load"(%17, %80, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %80 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %79 = "vector.load"(%17, %78, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %78 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %77 = "vector.load"(%17, %76, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %76 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %75 = "vector.load"(%17, %74, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %74 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %73 = "vector.load"(%17, %72, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %72 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %71 = "vector.load"(%17, %70, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %70 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %69 = "vector.load"(%17, %68, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %68 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %67 = "vector.load"(%17, %66, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %66 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %65 = "vector.load"(%17, %64, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %64 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %63 = "vector.load"(%17, %62, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %62 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %61 = "vector.load"(%17, %60, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %60 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %59 = "vector.load"(%17, %58, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %58 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %57 = "vector.load"(%17, %56, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %56 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %55 = "vector.load"(%17, %54, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %54 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %53 = "vector.load"(%17, %52, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %52 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %51 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7bd0) {
  %50 = "vector.insert"(%49, %48) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %49 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7570) {
  %48 = "vector.insert"(%47, %46) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %47 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2989570) {
  %46 = "vector.insert"(%45, %44) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %45 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29892e0) {
  %44 = "vector.insert"(%43, %42) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %43 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29890b0) {
  %42 = "vector.insert"(%41, %40) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %41 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d7c0) {
  %40 = "vector.insert"(%39, %38) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %39 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d530) {
  %38 = "vector.insert"(%37, %36) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %37 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d2a0) {
  %36 = "vector.insert"(%35, %0) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %35 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978440) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.shape_cast %37 : vector<8x16xf32> to vector<128xf32>
        %70 = vector.shuffle %69, %69 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %71 = vector.shape_cast %70 : vector<128xf32> to vector<16x8xf32>
        %72 = vector.extract %71[0] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %71[1] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %40, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %71[2] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %42, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %71[3] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %44, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %71[4] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %46, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %71[5] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %48, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %71[6] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %50, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %71[7] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %52, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %71[8] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %54, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %71[9] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %56, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %71[10] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %58, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %71[11] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %60, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %71[12] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %62, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %71[13] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %64, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %71[14] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %66, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.extract %71[15] : vector<16x8xf32>
        %103 = vector.outerproduct %102, %68, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %103 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.shape_cast %37 : vector<8x16xf32> to vector<128xf32>
        %70 = vector.shuffle %69, %69 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %71 = vector.shape_cast %70 : vector<128xf32> to vector<16x8xf32>
        %72 = vector.extract %71[0] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %71[1] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %40, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %71[2] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %42, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %71[3] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %44, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %71[4] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %46, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %71[5] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %48, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %71[6] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %50, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %71[7] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %52, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %71[8] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %54, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %71[9] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %56, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %71[10] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %58, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %71[11] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %60, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %71[12] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %62, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %71[13] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %64, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %71[14] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %66, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.extract %71[15] : vector<16x8xf32>
        %103 = vector.outerproduct %102, %68, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %103 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.shape_cast %37 : vector<8x16xf32> to vector<128xf32>
        %70 = vector.shuffle %69, %69 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %71 = vector.shape_cast %70 : vector<128xf32> to vector<16x8xf32>
        %72 = vector.extract %71[0] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %71[1] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %40, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %71[2] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %42, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %71[3] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %44, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %71[4] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %46, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %71[5] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %48, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %71[6] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %50, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %71[7] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %52, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %71[8] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %54, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %71[9] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %56, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %71[10] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %58, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %71[11] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %60, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %71[12] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %62, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %71[13] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %64, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %71[14] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %66, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.extract %71[15] : vector<16x8xf32>
        %103 = vector.outerproduct %102, %68, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %103 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%34, %16, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %34 = "vector.extract"(%26) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%33, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %33 = "vector.extract"(%26) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%32, %16, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %32 = "vector.extract"(%26) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%31, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %31 = "vector.extract"(%26) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%30, %16, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %30 = "vector.extract"(%26) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%29, %16, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %29 = "vector.extract"(%26) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%28, %16, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %28 = "vector.extract"(%26) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%27, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %27 = "vector.extract"(%26) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %26 = "math.cos"(%25) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%116) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %116 = "vector.outerproduct"(%115, %81, %114) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %115 = "vector.extract"(%84) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %114 = "vector.outerproduct"(%113, %79, %112) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %113 = "vector.extract"(%84) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %112 = "vector.outerproduct"(%111, %77, %110) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %111 = "vector.extract"(%84) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %110 = "vector.outerproduct"(%109, %75, %108) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %109 = "vector.extract"(%84) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %108 = "vector.outerproduct"(%107, %73, %106) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %107 = "vector.extract"(%84) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %106 = "vector.outerproduct"(%105, %71, %104) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %105 = "vector.extract"(%84) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %104 = "vector.outerproduct"(%103, %69, %102) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %103 = "vector.extract"(%84) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %102 = "vector.outerproduct"(%101, %67, %100) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %101 = "vector.extract"(%84) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %100 = "vector.outerproduct"(%99, %65, %98) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %99 = "vector.extract"(%84) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %98 = "vector.outerproduct"(%97, %63, %96) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %97 = "vector.extract"(%84) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %96 = "vector.outerproduct"(%95, %61, %94) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %95 = "vector.extract"(%84) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %94 = "vector.outerproduct"(%93, %59, %92) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %93 = "vector.extract"(%84) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %92 = "vector.outerproduct"(%91, %57, %90) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %91 = "vector.extract"(%84) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %90 = "vector.outerproduct"(%89, %55, %88) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %89 = "vector.extract"(%84) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %88 = "vector.outerproduct"(%87, %53, %86) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %87 = "vector.extract"(%84) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %86 = "vector.outerproduct"(%85, %51, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %85 = "vector.extract"(%84) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x2980f10) {
  %84 = "vector.shape_cast"(%83) : (vector<128xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x21fd6a0) {
  %83 = "vector.shuffle"(%82, %82) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0xbccf90) {
  %82 = "vector.shape_cast"(%50) : (vector<8x16xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %81 = "vector.load"(%17, %80, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %80 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %79 = "vector.load"(%17, %78, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %78 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %77 = "vector.load"(%17, %76, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %76 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %75 = "vector.load"(%17, %74, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %74 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %73 = "vector.load"(%17, %72, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %72 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %71 = "vector.load"(%17, %70, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %70 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %69 = "vector.load"(%17, %68, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %68 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %67 = "vector.load"(%17, %66, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %66 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %65 = "vector.load"(%17, %64, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %64 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %63 = "vector.load"(%17, %62, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %62 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %61 = "vector.load"(%17, %60, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %60 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %59 = "vector.load"(%17, %58, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %58 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %57 = "vector.load"(%17, %56, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %56 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %55 = "vector.load"(%17, %54, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %54 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %53 = "vector.load"(%17, %52, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %52 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %51 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7bd0) {
  %50 = "vector.insert"(%49, %48) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %49 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7570) {
  %48 = "vector.insert"(%47, %46) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %47 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2989570) {
  %46 = "vector.insert"(%45, %44) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %45 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29892e0) {
  %44 = "vector.insert"(%43, %42) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %43 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29890b0) {
  %42 = "vector.insert"(%41, %40) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %41 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d7c0) {
  %40 = "vector.insert"(%39, %38) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %39 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d530) {
  %38 = "vector.insert"(%37, %36) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %37 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d2a0) {
  %36 = "vector.insert"(%35, %0) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %35 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978440) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.shape_cast %37 : vector<8x16xf32> to vector<128xf32>
        %70 = vector.shuffle %69, %69 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %71 = vector.shape_cast %70 : vector<128xf32> to vector<16x8xf32>
        %72 = vector.extract %71[0] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %71[1] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %40, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %71[2] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %42, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %71[3] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %44, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %71[4] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %46, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %71[5] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %48, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %71[6] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %50, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %71[7] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %52, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %71[8] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %54, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %71[9] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %56, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %71[10] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %58, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %71[11] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %60, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %71[12] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %62, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %71[13] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %64, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %71[14] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %66, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.extract %71[15] : vector<16x8xf32>
        %103 = vector.outerproduct %102, %68, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %103 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.shape_cast %37 : vector<8x16xf32> to vector<128xf32>
        %70 = vector.shuffle %69, %69 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %71 = vector.shape_cast %70 : vector<128xf32> to vector<16x8xf32>
        %72 = vector.extract %71[0] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %71[1] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %40, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %71[2] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %42, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %71[3] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %44, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %71[4] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %46, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %71[5] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %48, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %71[6] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %50, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %71[7] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %52, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %71[8] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %54, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %71[9] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %56, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %71[10] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %58, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %71[11] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %60, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %71[12] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %62, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %71[13] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %64, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %71[14] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %66, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.extract %71[15] : vector<16x8xf32>
        %103 = vector.outerproduct %102, %68, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %103 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgVectorLowering (linalg-vector-lowering) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.shape_cast %37 : vector<8x16xf32> to vector<128xf32>
        %70 = vector.shuffle %69, %69 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %71 = vector.shape_cast %70 : vector<128xf32> to vector<16x8xf32>
        %72 = vector.extract %71[0] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %71[1] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %40, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %71[2] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %42, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %71[3] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %44, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %71[4] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %46, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %71[5] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %48, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %71[6] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %50, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %71[7] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %52, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %71[8] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %54, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %71[9] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %56, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %71[10] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %58, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %71[11] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %60, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %71[12] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %62, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %71[13] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %64, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %71[14] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %66, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.extract %71[15] : vector<16x8xf32>
        %103 = vector.outerproduct %102, %68, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %103 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978440) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %35 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d2a0) {
  %36 = "vector.insert"(%35, %0) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %37 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d530) {
  %38 = "vector.insert"(%37, %36) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %39 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d7c0) {
  %40 = "vector.insert"(%39, %38) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %41 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29890b0) {
  %42 = "vector.insert"(%41, %40) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %43 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29892e0) {
  %44 = "vector.insert"(%43, %42) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %45 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2989570) {
  %46 = "vector.insert"(%45, %44) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %47 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7570) {
  %48 = "vector.insert"(%47, %46) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %49 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7bd0) {
  %50 = "vector.insert"(%49, %48) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %51 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %52 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %53 = "vector.load"(%17, %52, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %54 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %55 = "vector.load"(%17, %54, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %56 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %57 = "vector.load"(%17, %56, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %58 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %59 = "vector.load"(%17, %58, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %60 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %61 = "vector.load"(%17, %60, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %62 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %63 = "vector.load"(%17, %62, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %64 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %65 = "vector.load"(%17, %64, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %66 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %67 = "vector.load"(%17, %66, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %68 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %69 = "vector.load"(%17, %68, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %70 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %71 = "vector.load"(%17, %70, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %72 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %73 = "vector.load"(%17, %72, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %74 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %75 = "vector.load"(%17, %74, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %76 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %77 = "vector.load"(%17, %76, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %78 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %79 = "vector.load"(%17, %78, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %80 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %81 = "vector.load"(%17, %80, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0xbccf90) {
  %82 = "vector.shape_cast"(%50) : (vector<8x16xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::ShapeCastConstantFolder : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ShapeCastBroadcastFolder : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x21fd6a0) {
  %83 = "vector.shuffle"(%82, %82) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::ShuffleSplat : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::Canonicalize0DShuffleOp : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x2980f10) {
  %84 = "vector.shape_cast"(%83) : (vector<128xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::ShapeCastConstantFolder : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ShapeCastBroadcastFolder : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %85 = "vector.extract"(%84) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %86 = "vector.outerproduct"(%85, %51, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %87 = "vector.extract"(%84) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %88 = "vector.outerproduct"(%87, %53, %86) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %89 = "vector.extract"(%84) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %90 = "vector.outerproduct"(%89, %55, %88) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %91 = "vector.extract"(%84) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %92 = "vector.outerproduct"(%91, %57, %90) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %93 = "vector.extract"(%84) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %94 = "vector.outerproduct"(%93, %59, %92) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %95 = "vector.extract"(%84) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %96 = "vector.outerproduct"(%95, %61, %94) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %97 = "vector.extract"(%84) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %98 = "vector.outerproduct"(%97, %63, %96) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %99 = "vector.extract"(%84) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %100 = "vector.outerproduct"(%99, %65, %98) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %101 = "vector.extract"(%84) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %102 = "vector.outerproduct"(%101, %67, %100) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %103 = "vector.extract"(%84) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %104 = "vector.outerproduct"(%103, %69, %102) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %105 = "vector.extract"(%84) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %106 = "vector.outerproduct"(%105, %71, %104) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %107 = "vector.extract"(%84) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %108 = "vector.outerproduct"(%107, %73, %106) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %109 = "vector.extract"(%84) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %110 = "vector.outerproduct"(%109, %75, %108) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %111 = "vector.extract"(%84) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %112 = "vector.outerproduct"(%111, %77, %110) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %113 = "vector.extract"(%84) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %114 = "vector.outerproduct"(%113, %79, %112) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %115 = "vector.extract"(%84) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %116 = "vector.outerproduct"(%115, %81, %114) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%116) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %26 = "math.cos"(%25) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %27 = "vector.extract"(%26) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%27, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %28 = "vector.extract"(%26) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%28, %16, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %29 = "vector.extract"(%26) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%29, %16, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %30 = "vector.extract"(%26) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%30, %16, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %31 = "vector.extract"(%26) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%31, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %32 = "vector.extract"(%26) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%32, %16, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %33 = "vector.extract"(%26) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%33, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %34 = "vector.extract"(%26) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%34, %16, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.shape_cast %37 : vector<8x16xf32> to vector<128xf32>
        %70 = vector.shuffle %69, %69 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %71 = vector.shape_cast %70 : vector<128xf32> to vector<16x8xf32>
        %72 = vector.extract %71[0] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %71[1] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %40, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %71[2] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %42, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %71[3] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %44, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %71[4] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %46, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %71[5] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %48, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %71[6] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %50, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %71[7] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %52, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %71[8] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %54, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %71[9] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %56, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %71[10] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %58, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %71[11] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %60, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %71[12] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %62, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %71[13] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %64, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %71[14] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %66, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.extract %71[15] : vector<16x8xf32>
        %103 = vector.outerproduct %102, %68, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %103 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.insert %22, %cst [0] : vector<16xf32> into vector<8x16xf32>
        %24 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.insert %24, %23 [1] : vector<16xf32> into vector<8x16xf32>
        %26 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.insert %26, %25 [2] : vector<16xf32> into vector<8x16xf32>
        %28 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.insert %28, %27 [3] : vector<16xf32> into vector<8x16xf32>
        %30 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %31 = vector.insert %30, %29 [4] : vector<16xf32> into vector<8x16xf32>
        %32 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %33 = vector.insert %32, %31 [5] : vector<16xf32> into vector<8x16xf32>
        %34 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %35 = vector.insert %34, %33 [6] : vector<16xf32> into vector<8x16xf32>
        %36 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %37 = vector.insert %36, %35 [7] : vector<16xf32> into vector<8x16xf32>
        %38 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %62 = vector.load %subview_2[%61, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %63 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %64 = vector.load %subview_2[%63, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %65 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %66 = vector.load %subview_2[%65, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %67 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %68 = vector.load %subview_2[%67, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %69 = vector.shape_cast %37 : vector<8x16xf32> to vector<128xf32>
        %70 = vector.shuffle %69, %69 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %71 = vector.shape_cast %70 : vector<128xf32> to vector<16x8xf32>
        %72 = vector.extract %71[0] : vector<16x8xf32>
        %73 = vector.outerproduct %72, %38, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %74 = vector.extract %71[1] : vector<16x8xf32>
        %75 = vector.outerproduct %74, %40, %73 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %76 = vector.extract %71[2] : vector<16x8xf32>
        %77 = vector.outerproduct %76, %42, %75 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %78 = vector.extract %71[3] : vector<16x8xf32>
        %79 = vector.outerproduct %78, %44, %77 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %80 = vector.extract %71[4] : vector<16x8xf32>
        %81 = vector.outerproduct %80, %46, %79 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %82 = vector.extract %71[5] : vector<16x8xf32>
        %83 = vector.outerproduct %82, %48, %81 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %84 = vector.extract %71[6] : vector<16x8xf32>
        %85 = vector.outerproduct %84, %50, %83 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %86 = vector.extract %71[7] : vector<16x8xf32>
        %87 = vector.outerproduct %86, %52, %85 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.extract %71[8] : vector<16x8xf32>
        %89 = vector.outerproduct %88, %54, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.extract %71[9] : vector<16x8xf32>
        %91 = vector.outerproduct %90, %56, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.extract %71[10] : vector<16x8xf32>
        %93 = vector.outerproduct %92, %58, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.extract %71[11] : vector<16x8xf32>
        %95 = vector.outerproduct %94, %60, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.extract %71[12] : vector<16x8xf32>
        %97 = vector.outerproduct %96, %62, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.extract %71[13] : vector<16x8xf32>
        %99 = vector.outerproduct %98, %64, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.extract %71[14] : vector<16x8xf32>
        %101 = vector.outerproduct %100, %66, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.extract %71[15] : vector<16x8xf32>
        %103 = vector.outerproduct %102, %68, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %103 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%34, %16, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %34 = "vector.extract"(%26) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%33, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %33 = "vector.extract"(%26) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%32, %16, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %32 = "vector.extract"(%26) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%31, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %31 = "vector.extract"(%26) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%30, %16, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %30 = "vector.extract"(%26) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%29, %16, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %29 = "vector.extract"(%26) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%28, %16, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %28 = "vector.extract"(%26) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%27, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %27 = "vector.extract"(%26) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %26 = "math.cos"(%25) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'math.cos -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%116) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %116 = "vector.outerproduct"(%115, %81, %114) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %115 = "vector.extract"(%84) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %114 = "vector.outerproduct"(%113, %79, %112) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %113 = "vector.extract"(%84) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %112 = "vector.outerproduct"(%111, %77, %110) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %111 = "vector.extract"(%84) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %110 = "vector.outerproduct"(%109, %75, %108) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %109 = "vector.extract"(%84) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %108 = "vector.outerproduct"(%107, %73, %106) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %107 = "vector.extract"(%84) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %106 = "vector.outerproduct"(%105, %71, %104) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %105 = "vector.extract"(%84) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %104 = "vector.outerproduct"(%103, %69, %102) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %103 = "vector.extract"(%84) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %102 = "vector.outerproduct"(%101, %67, %100) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %101 = "vector.extract"(%84) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %100 = "vector.outerproduct"(%99, %65, %98) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %99 = "vector.extract"(%84) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %98 = "vector.outerproduct"(%97, %63, %96) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %97 = "vector.extract"(%84) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %96 = "vector.outerproduct"(%95, %61, %94) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %95 = "vector.extract"(%84) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %94 = "vector.outerproduct"(%93, %59, %92) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %93 = "vector.extract"(%84) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %92 = "vector.outerproduct"(%91, %57, %90) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %91 = "vector.extract"(%84) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %90 = "vector.outerproduct"(%89, %55, %88) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %89 = "vector.extract"(%84) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %88 = "vector.outerproduct"(%87, %53, %86) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %87 = "vector.extract"(%84) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %86 = "vector.outerproduct"(%85, %51, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %85 = "vector.extract"(%84) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x2980f10) {
  %84 = "vector.shape_cast"(%83) : (vector<128xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::ShapeCastOp2DDownCastRewritePattern : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ShapeCastOp2DUpCastRewritePattern : 'vector.shape_cast -> ()' {
    ** Insert  : 'arith.constant'(0x2977d80)
    ** Insert  : 'vector.extract_strided_slice'(0x2200d40)
    ** Insert  : 'vector.insert'(0xeee500)
    ** Insert  : 'vector.extract_strided_slice'(0x2980d20)
    ** Insert  : 'vector.insert'(0x21f4ef0)
    ** Insert  : 'vector.extract_strided_slice'(0x2980b30)
    ** Insert  : 'vector.insert'(0x21f4fe0)
    ** Insert  : 'vector.extract_strided_slice'(0x2980940)
    ** Insert  : 'vector.insert'(0xcb2e40)
    ** Insert  : 'vector.extract_strided_slice'(0x2980750)
    ** Insert  : 'vector.insert'(0x29888b0)
    ** Insert  : 'vector.extract_strided_slice'(0x2980560)
    ** Insert  : 'vector.insert'(0x297be70)
    ** Insert  : 'vector.extract_strided_slice'(0x297bf20)
    ** Insert  : 'vector.insert'(0x2978040)
    ** Insert  : 'vector.extract_strided_slice'(0x29780f0)
    ** Insert  : 'vector.insert'(0x2988d10)
    ** Insert  : 'vector.extract_strided_slice'(0x2988dc0)
    ** Insert  : 'vector.insert'(0x2988e50)
    ** Insert  : 'vector.extract_strided_slice'(0x297c0d0)
    ** Insert  : 'vector.insert'(0x297c160)
    ** Insert  : 'vector.extract_strided_slice'(0x297c210)
    ** Insert  : 'vector.insert'(0x297c2a0)
    ** Insert  : 'vector.extract_strided_slice'(0x2996b60)
    ** Insert  : 'vector.insert'(0x2996bf0)
    ** Insert  : 'vector.extract_strided_slice'(0x2996ca0)
    ** Insert  : 'vector.insert'(0x2996d30)
    ** Insert  : 'vector.extract_strided_slice'(0x2994d40)
    ** Insert  : 'vector.insert'(0x2994dd0)
    ** Insert  : 'vector.extract_strided_slice'(0x2994e80)
    ** Insert  : 'vector.insert'(0x2994f10)
    ** Insert  : 'vector.extract_strided_slice'(0x2994fc0)
    ** Insert  : 'vector.insert'(0x2995050)
    ** Replace : 'vector.shape_cast'(0x2980f10)
    ** Erase   : 'vector.shape_cast'(0x2980f10)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %147 = "vector.extract"(%116) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x2980e80)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %147 = "vector.outerproduct"(%115, %81, %146) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %145 = "vector.extract"(%116) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x2980c90)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %145 = "vector.outerproduct"(%113, %79, %144) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %143 = "vector.extract"(%116) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x2980aa0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %143 = "vector.outerproduct"(%111, %77, %142) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %141 = "vector.extract"(%116) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x29808b0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %141 = "vector.outerproduct"(%109, %75, %140) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %139 = "vector.extract"(%116) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x29806c0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %139 = "vector.outerproduct"(%107, %73, %138) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %137 = "vector.extract"(%116) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x29804d0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %137 = "vector.outerproduct"(%105, %71, %136) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %135 = "vector.extract"(%116) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x2978860)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %135 = "vector.outerproduct"(%103, %69, %134) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297c650) {
  %133 = "vector.extract"(%116) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x297c650)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %133 = "vector.outerproduct"(%101, %67, %132) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b710) {
  %131 = "vector.extract"(%116) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x297b710)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %131 = "vector.outerproduct"(%99, %65, %130) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977fb0) {
  %129 = "vector.extract"(%116) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x2977fb0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %129 = "vector.outerproduct"(%97, %63, %128) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297b680) {
  %127 = "vector.extract"(%116) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x297b680)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %127 = "vector.outerproduct"(%95, %61, %126) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2977de0) {
  %125 = "vector.extract"(%116) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x2977de0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %125 = "vector.outerproduct"(%93, %59, %124) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xee4b70) {
  %123 = "vector.extract"(%116) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0xee4b70)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %123 = "vector.outerproduct"(%91, %57, %122) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xcfb090) {
  %121 = "vector.extract"(%116) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0xcfb090)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %121 = "vector.outerproduct"(%89, %55, %120) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f82b0) {
  %119 = "vector.extract"(%116) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x21f82b0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %119 = "vector.outerproduct"(%87, %53, %118) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0xecbb30) {
  %117 = "vector.extract"(%116) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0xecbb30)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %117 = "vector.outerproduct"(%85, %51, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2995050) {
  %116 = "vector.insert"(%115, %114) {position = [15]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x2995050)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994fc0) {
  %115 = "vector.extract_strided_slice"(%83) {offsets = [120], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2994f10) {
  %114 = "vector.insert"(%113, %112) {position = [14]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x2994f10)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994e80) {
  %113 = "vector.extract_strided_slice"(%83) {offsets = [112], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2994dd0) {
  %112 = "vector.insert"(%111, %110) {position = [13]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x2994dd0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994d40) {
  %111 = "vector.extract_strided_slice"(%83) {offsets = [104], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2996d30) {
  %110 = "vector.insert"(%109, %108) {position = [12]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x2996d30)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2996ca0) {
  %109 = "vector.extract_strided_slice"(%83) {offsets = [96], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2996bf0) {
  %108 = "vector.insert"(%107, %106) {position = [11]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x2996bf0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2996b60) {
  %107 = "vector.extract_strided_slice"(%83) {offsets = [88], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297c2a0) {
  %106 = "vector.insert"(%105, %104) {position = [10]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x297c2a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297c210) {
  %105 = "vector.extract_strided_slice"(%83) {offsets = [80], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297c160) {
  %104 = "vector.insert"(%103, %102) {position = [9]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x297c160)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297c0d0) {
  %103 = "vector.extract_strided_slice"(%83) {offsets = [72], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2988e50) {
  %102 = "vector.insert"(%101, %100) {position = [8]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x2988e50)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2988dc0) {
  %101 = "vector.extract_strided_slice"(%83) {offsets = [64], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2988d10) {
  %100 = "vector.insert"(%99, %98) {position = [7]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x2988d10)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x29780f0) {
  %99 = "vector.extract_strided_slice"(%83) {offsets = [56], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2978040) {
  %98 = "vector.insert"(%97, %96) {position = [6]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x2978040)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297bf20) {
  %97 = "vector.extract_strided_slice"(%83) {offsets = [48], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297be70) {
  %96 = "vector.insert"(%95, %94) {position = [5]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x297be70)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980560) {
  %95 = "vector.extract_strided_slice"(%83) {offsets = [40], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29888b0) {
  %94 = "vector.insert"(%93, %92) {position = [4]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x29888b0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980750) {
  %93 = "vector.extract_strided_slice"(%83) {offsets = [32], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0xcb2e40) {
  %92 = "vector.insert"(%91, %90) {position = [3]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0xcb2e40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980940) {
  %91 = "vector.extract_strided_slice"(%83) {offsets = [24], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x21f4fe0) {
  %90 = "vector.insert"(%89, %88) {position = [2]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x21f4fe0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980b30) {
  %89 = "vector.extract_strided_slice"(%83) {offsets = [16], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x21f4ef0) {
  %88 = "vector.insert"(%87, %86) {position = [1]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x21f4ef0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980d20) {
  %87 = "vector.extract_strided_slice"(%83) {offsets = [8], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0xeee500) {
  %86 = "vector.insert"(%85, %84) {position = [0]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0xeee500)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2200d40) {
  %85 = "vector.extract_strided_slice"(%83) {offsets = [0], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2977d80) {
  %84 = "arith.constant"() {value = dense<0.000000e+00> : vector<16x8xf32>} : () -> vector<16x8xf32>

  ** Erase   : 'arith.constant'(0x2977d80)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x21fd6a0) {
  %83 = "vector.shuffle"(%82, %82) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0xbccf90) {
  %82 = "vector.shape_cast"(%50) : (vector<8x16xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::ShapeCastOp2DDownCastRewritePattern : 'vector.shape_cast -> ()' {
    ** Insert  : 'arith.constant'(0x2977d80)
    ** Insert  : 'vector.extract'(0x29804d0)
    ** Insert  : 'vector.insert_strided_slice'(0x297c160)
    ** Insert  : 'vector.extract'(0x29806c0)
    ** Insert  : 'vector.insert_strided_slice'(0x297c2a0)
    ** Insert  : 'vector.extract'(0x29808b0)
    ** Insert  : 'vector.insert_strided_slice'(0x2996bf0)
    ** Insert  : 'vector.extract'(0x2980aa0)
    ** Insert  : 'vector.insert_strided_slice'(0x2996d30)
    ** Insert  : 'vector.extract'(0x2980c90)
    ** Insert  : 'vector.insert_strided_slice'(0x2994dd0)
    ** Insert  : 'vector.extract'(0x2980e80)
    ** Insert  : 'vector.insert_strided_slice'(0x2994f10)
    ** Insert  : 'vector.extract'(0x2980f10)
    ** Insert  : 'vector.insert_strided_slice'(0x2995050)
    ** Insert  : 'vector.extract'(0x2978860)
    ** Insert  : 'vector.insert_strided_slice'(0x2988e50)
    ** Replace : 'vector.shape_cast'(0xbccf90)
    ** Erase   : 'vector.shape_cast'(0xbccf90)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x21fd6a0) {
  %99 = "vector.shuffle"(%98, %98) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2988e50) {
  %98 = "vector.insert_strided_slice"(%97, %96) {offsets = [112], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2978860) {
  %97 = "vector.extract"(%50) {position = [7]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x2978860)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2988e50) {
  %97 = "vector.insert_strided_slice"(%49, %96) {offsets = [112], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2995050) {
  %96 = "vector.insert_strided_slice"(%95, %94) {offsets = [96], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980f10) {
  %95 = "vector.extract"(%50) {position = [6]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x2980f10)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2995050) {
  %95 = "vector.insert_strided_slice"(%47, %94) {offsets = [96], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2994f10) {
  %94 = "vector.insert_strided_slice"(%93, %92) {offsets = [80], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980e80) {
  %93 = "vector.extract"(%50) {position = [5]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x2980e80)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2994f10) {
  %93 = "vector.insert_strided_slice"(%45, %92) {offsets = [80], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2994dd0) {
  %92 = "vector.insert_strided_slice"(%91, %90) {offsets = [64], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980c90) {
  %91 = "vector.extract"(%50) {position = [4]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x2980c90)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2994dd0) {
  %91 = "vector.insert_strided_slice"(%43, %90) {offsets = [64], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2996d30) {
  %90 = "vector.insert_strided_slice"(%89, %88) {offsets = [48], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2980aa0) {
  %89 = "vector.extract"(%50) {position = [3]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x2980aa0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2996d30) {
  %89 = "vector.insert_strided_slice"(%41, %88) {offsets = [48], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2996bf0) {
  %88 = "vector.insert_strided_slice"(%87, %86) {offsets = [32], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29808b0) {
  %87 = "vector.extract"(%50) {position = [2]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x29808b0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2996bf0) {
  %87 = "vector.insert_strided_slice"(%39, %86) {offsets = [32], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x297c2a0) {
  %86 = "vector.insert_strided_slice"(%85, %84) {offsets = [16], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29806c0) {
  %85 = "vector.extract"(%50) {position = [1]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x29806c0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x297c2a0) {
  %85 = "vector.insert_strided_slice"(%37, %84) {offsets = [16], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x297c160) {
  %84 = "vector.insert_strided_slice"(%83, %82) {offsets = [0], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29804d0) {
  %83 = "vector.extract"(%50) {position = [0]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x29804d0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x297c160) {
  %83 = "vector.insert_strided_slice"(%35, %82) {offsets = [0], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2977d80) {
  %82 = "arith.constant"() {value = dense<0.000000e+00> : vector<128xf32>} : () -> vector<128xf32>

  ** Erase   : 'arith.constant'(0x2977d80)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x297c160) {
  %83 = "vector.insert_strided_slice"(%36, %0) {offsets = [0], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<128xf32>} : () -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %82 = "vector.load"(%18, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %80 = "vector.load"(%18, %79, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %79 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %78 = "vector.load"(%18, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %76 = "vector.load"(%18, %75, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %75 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %74 = "vector.load"(%18, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %72 = "vector.load"(%18, %71, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %71 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %70 = "vector.load"(%18, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %68 = "vector.load"(%18, %67, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %67 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %66 = "vector.load"(%18, %65, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %65 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %64 = "vector.load"(%18, %63, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %63 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %62 = "vector.load"(%18, %61, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %61 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %60 = "vector.load"(%18, %59, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %59 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %58 = "vector.load"(%18, %57, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %57 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %56 = "vector.load"(%18, %55, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %55 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %54 = "vector.load"(%18, %53, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %53 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %52 = "vector.load"(%18, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7bd0) {
  %51 = "vector.insert"(%50, %49) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x1ce7bd0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %50 = "vector.load"(%16, %25, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1ce7570) {
  %49 = "vector.insert"(%48, %47) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x1ce7570)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %48 = "vector.load"(%16, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x2989570) {
  %47 = "vector.insert"(%46, %45) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x2989570)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %46 = "vector.load"(%16, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29892e0) {
  %45 = "vector.insert"(%44, %43) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x29892e0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %44 = "vector.load"(%16, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x29890b0) {
  %43 = "vector.insert"(%42, %41) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x29890b0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %42 = "vector.load"(%16, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d7c0) {
  %41 = "vector.insert"(%40, %39) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x297d7c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %40 = "vector.load"(%16, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d530) {
  %39 = "vector.insert"(%38, %37) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x297d530)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %38 = "vector.load"(%16, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x297d2a0) {
  %37 = "vector.insert"(%36, %1) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x297d2a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %36 = "vector.load"(%16, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %25 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %18 = "memref.subview"(%10, %15) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %17 = "memref.subview"(%11, %14, %15) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %15 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %14 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %7 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %6 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %5 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %4 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %3 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %2 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2978440) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>

  ** Erase   : 'arith.constant'(0x2978440)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%34, %16, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %34 = "vector.extract"(%26) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%33, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %33 = "vector.extract"(%26) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%32, %16, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %32 = "vector.extract"(%26) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%31, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %31 = "vector.extract"(%26) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%30, %16, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %30 = "vector.extract"(%26) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%29, %16, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %29 = "vector.extract"(%26) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%28, %16, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %28 = "vector.extract"(%26) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%27, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %27 = "vector.extract"(%26) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %26 = "math.cos"(%25) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'math.cos -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%114) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %114 = "vector.outerproduct"(%98, %73, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %113 = "vector.outerproduct"(%97, %71, %112) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %112 = "vector.outerproduct"(%96, %69, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %111 = "vector.outerproduct"(%95, %67, %110) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %110 = "vector.outerproduct"(%94, %65, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %109 = "vector.outerproduct"(%93, %63, %108) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %108 = "vector.outerproduct"(%92, %61, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %107 = "vector.outerproduct"(%91, %59, %106) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %106 = "vector.outerproduct"(%90, %57, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %105 = "vector.outerproduct"(%89, %55, %104) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %104 = "vector.outerproduct"(%88, %53, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %103 = "vector.outerproduct"(%87, %51, %102) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %102 = "vector.outerproduct"(%86, %49, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %101 = "vector.outerproduct"(%85, %47, %100) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %100 = "vector.outerproduct"(%84, %45, %99) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %99 = "vector.outerproduct"(%83, %43, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994fc0) {
  %98 = "vector.extract_strided_slice"(%82) {offsets = [120], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994e80) {
  %97 = "vector.extract_strided_slice"(%82) {offsets = [112], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994d40) {
  %96 = "vector.extract_strided_slice"(%82) {offsets = [104], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2996ca0) {
  %95 = "vector.extract_strided_slice"(%82) {offsets = [96], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2996b60) {
  %94 = "vector.extract_strided_slice"(%82) {offsets = [88], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297c210) {
  %93 = "vector.extract_strided_slice"(%82) {offsets = [80], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297c0d0) {
  %92 = "vector.extract_strided_slice"(%82) {offsets = [72], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2988dc0) {
  %91 = "vector.extract_strided_slice"(%82) {offsets = [64], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x29780f0) {
  %90 = "vector.extract_strided_slice"(%82) {offsets = [56], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297bf20) {
  %89 = "vector.extract_strided_slice"(%82) {offsets = [48], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980560) {
  %88 = "vector.extract_strided_slice"(%82) {offsets = [40], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980750) {
  %87 = "vector.extract_strided_slice"(%82) {offsets = [32], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980940) {
  %86 = "vector.extract_strided_slice"(%82) {offsets = [24], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980b30) {
  %85 = "vector.extract_strided_slice"(%82) {offsets = [16], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980d20) {
  %84 = "vector.extract_strided_slice"(%82) {offsets = [8], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2200d40) {
  %83 = "vector.extract_strided_slice"(%82) {offsets = [0], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x21fd6a0) {
  %82 = "vector.shuffle"(%81, %81) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2988e50) {
  %81 = "vector.insert_strided_slice"(%42, %80) {offsets = [112], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2995050) {
  %80 = "vector.insert_strided_slice"(%41, %79) {offsets = [96], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2994f10) {
  %79 = "vector.insert_strided_slice"(%40, %78) {offsets = [80], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2994dd0) {
  %78 = "vector.insert_strided_slice"(%39, %77) {offsets = [64], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2996d30) {
  %77 = "vector.insert_strided_slice"(%38, %76) {offsets = [48], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2996bf0) {
  %76 = "vector.insert_strided_slice"(%37, %75) {offsets = [32], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x297c2a0) {
  %75 = "vector.insert_strided_slice"(%36, %74) {offsets = [16], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x297c160) {
  %74 = "vector.insert_strided_slice"(%35, %0) {offsets = [0], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %73 = "vector.load"(%17, %72, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %72 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %71 = "vector.load"(%17, %70, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %70 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %69 = "vector.load"(%17, %68, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %68 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %67 = "vector.load"(%17, %66, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %66 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %65 = "vector.load"(%17, %64, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %64 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %63 = "vector.load"(%17, %62, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %62 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %61 = "vector.load"(%17, %60, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %60 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %59 = "vector.load"(%17, %58, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %58 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %57 = "vector.load"(%17, %56, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %56 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %55 = "vector.load"(%17, %54, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %54 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %53 = "vector.load"(%17, %52, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %52 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %51 = "vector.load"(%17, %50, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %50 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %49 = "vector.load"(%17, %48, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %48 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %47 = "vector.load"(%17, %46, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %46 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %45 = "vector.load"(%17, %44, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %44 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %43 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %42 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %41 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %40 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %39 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %38 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %37 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %36 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %35 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<128xf32>} : () -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyLowerVectorsPass (iree-linalg-strategy-lower-vectors-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %24 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %26 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %28 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %30 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %31 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %32 = vector.load %subview_2[%31, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %33 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %34 = vector.load %subview_2[%33, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %35 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %36 = vector.load %subview_2[%35, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %37 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %38 = vector.load %subview_2[%37, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = vector.insert_strided_slice %22, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %62 = vector.insert_strided_slice %23, %61 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %63 = vector.insert_strided_slice %24, %62 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %64 = vector.insert_strided_slice %25, %63 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %65 = vector.insert_strided_slice %26, %64 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %66 = vector.insert_strided_slice %27, %65 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %67 = vector.insert_strided_slice %28, %66 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %68 = vector.insert_strided_slice %29, %67 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %69 = vector.shuffle %68, %68 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %70 = vector.extract_strided_slice %69 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %71 = vector.extract_strided_slice %69 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %72 = vector.extract_strided_slice %69 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %73 = vector.extract_strided_slice %69 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %74 = vector.extract_strided_slice %69 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %75 = vector.extract_strided_slice %69 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %76 = vector.extract_strided_slice %69 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %77 = vector.extract_strided_slice %69 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %78 = vector.extract_strided_slice %69 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %79 = vector.extract_strided_slice %69 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %80 = vector.extract_strided_slice %69 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %81 = vector.extract_strided_slice %69 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %82 = vector.extract_strided_slice %69 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %83 = vector.extract_strided_slice %69 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %84 = vector.extract_strided_slice %69 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %85 = vector.extract_strided_slice %69 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.outerproduct %70, %30, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.outerproduct %71, %32, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.outerproduct %72, %34, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.outerproduct %73, %36, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.outerproduct %74, %38, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.outerproduct %75, %40, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.outerproduct %76, %42, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.outerproduct %77, %44, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.outerproduct %78, %46, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.outerproduct %79, %48, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.outerproduct %80, %50, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.outerproduct %81, %52, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.outerproduct %82, %54, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.outerproduct %83, %56, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.outerproduct %84, %58, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.outerproduct %85, %60, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%34, %16, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %34 = "vector.extract"(%26) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%33, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %33 = "vector.extract"(%26) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%32, %16, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %32 = "vector.extract"(%26) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%31, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %31 = "vector.extract"(%26) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%30, %16, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %30 = "vector.extract"(%26) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%29, %16, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %29 = "vector.extract"(%26) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%28, %16, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %28 = "vector.extract"(%26) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%27, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %27 = "vector.extract"(%26) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %26 = "math.cos"(%25) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%114) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %114 = "vector.outerproduct"(%98, %73, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %113 = "vector.outerproduct"(%97, %71, %112) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %112 = "vector.outerproduct"(%96, %69, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %111 = "vector.outerproduct"(%95, %67, %110) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %110 = "vector.outerproduct"(%94, %65, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %109 = "vector.outerproduct"(%93, %63, %108) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %108 = "vector.outerproduct"(%92, %61, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %107 = "vector.outerproduct"(%91, %59, %106) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %106 = "vector.outerproduct"(%90, %57, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %105 = "vector.outerproduct"(%89, %55, %104) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %104 = "vector.outerproduct"(%88, %53, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %103 = "vector.outerproduct"(%87, %51, %102) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %102 = "vector.outerproduct"(%86, %49, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %101 = "vector.outerproduct"(%85, %47, %100) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %100 = "vector.outerproduct"(%84, %45, %99) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %99 = "vector.outerproduct"(%83, %43, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994fc0) {
  %98 = "vector.extract_strided_slice"(%82) {offsets = [120], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994e80) {
  %97 = "vector.extract_strided_slice"(%82) {offsets = [112], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994d40) {
  %96 = "vector.extract_strided_slice"(%82) {offsets = [104], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2996ca0) {
  %95 = "vector.extract_strided_slice"(%82) {offsets = [96], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2996b60) {
  %94 = "vector.extract_strided_slice"(%82) {offsets = [88], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297c210) {
  %93 = "vector.extract_strided_slice"(%82) {offsets = [80], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297c0d0) {
  %92 = "vector.extract_strided_slice"(%82) {offsets = [72], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2988dc0) {
  %91 = "vector.extract_strided_slice"(%82) {offsets = [64], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x29780f0) {
  %90 = "vector.extract_strided_slice"(%82) {offsets = [56], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297bf20) {
  %89 = "vector.extract_strided_slice"(%82) {offsets = [48], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980560) {
  %88 = "vector.extract_strided_slice"(%82) {offsets = [40], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980750) {
  %87 = "vector.extract_strided_slice"(%82) {offsets = [32], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980940) {
  %86 = "vector.extract_strided_slice"(%82) {offsets = [24], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980b30) {
  %85 = "vector.extract_strided_slice"(%82) {offsets = [16], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980d20) {
  %84 = "vector.extract_strided_slice"(%82) {offsets = [8], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2200d40) {
  %83 = "vector.extract_strided_slice"(%82) {offsets = [0], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x21fd6a0) {
  %82 = "vector.shuffle"(%81, %81) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2988e50) {
  %81 = "vector.insert_strided_slice"(%42, %80) {offsets = [112], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2995050) {
  %80 = "vector.insert_strided_slice"(%41, %79) {offsets = [96], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2994f10) {
  %79 = "vector.insert_strided_slice"(%40, %78) {offsets = [80], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2994dd0) {
  %78 = "vector.insert_strided_slice"(%39, %77) {offsets = [64], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2996d30) {
  %77 = "vector.insert_strided_slice"(%38, %76) {offsets = [48], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2996bf0) {
  %76 = "vector.insert_strided_slice"(%37, %75) {offsets = [32], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x297c2a0) {
  %75 = "vector.insert_strided_slice"(%36, %74) {offsets = [16], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x297c160) {
  %74 = "vector.insert_strided_slice"(%35, %0) {offsets = [0], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %73 = "vector.load"(%17, %72, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %72 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %71 = "vector.load"(%17, %70, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %70 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %69 = "vector.load"(%17, %68, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %68 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %67 = "vector.load"(%17, %66, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %66 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %65 = "vector.load"(%17, %64, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %64 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %63 = "vector.load"(%17, %62, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %62 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %61 = "vector.load"(%17, %60, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %60 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %59 = "vector.load"(%17, %58, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %58 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %57 = "vector.load"(%17, %56, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %56 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %55 = "vector.load"(%17, %54, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %54 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %53 = "vector.load"(%17, %52, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %52 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %51 = "vector.load"(%17, %50, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %50 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %49 = "vector.load"(%17, %48, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %48 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %47 = "vector.load"(%17, %46, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %46 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %45 = "vector.load"(%17, %44, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %44 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %43 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %42 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %41 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %40 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %39 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %38 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %37 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %36 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %35 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<128xf32>} : () -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %24 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %26 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %28 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %30 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %31 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %32 = vector.load %subview_2[%31, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %33 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %34 = vector.load %subview_2[%33, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %35 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %36 = vector.load %subview_2[%35, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %37 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %38 = vector.load %subview_2[%37, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = vector.insert_strided_slice %22, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %62 = vector.insert_strided_slice %23, %61 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %63 = vector.insert_strided_slice %24, %62 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %64 = vector.insert_strided_slice %25, %63 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %65 = vector.insert_strided_slice %26, %64 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %66 = vector.insert_strided_slice %27, %65 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %67 = vector.insert_strided_slice %28, %66 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %68 = vector.insert_strided_slice %29, %67 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %69 = vector.shuffle %68, %68 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %70 = vector.extract_strided_slice %69 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %71 = vector.extract_strided_slice %69 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %72 = vector.extract_strided_slice %69 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %73 = vector.extract_strided_slice %69 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %74 = vector.extract_strided_slice %69 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %75 = vector.extract_strided_slice %69 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %76 = vector.extract_strided_slice %69 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %77 = vector.extract_strided_slice %69 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %78 = vector.extract_strided_slice %69 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %79 = vector.extract_strided_slice %69 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %80 = vector.extract_strided_slice %69 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %81 = vector.extract_strided_slice %69 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %82 = vector.extract_strided_slice %69 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %83 = vector.extract_strided_slice %69 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %84 = vector.extract_strided_slice %69 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %85 = vector.extract_strided_slice %69 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.outerproduct %70, %30, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.outerproduct %71, %32, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.outerproduct %72, %34, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.outerproduct %73, %36, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.outerproduct %74, %38, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.outerproduct %75, %40, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.outerproduct %76, %42, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.outerproduct %77, %44, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.outerproduct %78, %46, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.outerproduct %79, %48, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.outerproduct %80, %50, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.outerproduct %81, %52, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.outerproduct %82, %54, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.outerproduct %83, %56, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.outerproduct %84, %58, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.outerproduct %85, %60, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %24 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %26 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %28 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %30 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %31 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %32 = vector.load %subview_2[%31, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %33 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %34 = vector.load %subview_2[%33, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %35 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %36 = vector.load %subview_2[%35, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %37 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %38 = vector.load %subview_2[%37, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = vector.insert_strided_slice %22, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %62 = vector.insert_strided_slice %23, %61 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %63 = vector.insert_strided_slice %24, %62 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %64 = vector.insert_strided_slice %25, %63 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %65 = vector.insert_strided_slice %26, %64 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %66 = vector.insert_strided_slice %27, %65 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %67 = vector.insert_strided_slice %28, %66 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %68 = vector.insert_strided_slice %29, %67 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %69 = vector.shuffle %68, %68 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %70 = vector.extract_strided_slice %69 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %71 = vector.extract_strided_slice %69 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %72 = vector.extract_strided_slice %69 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %73 = vector.extract_strided_slice %69 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %74 = vector.extract_strided_slice %69 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %75 = vector.extract_strided_slice %69 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %76 = vector.extract_strided_slice %69 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %77 = vector.extract_strided_slice %69 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %78 = vector.extract_strided_slice %69 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %79 = vector.extract_strided_slice %69 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %80 = vector.extract_strided_slice %69 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %81 = vector.extract_strided_slice %69 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %82 = vector.extract_strided_slice %69 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %83 = vector.extract_strided_slice %69 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %84 = vector.extract_strided_slice %69 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %85 = vector.extract_strided_slice %69 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.outerproduct %70, %30, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.outerproduct %71, %32, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.outerproduct %72, %34, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.outerproduct %73, %36, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.outerproduct %74, %38, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.outerproduct %75, %40, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.outerproduct %76, %42, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.outerproduct %77, %44, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.outerproduct %78, %46, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.outerproduct %79, %48, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.outerproduct %80, %50, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.outerproduct %81, %52, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.outerproduct %82, %54, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.outerproduct %83, %56, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.outerproduct %84, %58, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.outerproduct %85, %60, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %24 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %26 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %28 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %30 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %31 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %32 = vector.load %subview_2[%31, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %33 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %34 = vector.load %subview_2[%33, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %35 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %36 = vector.load %subview_2[%35, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %37 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %38 = vector.load %subview_2[%37, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = vector.insert_strided_slice %22, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %62 = vector.insert_strided_slice %23, %61 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %63 = vector.insert_strided_slice %24, %62 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %64 = vector.insert_strided_slice %25, %63 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %65 = vector.insert_strided_slice %26, %64 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %66 = vector.insert_strided_slice %27, %65 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %67 = vector.insert_strided_slice %28, %66 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %68 = vector.insert_strided_slice %29, %67 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %69 = vector.shuffle %68, %68 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %70 = vector.extract_strided_slice %69 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %71 = vector.extract_strided_slice %69 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %72 = vector.extract_strided_slice %69 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %73 = vector.extract_strided_slice %69 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %74 = vector.extract_strided_slice %69 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %75 = vector.extract_strided_slice %69 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %76 = vector.extract_strided_slice %69 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %77 = vector.extract_strided_slice %69 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %78 = vector.extract_strided_slice %69 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %79 = vector.extract_strided_slice %69 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %80 = vector.extract_strided_slice %69 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %81 = vector.extract_strided_slice %69 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %82 = vector.extract_strided_slice %69 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %83 = vector.extract_strided_slice %69 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %84 = vector.extract_strided_slice %69 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %85 = vector.extract_strided_slice %69 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.outerproduct %70, %30, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.outerproduct %71, %32, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.outerproduct %72, %34, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.outerproduct %73, %36, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.outerproduct %74, %38, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.outerproduct %75, %40, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.outerproduct %76, %42, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.outerproduct %77, %44, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.outerproduct %78, %46, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.outerproduct %79, %48, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.outerproduct %80, %50, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.outerproduct %81, %52, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.outerproduct %82, %54, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.outerproduct %83, %56, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.outerproduct %84, %58, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.outerproduct %85, %60, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%34, %16, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %34 = "vector.extract"(%26) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%33, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %33 = "vector.extract"(%26) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%32, %16, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %32 = "vector.extract"(%26) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%31, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %31 = "vector.extract"(%26) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%30, %16, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %30 = "vector.extract"(%26) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%29, %16, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %29 = "vector.extract"(%26) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%28, %16, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %28 = "vector.extract"(%26) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%27, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %27 = "vector.extract"(%26) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %26 = "math.cos"(%25) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%114) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %114 = "vector.outerproduct"(%98, %73, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %113 = "vector.outerproduct"(%97, %71, %112) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %112 = "vector.outerproduct"(%96, %69, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %111 = "vector.outerproduct"(%95, %67, %110) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %110 = "vector.outerproduct"(%94, %65, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %109 = "vector.outerproduct"(%93, %63, %108) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %108 = "vector.outerproduct"(%92, %61, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %107 = "vector.outerproduct"(%91, %59, %106) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %106 = "vector.outerproduct"(%90, %57, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %105 = "vector.outerproduct"(%89, %55, %104) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %104 = "vector.outerproduct"(%88, %53, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %103 = "vector.outerproduct"(%87, %51, %102) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %102 = "vector.outerproduct"(%86, %49, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %101 = "vector.outerproduct"(%85, %47, %100) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %100 = "vector.outerproduct"(%84, %45, %99) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %99 = "vector.outerproduct"(%83, %43, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994fc0) {
  %98 = "vector.extract_strided_slice"(%82) {offsets = [120], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994e80) {
  %97 = "vector.extract_strided_slice"(%82) {offsets = [112], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994d40) {
  %96 = "vector.extract_strided_slice"(%82) {offsets = [104], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2996ca0) {
  %95 = "vector.extract_strided_slice"(%82) {offsets = [96], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2996b60) {
  %94 = "vector.extract_strided_slice"(%82) {offsets = [88], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297c210) {
  %93 = "vector.extract_strided_slice"(%82) {offsets = [80], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297c0d0) {
  %92 = "vector.extract_strided_slice"(%82) {offsets = [72], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2988dc0) {
  %91 = "vector.extract_strided_slice"(%82) {offsets = [64], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x29780f0) {
  %90 = "vector.extract_strided_slice"(%82) {offsets = [56], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297bf20) {
  %89 = "vector.extract_strided_slice"(%82) {offsets = [48], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980560) {
  %88 = "vector.extract_strided_slice"(%82) {offsets = [40], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980750) {
  %87 = "vector.extract_strided_slice"(%82) {offsets = [32], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980940) {
  %86 = "vector.extract_strided_slice"(%82) {offsets = [24], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980b30) {
  %85 = "vector.extract_strided_slice"(%82) {offsets = [16], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980d20) {
  %84 = "vector.extract_strided_slice"(%82) {offsets = [8], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2200d40) {
  %83 = "vector.extract_strided_slice"(%82) {offsets = [0], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x21fd6a0) {
  %82 = "vector.shuffle"(%81, %81) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2988e50) {
  %81 = "vector.insert_strided_slice"(%42, %80) {offsets = [112], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2995050) {
  %80 = "vector.insert_strided_slice"(%41, %79) {offsets = [96], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2994f10) {
  %79 = "vector.insert_strided_slice"(%40, %78) {offsets = [80], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2994dd0) {
  %78 = "vector.insert_strided_slice"(%39, %77) {offsets = [64], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2996d30) {
  %77 = "vector.insert_strided_slice"(%38, %76) {offsets = [48], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2996bf0) {
  %76 = "vector.insert_strided_slice"(%37, %75) {offsets = [32], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x297c2a0) {
  %75 = "vector.insert_strided_slice"(%36, %74) {offsets = [16], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x297c160) {
  %74 = "vector.insert_strided_slice"(%35, %0) {offsets = [0], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %73 = "vector.load"(%17, %72, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %72 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %71 = "vector.load"(%17, %70, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %70 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %69 = "vector.load"(%17, %68, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %68 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %67 = "vector.load"(%17, %66, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %66 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %65 = "vector.load"(%17, %64, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %64 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %63 = "vector.load"(%17, %62, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %62 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %61 = "vector.load"(%17, %60, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %60 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %59 = "vector.load"(%17, %58, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %58 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %57 = "vector.load"(%17, %56, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %56 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %55 = "vector.load"(%17, %54, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %54 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %53 = "vector.load"(%17, %52, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %52 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %51 = "vector.load"(%17, %50, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %50 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %49 = "vector.load"(%17, %48, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %48 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %47 = "vector.load"(%17, %46, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %46 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %45 = "vector.load"(%17, %44, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %44 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %43 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %42 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %41 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %40 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %39 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %38 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %37 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %36 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %35 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<128xf32>} : () -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %24 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %26 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %28 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %30 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %31 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %32 = vector.load %subview_2[%31, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %33 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %34 = vector.load %subview_2[%33, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %35 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %36 = vector.load %subview_2[%35, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %37 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %38 = vector.load %subview_2[%37, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = vector.insert_strided_slice %22, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %62 = vector.insert_strided_slice %23, %61 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %63 = vector.insert_strided_slice %24, %62 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %64 = vector.insert_strided_slice %25, %63 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %65 = vector.insert_strided_slice %26, %64 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %66 = vector.insert_strided_slice %27, %65 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %67 = vector.insert_strided_slice %28, %66 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %68 = vector.insert_strided_slice %29, %67 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %69 = vector.shuffle %68, %68 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %70 = vector.extract_strided_slice %69 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %71 = vector.extract_strided_slice %69 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %72 = vector.extract_strided_slice %69 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %73 = vector.extract_strided_slice %69 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %74 = vector.extract_strided_slice %69 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %75 = vector.extract_strided_slice %69 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %76 = vector.extract_strided_slice %69 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %77 = vector.extract_strided_slice %69 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %78 = vector.extract_strided_slice %69 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %79 = vector.extract_strided_slice %69 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %80 = vector.extract_strided_slice %69 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %81 = vector.extract_strided_slice %69 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %82 = vector.extract_strided_slice %69 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %83 = vector.extract_strided_slice %69 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %84 = vector.extract_strided_slice %69 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %85 = vector.extract_strided_slice %69 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.outerproduct %70, %30, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.outerproduct %71, %32, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.outerproduct %72, %34, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.outerproduct %73, %36, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.outerproduct %74, %38, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.outerproduct %75, %40, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.outerproduct %76, %42, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.outerproduct %77, %44, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.outerproduct %78, %46, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.outerproduct %79, %48, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.outerproduct %80, %50, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.outerproduct %81, %52, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.outerproduct %82, %54, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.outerproduct %83, %56, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.outerproduct %84, %58, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.outerproduct %85, %60, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %24 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %26 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %28 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %30 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %31 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %32 = vector.load %subview_2[%31, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %33 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %34 = vector.load %subview_2[%33, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %35 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %36 = vector.load %subview_2[%35, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %37 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %38 = vector.load %subview_2[%37, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = vector.insert_strided_slice %22, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %62 = vector.insert_strided_slice %23, %61 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %63 = vector.insert_strided_slice %24, %62 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %64 = vector.insert_strided_slice %25, %63 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %65 = vector.insert_strided_slice %26, %64 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %66 = vector.insert_strided_slice %27, %65 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %67 = vector.insert_strided_slice %28, %66 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %68 = vector.insert_strided_slice %29, %67 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %69 = vector.shuffle %68, %68 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %70 = vector.extract_strided_slice %69 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %71 = vector.extract_strided_slice %69 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %72 = vector.extract_strided_slice %69 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %73 = vector.extract_strided_slice %69 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %74 = vector.extract_strided_slice %69 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %75 = vector.extract_strided_slice %69 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %76 = vector.extract_strided_slice %69 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %77 = vector.extract_strided_slice %69 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %78 = vector.extract_strided_slice %69 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %79 = vector.extract_strided_slice %69 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %80 = vector.extract_strided_slice %69 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %81 = vector.extract_strided_slice %69 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %82 = vector.extract_strided_slice %69 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %83 = vector.extract_strided_slice %69 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %84 = vector.extract_strided_slice %69 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %85 = vector.extract_strided_slice %69 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.outerproduct %70, %30, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.outerproduct %71, %32, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.outerproduct %72, %34, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.outerproduct %73, %36, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.outerproduct %74, %38, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.outerproduct %75, %40, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.outerproduct %76, %42, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.outerproduct %77, %44, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.outerproduct %78, %46, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.outerproduct %79, %48, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.outerproduct %80, %50, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.outerproduct %81, %52, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.outerproduct %82, %54, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.outerproduct %83, %56, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.outerproduct %84, %58, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.outerproduct %85, %60, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgVectorLowering (linalg-vector-lowering) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %24 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %26 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %28 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %30 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %31 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %32 = vector.load %subview_2[%31, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %33 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %34 = vector.load %subview_2[%33, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %35 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %36 = vector.load %subview_2[%35, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %37 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %38 = vector.load %subview_2[%37, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = vector.insert_strided_slice %22, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %62 = vector.insert_strided_slice %23, %61 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %63 = vector.insert_strided_slice %24, %62 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %64 = vector.insert_strided_slice %25, %63 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %65 = vector.insert_strided_slice %26, %64 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %66 = vector.insert_strided_slice %27, %65 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %67 = vector.insert_strided_slice %28, %66 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %68 = vector.insert_strided_slice %29, %67 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %69 = vector.shuffle %68, %68 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %70 = vector.extract_strided_slice %69 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %71 = vector.extract_strided_slice %69 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %72 = vector.extract_strided_slice %69 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %73 = vector.extract_strided_slice %69 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %74 = vector.extract_strided_slice %69 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %75 = vector.extract_strided_slice %69 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %76 = vector.extract_strided_slice %69 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %77 = vector.extract_strided_slice %69 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %78 = vector.extract_strided_slice %69 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %79 = vector.extract_strided_slice %69 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %80 = vector.extract_strided_slice %69 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %81 = vector.extract_strided_slice %69 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %82 = vector.extract_strided_slice %69 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %83 = vector.extract_strided_slice %69 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %84 = vector.extract_strided_slice %69 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %85 = vector.extract_strided_slice %69 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.outerproduct %70, %30, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.outerproduct %71, %32, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.outerproduct %72, %34, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.outerproduct %73, %36, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.outerproduct %74, %38, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.outerproduct %75, %40, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.outerproduct %76, %42, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.outerproduct %77, %44, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.outerproduct %78, %46, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.outerproduct %79, %48, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.outerproduct %80, %50, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.outerproduct %81, %52, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.outerproduct %82, %54, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.outerproduct %83, %56, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.outerproduct %84, %58, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.outerproduct %85, %60, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xdfdf30) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<128xf32>} : () -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200680) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f9c90) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f6140) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7de0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x21f7f00) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2200bf0) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0xcb7100) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0xd01aa0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xee5060) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21fd610) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xeee610) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x21f8220) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0xcb2fb0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed2220) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0xed22e0) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xed2540) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd710) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0xeee450) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x297ba70) {
  %16 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x21f7bd0) {
  %17 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x297b990) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xbccf00) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecc270) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xcff010) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x231dc80) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x21f3660) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29788f0) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0xecd7a0) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2323f00) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2200700) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d6d0) {
  %35 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991150) {
  %36 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2991080) {
  %37 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x2990fb0) {
  %38 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e800) {
  %39 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e730) {
  %40 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x232b600) {
  %41 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc82930) {
  %42 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc68a50) {
  %43 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29859a0) {
  %44 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x21f97d0) {
  %45 = "vector.load"(%17, %44, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985a30) {
  %46 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xc8fbb0) {
  %47 = "vector.load"(%17, %46, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985ac0) {
  %48 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0xcb9190) {
  %49 = "vector.load"(%17, %48, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985b50) {
  %50 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e5b0) {
  %51 = "vector.load"(%17, %50, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2985be0) {
  %52 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297ea30) {
  %53 = "vector.load"(%17, %52, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e520) {
  %54 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297e960) {
  %55 = "vector.load"(%17, %54, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e6a0) {
  %56 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7b00) {
  %57 = "vector.load"(%17, %56, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297e8d0) {
  %58 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x297d1b0) {
  %59 = "vector.load"(%17, %58, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297eb00) {
  %60 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7a30) {
  %61 = "vector.load"(%17, %60, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d3b0) {
  %62 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7960) {
  %63 = "vector.load"(%17, %62, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x297d640) {
  %64 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7890) {
  %65 = "vector.load"(%17, %64, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2988f30) {
  %66 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce77c0) {
  %67 = "vector.load"(%17, %66, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989160) {
  %68 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce76f0) {
  %69 = "vector.load"(%17, %68, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x29893f0) {
  %70 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1ce7620) {
  %71 = "vector.load"(%17, %70, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2989680) {
  %72 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x29858d0) {
  %73 = "vector.load"(%17, %72, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x297c160) {
  %74 = "vector.insert_strided_slice"(%35, %0) {offsets = [0], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x297c2a0) {
  %75 = "vector.insert_strided_slice"(%36, %74) {offsets = [16], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2996bf0) {
  %76 = "vector.insert_strided_slice"(%37, %75) {offsets = [32], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2996d30) {
  %77 = "vector.insert_strided_slice"(%38, %76) {offsets = [48], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2994dd0) {
  %78 = "vector.insert_strided_slice"(%39, %77) {offsets = [64], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2994f10) {
  %79 = "vector.insert_strided_slice"(%40, %78) {offsets = [80], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2995050) {
  %80 = "vector.insert_strided_slice"(%41, %79) {offsets = [96], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x2988e50) {
  %81 = "vector.insert_strided_slice"(%42, %80) {offsets = [112], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x21fd6a0) {
  %82 = "vector.shuffle"(%81, %81) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::ShuffleSplat : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::Canonicalize0DShuffleOp : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2200d40) {
  %83 = "vector.extract_strided_slice"(%82) {offsets = [0], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980d20) {
  %84 = "vector.extract_strided_slice"(%82) {offsets = [8], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980b30) {
  %85 = "vector.extract_strided_slice"(%82) {offsets = [16], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980940) {
  %86 = "vector.extract_strided_slice"(%82) {offsets = [24], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980750) {
  %87 = "vector.extract_strided_slice"(%82) {offsets = [32], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2980560) {
  %88 = "vector.extract_strided_slice"(%82) {offsets = [40], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297bf20) {
  %89 = "vector.extract_strided_slice"(%82) {offsets = [48], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x29780f0) {
  %90 = "vector.extract_strided_slice"(%82) {offsets = [56], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2988dc0) {
  %91 = "vector.extract_strided_slice"(%82) {offsets = [64], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297c0d0) {
  %92 = "vector.extract_strided_slice"(%82) {offsets = [72], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x297c210) {
  %93 = "vector.extract_strided_slice"(%82) {offsets = [80], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2996b60) {
  %94 = "vector.extract_strided_slice"(%82) {offsets = [88], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2996ca0) {
  %95 = "vector.extract_strided_slice"(%82) {offsets = [96], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994d40) {
  %96 = "vector.extract_strided_slice"(%82) {offsets = [104], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994e80) {
  %97 = "vector.extract_strided_slice"(%82) {offsets = [112], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2994fc0) {
  %98 = "vector.extract_strided_slice"(%82) {offsets = [120], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xecbc20) {
  %99 = "vector.outerproduct"(%83, %43, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x231cb50) {
  %100 = "vector.outerproduct"(%84, %45, %99) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29781a0) {
  %101 = "vector.outerproduct"(%85, %47, %100) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0xbcce30) {
  %102 = "vector.outerproduct"(%86, %49, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297b5b0) {
  %103 = "vector.outerproduct"(%87, %51, %102) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2977ee0) {
  %104 = "vector.outerproduct"(%88, %53, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c420) {
  %105 = "vector.outerproduct"(%89, %55, %104) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x297c580) {
  %106 = "vector.outerproduct"(%90, %57, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2978790) {
  %107 = "vector.outerproduct"(%91, %59, %106) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980400) {
  %108 = "vector.outerproduct"(%92, %61, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29805f0) {
  %109 = "vector.outerproduct"(%93, %63, %108) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29807e0) {
  %110 = "vector.outerproduct"(%94, %65, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x29809d0) {
  %111 = "vector.outerproduct"(%95, %67, %110) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980bc0) {
  %112 = "vector.outerproduct"(%96, %69, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980db0) {
  %113 = "vector.outerproduct"(%97, %71, %112) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x2980fa0) {
  %114 = "vector.outerproduct"(%98, %73, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0xeedef0) {
  "scf.yield"(%114) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'math.cos'(0x231a5a0) {
  %26 = "math.cos"(%25) {fastmath = #arith.fastmath<none>} : (vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x21f3b60) {
  %27 = "vector.extract"(%26) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xd09cd0) {
  "vector.store"(%27, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2984750) {
  %28 = "vector.extract"(%26) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcc3cd0) {
  "vector.store"(%28, %16, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a390) {
  %29 = "vector.extract"(%26) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbad430) {
  "vector.store"(%29, %16, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297a4b0) {
  %30 = "vector.extract"(%26) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xbacce0) {
  "vector.store"(%30, %16, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fc80) {
  %31 = "vector.extract"(%26) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba1190) {
  "vector.store"(%31, %16, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x297fec0) {
  %32 = "vector.extract"(%26) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xba34b0) {
  "vector.store"(%32, %16, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2986390) {
  %33 = "vector.extract"(%26) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x2986530) {
  "vector.store"(%33, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x29864b0) {
  %34 = "vector.extract"(%26) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0xcd3380) {
  "vector.store"(%34, %16, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b850) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x297b930) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0xd136a0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %24 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %26 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %28 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %30 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %31 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %32 = vector.load %subview_2[%31, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %33 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %34 = vector.load %subview_2[%33, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %35 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %36 = vector.load %subview_2[%35, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %37 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %38 = vector.load %subview_2[%37, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = vector.insert_strided_slice %22, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %62 = vector.insert_strided_slice %23, %61 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %63 = vector.insert_strided_slice %24, %62 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %64 = vector.insert_strided_slice %25, %63 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %65 = vector.insert_strided_slice %26, %64 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %66 = vector.insert_strided_slice %27, %65 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %67 = vector.insert_strided_slice %28, %66 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %68 = vector.insert_strided_slice %29, %67 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %69 = vector.shuffle %68, %68 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %70 = vector.extract_strided_slice %69 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %71 = vector.extract_strided_slice %69 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %72 = vector.extract_strided_slice %69 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %73 = vector.extract_strided_slice %69 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %74 = vector.extract_strided_slice %69 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %75 = vector.extract_strided_slice %69 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %76 = vector.extract_strided_slice %69 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %77 = vector.extract_strided_slice %69 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %78 = vector.extract_strided_slice %69 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %79 = vector.extract_strided_slice %69 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %80 = vector.extract_strided_slice %69 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %81 = vector.extract_strided_slice %69 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %82 = vector.extract_strided_slice %69 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %83 = vector.extract_strided_slice %69 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %84 = vector.extract_strided_slice %69 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %85 = vector.extract_strided_slice %69 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.outerproduct %70, %30, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.outerproduct %71, %32, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.outerproduct %72, %34, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.outerproduct %73, %36, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.outerproduct %74, %38, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.outerproduct %75, %40, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.outerproduct %76, %42, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.outerproduct %77, %44, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.outerproduct %78, %46, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.outerproduct %79, %48, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.outerproduct %80, %50, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.outerproduct %81, %52, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.outerproduct %82, %54, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.outerproduct %83, %56, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.outerproduct %84, %58, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.outerproduct %85, %60, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
        %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %23 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %24 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %25 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %26 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %27 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %28 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %29 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %30 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %31 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %32 = vector.load %subview_2[%31, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %33 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %34 = vector.load %subview_2[%33, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %35 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %36 = vector.load %subview_2[%35, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %37 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %38 = vector.load %subview_2[%37, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %39 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %41 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %43 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %45 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %47 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %51 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %53 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %57 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %59 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %61 = vector.insert_strided_slice %22, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %62 = vector.insert_strided_slice %23, %61 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %63 = vector.insert_strided_slice %24, %62 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %64 = vector.insert_strided_slice %25, %63 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %65 = vector.insert_strided_slice %26, %64 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %66 = vector.insert_strided_slice %27, %65 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %67 = vector.insert_strided_slice %28, %66 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %68 = vector.insert_strided_slice %29, %67 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %69 = vector.shuffle %68, %68 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %70 = vector.extract_strided_slice %69 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %71 = vector.extract_strided_slice %69 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %72 = vector.extract_strided_slice %69 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %73 = vector.extract_strided_slice %69 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %74 = vector.extract_strided_slice %69 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %75 = vector.extract_strided_slice %69 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %76 = vector.extract_strided_slice %69 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %77 = vector.extract_strided_slice %69 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %78 = vector.extract_strided_slice %69 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %79 = vector.extract_strided_slice %69 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %80 = vector.extract_strided_slice %69 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %81 = vector.extract_strided_slice %69 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %82 = vector.extract_strided_slice %69 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %83 = vector.extract_strided_slice %69 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %84 = vector.extract_strided_slice %69 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %85 = vector.extract_strided_slice %69 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.outerproduct %70, %30, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.outerproduct %71, %32, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %88 = vector.outerproduct %72, %34, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.outerproduct %73, %36, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %90 = vector.outerproduct %74, %38, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.outerproduct %75, %40, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %92 = vector.outerproduct %76, %42, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.outerproduct %77, %44, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %94 = vector.outerproduct %78, %46, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.outerproduct %79, %48, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %96 = vector.outerproduct %80, %50, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.outerproduct %81, %52, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %98 = vector.outerproduct %82, %54, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.outerproduct %83, %56, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %100 = vector.outerproduct %84, %58, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.outerproduct %85, %60, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %101 : vector<8x32xf32>
      }
      %13 = math.cos %12 : vector<8x32xf32>
      %14 = vector.extract %13[0] : vector<8x32xf32>
      vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.extract %13[1] : vector<8x32xf32>
      vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %16 = vector.extract %13[2] : vector<8x32xf32>
      vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.extract %13[3] : vector<8x32xf32>
      vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.extract %13[4] : vector<8x32xf32>
      vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.extract %13[5] : vector<8x32xf32>
      vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %20 = vector.extract %13[6] : vector<8x32xf32>
      vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.extract %13[7] : vector<8x32xf32>
      vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LLVMCPULowerExecutableTarget (iree-llvmcpu-lower-executable-target) //----- //
hal.executable.variant public @embedded_elf_x86_64, target = <"llvm-cpu", "embedded-elf-x86_64", {cpu = "generic", cpu_features = "", data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", native_vector_size = 16 : index, target_triple = "x86_64-unknown-unknown-eabi-elf"}> {
  hal.executable.export public @mm_cosine_static_dispatch_0_matmul_512x1024x256 ordinal(0) layout(#hal.pipeline.layout<push_constants = 0, sets = [<0, bindings = [<0, storage_buffer, ReadOnly>, <1, storage_buffer, ReadOnly>, <2, storage_buffer>]>]>) attributes {translation_info = #iree_codegen.translation_info<CPUDoubleTilingPadExpert>} {
  ^bb0(%arg0: !hal.device, %arg1: index, %arg2: index):
    %c8 = arith.constant 8 : index
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    hal.return %c8, %c2, %c1 : index, index, index
  }
  builtin.module {
    func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
      %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
      %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
      %c16 = arith.constant 16 : index
      %c8 = arith.constant 8 : index
      %c32 = arith.constant 32 : index
      %c256 = arith.constant 256 : index
      %c128 = arith.constant 128 : index
      %c0 = arith.constant 0 : index
      %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
      memref.assume_alignment %0, 64 : memref<512x256xf32>
      %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
      memref.assume_alignment %1, 64 : memref<256x1024xf32>
      %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
      memref.assume_alignment %2, 64 : memref<512x1024xf32>
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
      %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
      %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
      %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
      %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
      scf.for %arg0 = %c0 to %c256 step %c8 {
        %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
        %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
        %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
        %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
        %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
        %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
        %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
        scf.for %arg1 = %c0 to %c128 step %c32 {
          %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
            %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %23 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %24 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %25 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %26 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %27 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %28 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %29 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %30 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %31 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
            %32 = vector.load %subview_2[%31, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %33 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
            %34 = vector.load %subview_2[%33, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %35 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
            %36 = vector.load %subview_2[%35, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %37 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
            %38 = vector.load %subview_2[%37, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %39 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
            %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %41 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
            %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %43 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
            %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %45 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
            %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %47 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
            %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %49 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
            %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %51 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
            %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %53 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
            %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %55 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
            %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %57 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
            %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %59 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
            %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %61 = vector.insert_strided_slice %22, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
            %62 = vector.insert_strided_slice %23, %61 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
            %63 = vector.insert_strided_slice %24, %62 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
            %64 = vector.insert_strided_slice %25, %63 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
            %65 = vector.insert_strided_slice %26, %64 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
            %66 = vector.insert_strided_slice %27, %65 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
            %67 = vector.insert_strided_slice %28, %66 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
            %68 = vector.insert_strided_slice %29, %67 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
            %69 = vector.shuffle %68, %68 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
            %70 = vector.extract_strided_slice %69 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %71 = vector.extract_strided_slice %69 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %72 = vector.extract_strided_slice %69 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %73 = vector.extract_strided_slice %69 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %74 = vector.extract_strided_slice %69 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %75 = vector.extract_strided_slice %69 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %76 = vector.extract_strided_slice %69 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %77 = vector.extract_strided_slice %69 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %78 = vector.extract_strided_slice %69 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %79 = vector.extract_strided_slice %69 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %80 = vector.extract_strided_slice %69 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %81 = vector.extract_strided_slice %69 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %82 = vector.extract_strided_slice %69 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %83 = vector.extract_strided_slice %69 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %84 = vector.extract_strided_slice %69 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %85 = vector.extract_strided_slice %69 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %86 = vector.outerproduct %70, %30, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %87 = vector.outerproduct %71, %32, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %88 = vector.outerproduct %72, %34, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %89 = vector.outerproduct %73, %36, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %90 = vector.outerproduct %74, %38, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %91 = vector.outerproduct %75, %40, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %92 = vector.outerproduct %76, %42, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %93 = vector.outerproduct %77, %44, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %94 = vector.outerproduct %78, %46, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %95 = vector.outerproduct %79, %48, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %96 = vector.outerproduct %80, %50, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %97 = vector.outerproduct %81, %52, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %98 = vector.outerproduct %82, %54, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %99 = vector.outerproduct %83, %56, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %100 = vector.outerproduct %84, %58, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %101 = vector.outerproduct %85, %60, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            scf.yield %101 : vector<8x32xf32>
          }
          %13 = math.cos %12 : vector<8x32xf32>
          %14 = vector.extract %13[0] : vector<8x32xf32>
          vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %15 = vector.extract %13[1] : vector<8x32xf32>
          vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %16 = vector.extract %13[2] : vector<8x32xf32>
          vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %17 = vector.extract %13[3] : vector<8x32xf32>
          vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %18 = vector.extract %13[4] : vector<8x32xf32>
          vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %19 = vector.extract %13[5] : vector<8x32xf32>
          vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %20 = vector.extract %13[6] : vector<8x32xf32>
          vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %21 = vector.extract %13[7] : vector<8x32xf32>
          vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        }
      }
      return
    }
  }
}

#executable_target_embedded_elf_x86_64_ = #hal.executable.target<"llvm-cpu", "embedded-elf-x86_64", {cpu = "generic", cpu_features = "", data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", native_vector_size = 16 : index, target_triple = "x86_64-unknown-unknown-eabi-elf"}>
#map = affine_map<()[s0] -> (s0 * 256)>
#map1 = affine_map<()[s0] -> (s0 * 128)>
#map2 = affine_map<(d0) -> (d0 + 1)>
#map3 = affine_map<(d0) -> (d0 + 2)>
#map4 = affine_map<(d0) -> (d0 + 3)>
#map5 = affine_map<(d0) -> (d0 + 4)>
#map6 = affine_map<(d0) -> (d0 + 5)>
#map7 = affine_map<(d0) -> (d0 + 6)>
#map8 = affine_map<(d0) -> (d0 + 7)>
#map9 = affine_map<(d0) -> (d0 + 8)>
#map10 = affine_map<(d0) -> (d0 + 9)>
#map11 = affine_map<(d0) -> (d0 + 10)>
#map12 = affine_map<(d0) -> (d0 + 11)>
#map13 = affine_map<(d0) -> (d0 + 12)>
#map14 = affine_map<(d0) -> (d0 + 13)>
#map15 = affine_map<(d0) -> (d0 + 14)>
#map16 = affine_map<(d0) -> (d0 + 15)>
#pipeline_layout = #hal.pipeline.layout<push_constants = 0, sets = [<0, bindings = [<0, storage_buffer, ReadOnly>, <1, storage_buffer, ReadOnly>, <2, storage_buffer>]>]>
#translation = #iree_codegen.translation_info<CPUDoubleTilingPadExpert>
#device_target_llvm_cpu = #hal.device.target<"llvm-cpu", {executable_targets = [#executable_target_embedded_elf_x86_64_]}>
module attributes {hal.device.targets = [#device_target_llvm_cpu]} {
  hal.executable private @mm_cosine_static_dispatch_0 {
    hal.executable.variant public @embedded_elf_x86_64, target = #executable_target_embedded_elf_x86_64_ {
      hal.executable.export public @mm_cosine_static_dispatch_0_matmul_512x1024x256 ordinal(0) layout(#pipeline_layout) attributes {translation_info = #translation} {
      ^bb0(%arg0: !hal.device, %arg1: index, %arg2: index):
        %c8 = arith.constant 8 : index
        %c2 = arith.constant 2 : index
        %c1 = arith.constant 1 : index
        hal.return %c8, %c2, %c1 : index, index, index
      }
      builtin.module {
        func.func @mm_cosine_static_dispatch_0_matmul_512x1024x256() {
          %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
          %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
          %c16 = arith.constant 16 : index
          %c8 = arith.constant 8 : index
          %c32 = arith.constant 32 : index
          %c256 = arith.constant 256 : index
          %c128 = arith.constant 128 : index
          %c0 = arith.constant 0 : index
          %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
          memref.assume_alignment %0, 64 : memref<512x256xf32>
          %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
          memref.assume_alignment %1, 64 : memref<256x1024xf32>
          %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
          memref.assume_alignment %2, 64 : memref<512x1024xf32>
          %workgroup_id_x = hal.interface.workgroup.id[0] : index
          %workgroup_id_y = hal.interface.workgroup.id[1] : index
          %3 = affine.apply #map()[%workgroup_id_y]
          %4 = affine.apply #map1()[%workgroup_id_x]
          %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
          %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
          %subview_2 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
          scf.for %arg0 = %c0 to %c256 step %c8 {
            %5 = affine.apply #map2(%arg0)
            %6 = affine.apply #map3(%arg0)
            %7 = affine.apply #map4(%arg0)
            %8 = affine.apply #map5(%arg0)
            %9 = affine.apply #map6(%arg0)
            %10 = affine.apply #map7(%arg0)
            %11 = affine.apply #map8(%arg0)
            scf.for %arg1 = %c0 to %c128 step %c32 {
              %12 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %cst_0) -> (vector<8x32xf32>) {
                %22 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %23 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %24 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %25 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %26 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %27 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %28 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %29 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %30 = vector.load %subview_2[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %31 = affine.apply #map2(%arg2)
                %32 = vector.load %subview_2[%31, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %33 = affine.apply #map3(%arg2)
                %34 = vector.load %subview_2[%33, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %35 = affine.apply #map4(%arg2)
                %36 = vector.load %subview_2[%35, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %37 = affine.apply #map5(%arg2)
                %38 = vector.load %subview_2[%37, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %39 = affine.apply #map6(%arg2)
                %40 = vector.load %subview_2[%39, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %41 = affine.apply #map7(%arg2)
                %42 = vector.load %subview_2[%41, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %43 = affine.apply #map8(%arg2)
                %44 = vector.load %subview_2[%43, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %45 = affine.apply #map9(%arg2)
                %46 = vector.load %subview_2[%45, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %47 = affine.apply #map10(%arg2)
                %48 = vector.load %subview_2[%47, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %49 = affine.apply #map11(%arg2)
                %50 = vector.load %subview_2[%49, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %51 = affine.apply #map12(%arg2)
                %52 = vector.load %subview_2[%51, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %53 = affine.apply #map13(%arg2)
                %54 = vector.load %subview_2[%53, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %55 = affine.apply #map14(%arg2)
                %56 = vector.load %subview_2[%55, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %57 = affine.apply #map15(%arg2)
                %58 = vector.load %subview_2[%57, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %59 = affine.apply #map16(%arg2)
                %60 = vector.load %subview_2[%59, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %61 = vector.insert_strided_slice %22, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
                %62 = vector.insert_strided_slice %23, %61 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
                %63 = vector.insert_strided_slice %24, %62 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
                %64 = vector.insert_strided_slice %25, %63 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
                %65 = vector.insert_strided_slice %26, %64 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
                %66 = vector.insert_strided_slice %27, %65 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
                %67 = vector.insert_strided_slice %28, %66 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
                %68 = vector.insert_strided_slice %29, %67 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
                %69 = vector.shuffle %68, %68 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
                %70 = vector.extract_strided_slice %69 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %71 = vector.extract_strided_slice %69 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %72 = vector.extract_strided_slice %69 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %73 = vector.extract_strided_slice %69 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %74 = vector.extract_strided_slice %69 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %75 = vector.extract_strided_slice %69 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %76 = vector.extract_strided_slice %69 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %77 = vector.extract_strided_slice %69 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %78 = vector.extract_strided_slice %69 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %79 = vector.extract_strided_slice %69 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %80 = vector.extract_strided_slice %69 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %81 = vector.extract_strided_slice %69 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %82 = vector.extract_strided_slice %69 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %83 = vector.extract_strided_slice %69 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %84 = vector.extract_strided_slice %69 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %85 = vector.extract_strided_slice %69 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %86 = vector.outerproduct %70, %30, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %87 = vector.outerproduct %71, %32, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %88 = vector.outerproduct %72, %34, %87 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %89 = vector.outerproduct %73, %36, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %90 = vector.outerproduct %74, %38, %89 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %91 = vector.outerproduct %75, %40, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %92 = vector.outerproduct %76, %42, %91 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %93 = vector.outerproduct %77, %44, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %94 = vector.outerproduct %78, %46, %93 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %95 = vector.outerproduct %79, %48, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %96 = vector.outerproduct %80, %50, %95 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %97 = vector.outerproduct %81, %52, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %98 = vector.outerproduct %82, %54, %97 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %99 = vector.outerproduct %83, %56, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %100 = vector.outerproduct %84, %58, %99 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %101 = vector.outerproduct %85, %60, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                scf.yield %101 : vector<8x32xf32>
              }
              %13 = math.cos %12 : vector<8x32xf32>
              %14 = vector.extract %13[0] : vector<8x32xf32>
              vector.store %14, %subview_1[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %15 = vector.extract %13[1] : vector<8x32xf32>
              vector.store %15, %subview_1[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %16 = vector.extract %13[2] : vector<8x32xf32>
              vector.store %16, %subview_1[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %17 = vector.extract %13[3] : vector<8x32xf32>
              vector.store %17, %subview_1[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %18 = vector.extract %13[4] : vector<8x32xf32>
              vector.store %18, %subview_1[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %19 = vector.extract %13[5] : vector<8x32xf32>
              vector.store %19, %subview_1[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %20 = vector.extract %13[6] : vector<8x32xf32>
              vector.store %20, %subview_1[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %21 = vector.extract %13[7] : vector<8x32xf32>
              vector.store %21, %subview_1[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            }
          }
          return
        }
      }
    }
  }
}

