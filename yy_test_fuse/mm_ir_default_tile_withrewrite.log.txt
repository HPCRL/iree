Pass Manager with 1 passes:
builtin.module(hal.executable(hal.executable.variant(iree-llvmcpu-lower-executable-target{test-lowering-configuration=false use-lowering-pipeline=})))


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e4a1e0) {
  "flow.dispatch.tensor.store"(%7, %3) {operand_segment_sizes = array<i32: 1, 1, 0, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 512, 1024>, static_strides = array<i64: 1, 1>} : (tensor<512x1024xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x1e5a1f0) {
  "linalg.yield"(%9) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1e5a0a0) {
  %9 = "arith.addf"(%arg2, %8) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x1e5a150) {
  %8 = "arith.mulf"(%arg0, %arg1) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1ea7b10) {
  %6 = "flow.dispatch.tensor.load"(%3) {operand_segment_sizes = array<i32: 1, 0, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 512, 1024>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>) -> tensor<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1ea7a60) {
  %5 = "flow.dispatch.tensor.load"(%2) {operand_segment_sizes = array<i32: 1, 0, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 256, 1024>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>) -> tensor<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1ea64c0) {
  %4 = "flow.dispatch.tensor.load"(%1) {operand_segment_sizes = array<i32: 1, 0, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 512, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>) -> tensor<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %3 = "hal.interface.binding.subspan"(%0) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %2 = "hal.interface.binding.subspan"(%0) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %1 = "hal.interface.binding.subspan"(%0) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0x1e943f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %0 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.return'(0x1e92240) {
  "hal.return"(%0#0, %0#1, %0#2) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.workgroup_count_from_dag_root'(0x1e61a40) {
  %0:3 = "flow.dispatch.workgroup_count_from_dag_root"(%arg1, %arg2, %arg3) : (index, index, index) -> (index, index, index)


  * Pattern mlir::iree_compiler::(anonymous namespace)::LowerDispatchWorkgroupCountForDagRootOp : 'flow.dispatch.workgroup_count_from_dag_root -> ()' {
    ** Insert  : 'arith.constant'(0x1f953c0)
    ** Insert  : 'arith.constant'(0x1f99d20)
    ** Insert  : 'arith.constant'(0x1f997e0)
    ** Replace : 'flow.dispatch.workgroup_count_from_dag_root'(0x1e61a40)
    ** Erase   : 'flow.dispatch.workgroup_count_from_dag_root'(0x1e61a40)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.return'(0x1e92240) {
  "hal.return"(%0, %1, %2) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f997e0) {
  %2 = "arith.constant"() {value = 1 : index} : () -> index

  ** Erase   : 'arith.constant'(0x1f997e0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.return'(0x1e92240) {
  "hal.return"(%1, %2, %0) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a7a0) {
  %0 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f99d20) {
  %2 = "arith.constant"() {value = 2 : index} : () -> index

  ** Erase   : 'arith.constant'(0x1f99d20)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.return'(0x1e92240) {
  "hal.return"(%2, %0, %1) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f997e0) {
  %0 = "arith.constant"() {value = 2 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f953c0) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x1f953c0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.return'(0x1e92240) {
  "hal.return"(%0, %1, %2) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f99d20) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.return'(0x1e92240) {
  "hal.return"(%0, %1, %2) : (index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a7a0) {
  %2 = "arith.constant"() {value = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f997e0) {
  %1 = "arith.constant"() {value = 2 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f99d20) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%32, %8, %arg0, %arg1, %19, %22) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2088420) {
  %36 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x2088420)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2088340) {
  %35 = "affine.apply"(%19) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x2088340)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2088250) {
  %34 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x2088250)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20881c0) {
  %33 = "affine.apply"(%19) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x20881c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2082420) {
  "linalg.yield"(%34) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %34 = "arith.addf"(%arg4, %33) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e5ec10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2078900) {
  %33 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x1da0250) {
  %31 = "tensor.extract_slice"(%11, %arg0, %arg1, %19, %22) {operand_segment_sizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<512x1024xf32>, index, index, index, index) -> tensor<?x?xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::SwapExtractSliceWithDispatchTensorLoad : 'tensor.extract_slice -> ()' {
    ** Insert  : 'flow.dispatch.tensor.load'(0x208c530)
    ** Replace : 'tensor.extract_slice'(0x1da0250)
    ** Erase   : 'tensor.extract_slice'(0x1da0250)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e5ec10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %31 = "flow.dispatch.tensor.load"(%8, %arg0, %arg1, %19, %22) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x2085eb0) {
  %30 = "tensor.extract_slice"(%10, %arg1, %22) {operand_segment_sizes = array<i32: 1, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<256x1024xf32>, index, index) -> tensor<256x?xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::SwapExtractSliceWithDispatchTensorLoad : 'tensor.extract_slice -> ()' {
    ** Insert  : 'flow.dispatch.tensor.load'(0x208d650)
    ** Replace : 'tensor.extract_slice'(0x2085eb0)
    ** Erase   : 'tensor.extract_slice'(0x2085eb0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e5ec10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %30 = "flow.dispatch.tensor.load"(%7, %arg1, %22) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x20848f0) {
  %29 = "tensor.extract_slice"(%9, %arg0, %19) {operand_segment_sizes = array<i32: 1, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (tensor<512x256xf32>, index, index) -> tensor<?x256xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::SwapExtractSliceWithDispatchTensorLoad : 'tensor.extract_slice -> ()' {
    ** Insert  : 'flow.dispatch.tensor.load'(0x2085eb0)
    ** Replace : 'tensor.extract_slice'(0x20848f0)
    ** Erase   : 'tensor.extract_slice'(0x20848f0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e5ec10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x2085eb0) {
  %29 = "flow.dispatch.tensor.load"(%6, %arg0, %19) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2084750) {
  %28 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x2084750)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20846c0) {
  %27 = "affine.apply"(%19) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x20846c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2083e20) {
  %26 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x2083e20)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2082490) {
  %25 = "affine.apply"(%19) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x2082490)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2080c50) {
  %24 = "affine.apply"(%22) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x2080c50)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2080bc0) {
  %23 = "affine.apply"(%19) {map = affine_map<(d0) -> (d0 - 1)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x2080bc0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x2068270) {
  %22 = "affine.min"(%arg1) {map = affine_map<(d0) -> (128, -d0 + 1024)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %21 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %20 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x2069e00) {
  %19 = "affine.min"(%arg0) {map = affine_map<(d0) -> (256, -d0 + 512)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %18 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %16 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %15 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %14 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %13 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2068880) {
  %0 = "arith.constant"() {value = 128 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2068880)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206bb70) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

  ** Erase   : 'arith.constant'(0x206bb70)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %0 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9aea0) {
  %1 = "arith.constant"() {value = 1 : index} : () -> index

  ** Erase   : 'arith.constant'(0x1f9aea0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %1 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x1e5a1f0) {
  "linalg.yield"(%17) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1e5a0a0) {
  %17 = "arith.addf"(%arg2, %16) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {
  ** Erase   : 'linalg.matmul'(0x1e89a60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1ea7b10) {
  %8 = "flow.dispatch.tensor.load"(%5) {operand_segment_sizes = array<i32: 1, 0, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 512, 1024>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>) -> tensor<512x1024xf32>

  ** Erase   : 'flow.dispatch.tensor.load'(0x1ea7b10)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1ea7a60) {
  %7 = "flow.dispatch.tensor.load"(%4) {operand_segment_sizes = array<i32: 1, 0, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 256, 1024>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>) -> tensor<256x1024xf32>

  ** Erase   : 'flow.dispatch.tensor.load'(0x1ea7a60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1ea64c0) {
  %6 = "flow.dispatch.tensor.load"(%3) {operand_segment_sizes = array<i32: 1, 0, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 512, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>) -> tensor<512x256xf32>

  ** Erase   : 'flow.dispatch.tensor.load'(0x1ea64c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %5 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %4 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %3 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %2 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%19, %5, %arg0, %arg1, %12, %15) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2082420) {
  "linalg.yield"(%21) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %21 = "arith.addf"(%arg4, %20) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e5ec10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2078900) {
  %20 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %18 = "flow.dispatch.tensor.load"(%5, %arg0, %arg1, %12, %15) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %17 = "flow.dispatch.tensor.load"(%4, %arg1, %15) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x2085eb0) {
  %16 = "flow.dispatch.tensor.load"(%3, %arg0, %12) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x2068270) {
  %15 = "affine.min"(%arg1) {map = affine_map<(d0) -> (128, -d0 + 1024)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %14 = "affine.apply"(%7) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%6) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x2069e00) {
  %12 = "affine.min"(%arg0) {map = affine_map<(d0) -> (256, -d0 + 512)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %11 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %10 = "affine.apply"(%8) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %9 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %8 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %7 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %6 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %5 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %4 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %3 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %2 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %1 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %0 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%19, %5, %arg0, %arg1, %12, %15) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2082420) {
  "linalg.yield"(%21) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %21 = "arith.addf"(%arg4, %20) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e5ec10) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2078900) {
  %20 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %18 = "flow.dispatch.tensor.load"(%5, %arg0, %arg1, %12, %15) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %17 = "flow.dispatch.tensor.load"(%4, %arg1, %15) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x2085eb0) {
  %16 = "flow.dispatch.tensor.load"(%3, %arg0, %12) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x2068270) {
  %15 = "affine.min"(%arg1) {map = affine_map<(d0) -> (128, -d0 + 1024)>} : (index) -> index


  * Pattern CanonicalizeSingleResultAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern DeduplicateAffineMinMaxExpressions<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern MergeAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern CanonicalizeAffineMinMaxOpExprAndTermOrder<mlir::AffineMinOp> : 'affine.min -> ()' {
    ** Insert  : 'affine.min'(0x20846c0)
    ** Replace : 'affine.min'(0x2068270)
    ** Erase   : 'affine.min'(0x2068270)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%19, %5, %arg0, %arg1, %12, %15) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %18 = "flow.dispatch.tensor.load"(%5, %arg0, %arg1, %12, %15) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %17 = "flow.dispatch.tensor.load"(%4, %arg1, %15) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x20846c0) {
  %15 = "affine.min"(%arg1) {map = affine_map<(d0) -> (-d0 + 1024, 128)>} : (index) -> index


  * Pattern CanonicalizeSingleResultAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern DeduplicateAffineMinMaxExpressions<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern MergeAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern CanonicalizeAffineMinMaxOpExprAndTermOrder<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::(anonymous namespace)::FoldAffineMinOverDistributedLoopInductionVariable : 'affine.min -> ()' {
    ** Insert  : 'affine.apply'(0x208be40)
    ** Replace : 'affine.min'(0x20846c0)
    ** Erase   : 'affine.min'(0x20846c0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %17 = "flow.dispatch.tensor.load"(%4, %arg1, %15) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %18 = "flow.dispatch.tensor.load"(%5, %arg0, %arg1, %12, %15) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%19, %5, %arg0, %arg1, %12, %15) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x208be40) {
  %15 = "affine.apply"() {map = affine_map<() -> (128)>} : () -> index

  ** Erase   : 'affine.apply'(0x208be40)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%19, %6, %arg0, %arg1, %13, %0) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %18 = "flow.dispatch.tensor.load"(%6, %arg0, %arg1, %13, %0) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %17 = "flow.dispatch.tensor.load"(%5, %arg1, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f953c0) {
  %0 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %15 = "affine.apply"(%8) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%7) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x2069e00) {
  %13 = "affine.min"(%arg0) {map = affine_map<(d0) -> (256, -d0 + 512)>} : (index) -> index


  * Pattern CanonicalizeSingleResultAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern DeduplicateAffineMinMaxExpressions<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern MergeAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern CanonicalizeAffineMinMaxOpExprAndTermOrder<mlir::AffineMinOp> : 'affine.min -> ()' {
    ** Insert  : 'affine.min'(0x2068270)
    ** Replace : 'affine.min'(0x2069e00)
    ** Erase   : 'affine.min'(0x2069e00)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%19, %6, %arg0, %arg1, %13, %0) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %18 = "flow.dispatch.tensor.load"(%6, %arg0, %arg1, %13, %0) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x2085eb0) {
  %16 = "flow.dispatch.tensor.load"(%4, %arg0, %13) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x2068270) {
  %13 = "affine.min"(%arg0) {map = affine_map<(d0) -> (-d0 + 512, 256)>} : (index) -> index


  * Pattern CanonicalizeSingleResultAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern DeduplicateAffineMinMaxExpressions<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern MergeAffineMinMaxOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern CanonicalizeAffineMinMaxOpExprAndTermOrder<mlir::AffineMinOp> : 'affine.min -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::(anonymous namespace)::FoldAffineMinOverDistributedLoopInductionVariable : 'affine.min -> ()' {
    ** Insert  : 'affine.apply'(0x208be40)
    ** Replace : 'affine.min'(0x2068270)
    ** Erase   : 'affine.min'(0x2068270)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x2085eb0) {
  %16 = "flow.dispatch.tensor.load"(%4, %arg0, %13) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %18 = "flow.dispatch.tensor.load"(%6, %arg0, %arg1, %13, %0) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%19, %6, %arg0, %arg1, %13, %0) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x208be40) {
  %13 = "affine.apply"() {map = affine_map<() -> (256)>} : () -> index

  ** Erase   : 'affine.apply'(0x208be40)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%19, %7, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x2085eb0) {
  %16 = "flow.dispatch.tensor.load"(%5, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x20687c0) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %11 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %10 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %9 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %8 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %5 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%19, %7, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2082420) {
  "linalg.yield"(%21) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %21 = "arith.addf"(%arg4, %20) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e5ec10) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2078900) {
  %20 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %17 = "flow.dispatch.tensor.load"(%6, %arg1, %1) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x2085eb0) {
  %16 = "flow.dispatch.tensor.load"(%5, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %15 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%8) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %11 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %10 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %9 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %8 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %5 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f953c0) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x20687c0) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%19, %7, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2082420) {
  "linalg.yield"(%21) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %21 = "arith.addf"(%arg4, %20) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e5ec10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2078900) {
  %20 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %17 = "flow.dispatch.tensor.load"(%6, %arg1, %1) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x2085eb0) {
  %16 = "flow.dispatch.tensor.load"(%5, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %15 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%8) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %11 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %10 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %9 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %8 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %5 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f953c0) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x20687c0) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After TileAndDistributeToWorkgroups (iree-codegen-tile-and-distribute-to-workgroups) //----- //
hal.executable.variant public @embedded_elf_x86_64, target = <"llvm-cpu", "embedded-elf-x86_64", {cpu = "generic", cpu_features = "", data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", native_vector_size = 16 : index, target_triple = "x86_64-unknown-unknown-eabi-elf"}> {
  hal.executable.export public @matmul_static_dispatch_0_matmul_512x1024x256 ordinal(0) layout(#hal.pipeline.layout<push_constants = 0, sets = [<0, bindings = [<0, storage_buffer, ReadOnly>, <1, storage_buffer, ReadOnly>, <2, storage_buffer>]>]>) attributes {translation_info = #iree_codegen.translation_info<CPUDoubleTilingPadExpert>} {
  ^bb0(%arg0: !hal.device, %arg1: index, %arg2: index, %arg3: index):
    %c8 = arith.constant 8 : index
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    hal.return %c8, %c2, %c1 : index, index, index
  }
  builtin.module {
    func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
      %c256 = arith.constant 256 : index
      %c128 = arith.constant 128 : index
      %c1024 = arith.constant 1024 : index
      %c512 = arith.constant 512 : index
      %c0 = arith.constant 0 : index
      %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
      %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
      %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_count_x = hal.interface.workgroup.count[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %workgroup_count_y = hal.interface.workgroup.count[1] : index
      %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
      %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
      scf.for %arg0 = %3 to %c512 step %4 {
        %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
        %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
        scf.for %arg1 = %5 to %c1024 step %6 {
          %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%c256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<?x256xf32>
          %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x?xf32>
          %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<?x?xf32>
          %10 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%7, %8 : tensor<?x256xf32>, tensor<256x?xf32>) outs(%9 : tensor<?x?xf32>) -> tensor<?x?xf32>
          flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
        }
      }
      return
    }
  }
}

// -----// IR Dump After TileAndDecomposeAttention (iree-linalg-ext-tile-and-decompose-attention) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c512 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c1024 step %6 {
      %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%c256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<?x256xf32>
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x?xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<?x?xf32>
      %10 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%7, %8 : tensor<?x256xf32>, tensor<256x?xf32>) outs(%9 : tensor<?x?xf32>) -> tensor<?x?xf32>
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After DecomposeSoftmax (iree-linalg-ext-decompose-softmax) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c512 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c1024 step %6 {
      %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%c256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<?x256xf32>
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x?xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<?x?xf32>
      %10 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%7, %8 : tensor<?x256xf32>, tensor<256x?xf32>) outs(%9 : tensor<?x?xf32>) -> tensor<?x?xf32>
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%19, %7, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2082420) {
  "linalg.yield"(%21) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %21 = "arith.addf"(%arg4, %20) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e5ec10) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveCstOutsDependency : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2078900) {
  %20 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %17 = "flow.dispatch.tensor.load"(%6, %arg1, %1) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x2085eb0) {
  %16 = "flow.dispatch.tensor.load"(%5, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %15 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%8) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %11 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %10 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %9 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %8 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %5 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f953c0) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x20687c0) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%19, %7, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2082420) {
  "linalg.yield"(%21) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %21 = "arith.addf"(%arg4, %20) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e5ec10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2078900) {
  %20 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %17 = "flow.dispatch.tensor.load"(%6, %arg1, %1) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x2085eb0) {
  %16 = "flow.dispatch.tensor.load"(%5, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %15 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%8) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %11 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %10 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %9 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %8 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %5 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f953c0) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x20687c0) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After ConvertToDestinationPassingStyle (iree-codegen-convert-to-destination-passing-style) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c512 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c1024 step %6 {
      %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%c256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<?x256xf32>
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x?xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<?x?xf32>
      %10 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%7, %8 : tensor<?x256xf32>, tensor<256x?xf32>) outs(%9 : tensor<?x?xf32>) -> tensor<?x?xf32>
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%19, %7, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2082420) {
  "linalg.yield"(%21) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %21 = "arith.addf"(%arg4, %20) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e5ec10) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2078900) {
  %20 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %17 = "flow.dispatch.tensor.load"(%6, %arg1, %1) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x2085eb0) {
  %16 = "flow.dispatch.tensor.load"(%5, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %15 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%8) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %11 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %10 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %9 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %8 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %5 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f953c0) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x20687c0) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After FoldAffineMinInDistributedLoops (iree-codegen-fold-affinemin-in-distributed-loops) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c512 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c1024 step %6 {
      %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [%c256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<?x256xf32>
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x?xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<?x?xf32>
      %10 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%7, %8 : tensor<?x256xf32>, tensor<256x?xf32>) outs(%9 : tensor<?x?xf32>) -> tensor<?x?xf32>
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [%c256, %c128], strides = [1, 1] : tensor<?x?xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.func'(0x1e943f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x20687c0) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f953c0) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %2 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %3 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %4 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %5 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %6 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %7 = "hal.interface.binding.subspan"(%4) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %8 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %9 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %10 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %11 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %13 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%8) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %15 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x2085eb0) {
  %16 = "flow.dispatch.tensor.load"(%5, %arg0, %0) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: -9223372036854775808, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index, index) -> tensor<?x256xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
    ** Insert  : 'flow.dispatch.tensor.load'(0x1e5a150)
    ** Insert  : 'tensor.cast'(0x2e856d0)
    ** Replace : 'flow.dispatch.tensor.load'(0x2085eb0)
    ** Erase   : 'flow.dispatch.tensor.load'(0x2085eb0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x2e856d0) {
  %17 = "tensor.cast"(%16) : (tensor<256x256xf32>) -> tensor<?x256xf32>


  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0x1e943f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %16 = "flow.dispatch.tensor.load"(%5, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %18 = "flow.dispatch.tensor.load"(%6, %arg1, %1) {operand_segment_sizes = array<i32: 1, 0, 1, 1, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index, index) -> tensor<256x?xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
    ** Insert  : 'flow.dispatch.tensor.load'(0x1e5a0a0)
    ** Insert  : 'tensor.cast'(0x2e85c30)
    ** Replace : 'flow.dispatch.tensor.load'(0x208d650)
    ** Erase   : 'flow.dispatch.tensor.load'(0x208d650)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x2e85c30) {
  %19 = "tensor.cast"(%18) : (tensor<256x128xf32>) -> tensor<256x?xf32>


  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0x1e943f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %18 = "flow.dispatch.tensor.load"(%6, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208c530) {
  %20 = "flow.dispatch.tensor.load"(%7, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> tensor<?x?xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
    ** Insert  : 'flow.dispatch.tensor.load'(0x208d650)
    ** Insert  : 'tensor.cast'(0x2e8b640)
    ** Replace : 'flow.dispatch.tensor.load'(0x208c530)
    ** Erase   : 'flow.dispatch.tensor.load'(0x208c530)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x2e8b640) {
  %21 = "tensor.cast"(%20) : (tensor<256x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0x1e943f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%7, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e5ec10) {

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
    ** Insert  : 'linalg.matmul'(0x1e89a60)
    ** Insert  : 'tensor.cast'(0x2e8c0a0)
    ** Replace : 'linalg.matmul'(0x1e5ec10)
    ** Erase   : 'linalg.matmul'(0x1e5ec10)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x2e8b640) {
  %21 = "tensor.cast"(%20) : (tensor<256x128xf32>) -> tensor<?x?xf32>

  ** Erase   : 'tensor.cast'(0x2e8b640)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x2e85c30) {
  %19 = "tensor.cast"(%18) : (tensor<256x128xf32>) -> tensor<256x?xf32>

  ** Erase   : 'tensor.cast'(0x2e85c30)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x2e856d0) {
  %17 = "tensor.cast"(%16) : (tensor<256x256xf32>) -> tensor<?x256xf32>

  ** Erase   : 'tensor.cast'(0x2e856d0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x2e8c0a0) {
  %20 = "tensor.cast"(%19) : (tensor<256x128xf32>) -> tensor<?x?xf32>


  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TensorCastExtractSlice : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0x1e943f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x2088590) {
  "flow.dispatch.tensor.store"(%20, %7, %arg0, %arg1, %0, %1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>} : (tensor<?x?xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
    ** Insert  : 'tensor.cast'(0x2e856d0)
    ** Insert  : 'flow.dispatch.tensor.store'(0x1e5ec00)
    ** Replace : 'flow.dispatch.tensor.store'(0x2088590)
    ** Erase   : 'flow.dispatch.tensor.store'(0x2088590)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f953c0) {
  %1 = "arith.constant"() {value = 128 : index} : () -> index

  ** Erase   : 'arith.constant'(0x1f953c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x20687c0) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

  ** Erase   : 'arith.constant'(0x20687c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e5ec00) {
  "flow.dispatch.tensor.store"(%19, %5, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorStoreShapeDims : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0x1e943f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x2e856d0) {
  %19 = "tensor.cast"(%18) : (tensor<?x?xf32>) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::FoldTensorCastConsumerOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithCastOp : 'tensor.cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ChainedTensorCast : 'tensor.cast -> ()' {
    ** Insert  : 'tensor.cast'(0x2e85c30)
    ** Replace : 'tensor.cast'(0x2e856d0)
    ** Erase   : 'tensor.cast'(0x2e856d0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x2e8c0a0) {
  %18 = "tensor.cast"(%17) : (tensor<256x128xf32>) -> tensor<?x?xf32>

  ** Erase   : 'tensor.cast'(0x2e8c0a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e5ec00) {
  "flow.dispatch.tensor.store"(%18, %5, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
    ** Insert  : 'flow.dispatch.tensor.store'(0x1e7bc10)
    ** Replace : 'flow.dispatch.tensor.store'(0x1e5ec00)
    ** Erase   : 'flow.dispatch.tensor.store'(0x1e5ec00)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%17, %5, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorStoreShapeDims : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0x1e943f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.cast'(0x2e85c30) {
  %18 = "tensor.cast"(%17) : (tensor<256x128xf32>) -> tensor<256x128xf32>

  ** Erase   : 'tensor.cast'(0x2e85c30)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0x1e943f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %0 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %1 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %2 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %3 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %4 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %5 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %6 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %7 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %8 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %9 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %10 = "affine.apply"(%8) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %11 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %12 = "affine.apply"(%6) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %13 = "affine.apply"(%7) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %14 = "flow.dispatch.tensor.load"(%3, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %15 = "flow.dispatch.tensor.load"(%4, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %16 = "flow.dispatch.tensor.load"(%5, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x208c4c0) {
  %18 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32


  * Pattern (anonymous namespace)::MulFOfNegF : 'arith.mulf -> (arith.mulf)' {
    ** Failure : There's no operation that defines operand 0 of castedOp0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %19 = "arith.addf"(%arg4, %18) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32


  * Pattern CanonicalizeContractAdd<mlir::arith::AddFOp> : 'arith.addf -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2e86300) {
  "linalg.yield"(%19) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%17, %5, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorStoreShapeDims : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
module {
  func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
    %c1024 = arith.constant 1024 : index
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
    %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
    %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
    scf.for %arg0 = %3 to %c512 step %4 {
      %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
      %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
      scf.for %arg1 = %5 to %c1024 step %6 {
        %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
        %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
        %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
        %10 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%7, %8 : tensor<256x256xf32>, tensor<256x128xf32>) outs(%9 : tensor<256x128xf32>) -> tensor<256x128xf32>
        flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
      }
    }
    return
  }
}

// -----// IR Dump After CSE (cse) //----- //
module {
  func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
    %c1024 = arith.constant 1024 : index
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
    %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
    %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
    scf.for %arg0 = %3 to %c512 step %4 {
      %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
      %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
      scf.for %arg1 = %5 to %c1024 step %6 {
        %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
        %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
        %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
        %10 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%7, %8 : tensor<256x256xf32>, tensor<256x128xf32>) outs(%9 : tensor<256x128xf32>) -> tensor<256x128xf32>
        flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
      }
    }
    return
  }
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%17, %5, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2e86300) {
  "linalg.yield"(%19) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %19 = "arith.addf"(%arg4, %18) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x208c4c0) {
  %18 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %16 = "flow.dispatch.tensor.load"(%5, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %15 = "flow.dispatch.tensor.load"(%4, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %14 = "flow.dispatch.tensor.load"(%3, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %13 = "affine.apply"(%7) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %12 = "affine.apply"(%6) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %11 = "affine.apply"(%9) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %10 = "affine.apply"(%8) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %9 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %8 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %7 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %6 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %5 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %4 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %3 = "hal.interface.binding.subspan"(%2) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %2 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %1 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %0 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After TileAndDecomposeWinogradTransform (iree-linalg-ext-tile-and-decompose-winograd) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c512 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c1024 step %6 {
      %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%7, %8 : tensor<256x256xf32>, tensor<256x128xf32>) outs(%9 : tensor<256x128xf32>) -> tensor<256x128xf32>
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%17, %5, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x2e86300) {
  "linalg.yield"(%19) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %19 = "arith.addf"(%arg4, %18) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTileAndFusePattern : 'linalg.matmul -> ()' {
Yufan:: SCFTileAndFusePattern::matchAndRewrite 
    ** Insert  : 'arith.constant'(0x33964c0)
    ** Insert  : 'arith.constant'(0x3396460)
    ** Insert  : 'arith.constant'(0x3396400)
    ** Insert  : 'arith.constant'(0x33963a0)
    ** Insert  : 'arith.constant'(0x3396340)
    ** Insert  : 'scf.yield'(0x33962d0)
    ** Insert  : 'scf.for'(0x2085ea0)
    ** Insert  : 'arith.constant'(0x3396520)
    ** Insert  : 'arith.constant'(0x3396580)
    ** Insert  : 'scf.yield'(0x33965f0)
    ** Insert  : 'scf.for'(0x206b540)
    ** Insert  : 'arith.constant'(0x3396660)
    ** Insert  : 'arith.constant'(0x33966c0)
    ** Insert  : 'tensor.extract_slice'(0x33959c0)
    ** Insert  : 'tensor.extract_slice'(0x3395b40)
    ** Insert  : 'tensor.extract_slice'(0x3395cc0)
    ** Insert  : 'linalg.matmul'(0x2e88720)
    ** Insert  : 'scf.for'(0x1e33ad0)
    ** Insert  : 'scf.for'(0x339f3b0)
    ** Insert  : 'tensor.insert_slice'(0x1e5e440)
    ** Insert  : 'scf.yield'(0x33958f0)
    ** Insert  : 'scf.yield'(0x3395950)
    ** Erase   : 'scf.for'(0x2085ea0)
    ** Erase   : 'scf.for'(0x206b540)
 tiledOps linalg.matmul
Yufan:: ??  
    ** Modified: 'flow.dispatch.tensor.store'(0x1e7bc10)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%23, %5, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %33 = "tensor.insert_slice"(%32, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTileAndFusePattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %31 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %30 = "tensor.extract_slice"(%15, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %29 = "tensor.extract_slice"(%14, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33966c0) {
  %28 = "arith.constant"() {value = 256 : index} : () -> index

  ** Erase   : 'arith.constant'(0x33966c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %27 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3396660)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396580) {
  %25 = "arith.constant"() {value = 128 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3396580)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %0 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %25 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3396520)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396340) {
  %23 = "arith.constant"() {value = 256 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3396340)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %0 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %23 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x33963a0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396400) {
  %22 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3396400)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %21 = "arith.constant"() {value = 32 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3396460)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %0 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33964c0) {
  %21 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x33964c0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x208c4c0) {
  %23 = "arith.mulf"(%arg2, %arg3) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
** Erase   : 'linalg.matmul'(0x1e89a60)

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%22) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x3395890) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTileAndFusePattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2082490) {
  %28 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %24 = "tensor.extract_slice"(%19, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %23 = "tensor.extract_slice"(%18, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyTileAndFusePass (iree-linalg-strategy-tile-and-fuse-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  scf.for %arg0 = %3 to %c512 step %4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg1 = %5 to %c1024 step %6 {
      %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%22) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x3395890) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2082490) {
  %28 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %24 = "tensor.extract_slice"(%19, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %23 = "tensor.extract_slice"(%18, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x3395890) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2082490) {
  %28 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %24 = "tensor.extract_slice"(%19, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %22 = "tensor.extract_slice"(%18, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgFuse (linalg-fuse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %22 = "tensor.extract_slice"(%18, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %24 = "tensor.extract_slice"(%19, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2082490) {
  %28 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32


  * Pattern (anonymous namespace)::MulFOfNegF : 'arith.mulf -> (arith.mulf)' {
    ** Failure : There's no operation that defines operand 0 of castedOp0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32


  * Pattern CanonicalizeContractAdd<mlir::arith::AddFOp> : 'arith.addf -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x3395890) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertSliceIntoTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SwapExtractSliceOfTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorStoreShapeDims : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x3395890) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2082490) {
  %28 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %24 = "tensor.extract_slice"(%19, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %22 = "tensor.extract_slice"(%18, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyPadPass (iree-linalg-strategy-pad-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x3395890) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2082490) {
  %28 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %24 = "tensor.extract_slice"(%19, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %22 = "tensor.extract_slice"(%18, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x3395890) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2082490) {
  %28 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %24 = "tensor.extract_slice"(%19, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %22 = "tensor.extract_slice"(%18, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgFuse (linalg-fuse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x3395890) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
    ** Insert  : 'arith.constant'(0x3396340)
    ** Insert  : 'arith.constant'(0x3396580)
    ** Insert  : 'linalg.matmul'(0x1e89a60)
    ** Insert  : 'tensor.extract_slice'(0x3395fe0)
    ** Replace : 'linalg.matmul'(0x2e88720)
    ** Erase   : 'linalg.matmul'(0x2e88720)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %30 = "tensor.insert_slice"(%29, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395fe0) {
  %29 = "tensor.extract_slice"(%28) {operand_segment_sizes = array<i32: 1, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>) -> tensor<8x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x3395fe0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %29 = "tensor.insert_slice"(%28, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396580) {
  %27 = "arith.constant"() {value = 32 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3396580)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396340) {
  %26 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3396340)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %24 = "tensor.extract_slice"(%19, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %22 = "tensor.extract_slice"(%18, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33966b0) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x208c4c0) {
  %28 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %24 = "tensor.extract_slice"(%19, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %22 = "tensor.extract_slice"(%18, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyPadPass (iree-linalg-strategy-pad-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33966b0) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x208c4c0) {
  %28 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %24 = "tensor.extract_slice"(%19, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %22 = "tensor.extract_slice"(%18, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33966b0) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x208c4c0) {
  %28 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %24 = "tensor.extract_slice"(%19, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %22 = "tensor.extract_slice"(%18, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgFuse (linalg-fuse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33966b0) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x208c4c0) {
  %28 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %24 = "tensor.extract_slice"(%19, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %22 = "tensor.extract_slice"(%18, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyPadPass (iree-linalg-strategy-pad-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33966b0) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x208c4c0) {
  %28 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %24 = "tensor.extract_slice"(%19, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %22 = "tensor.extract_slice"(%18, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33966b0) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x208c4c0) {
  %28 = "arith.mulf"(%arg6, %arg7) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %24 = "tensor.extract_slice"(%19, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %22 = "tensor.extract_slice"(%18, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %18 = "flow.dispatch.tensor.load"(%7, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %16 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %13 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %11 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %5 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %4 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %3 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %2 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %1 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %0 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgFuse (linalg-fuse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice, %extracted_slice_0 : tensor<8x256xf32>, tensor<256x32xf32>) outs(%extracted_slice_1 : tensor<8x32xf32>) -> tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%21, %9, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%23) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33966b0) {
  "linalg.yield"(%29) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %29 = "arith.addf"(%arg8, %28) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.matmul -> ()' {
    ** Insert  : 'arith.constant'(0x339f180)
    ** Insert  : 'arith.constant'(0x3395960)
    ** Insert  : 'arith.constant'(0x3395900)
    ** Insert  : 'arith.constant'(0x33958a0)
    ** Insert  : 'arith.constant'(0x3396580)
    ** Insert  : 'arith.constant'(0x3396340)
    ** Insert  : 'arith.constant'(0x339a650)
    ** Insert  : 'arith.constant'(0x33a0e60)
    ** Insert  : 'arith.constant'(0x33a0ec0)
    ** Insert  : 'scf.yield'(0x33a0f10)
    ** Insert  : 'scf.for'(0x2085ea0)
    ** Insert  : 'tensor.extract_slice'(0x3399040)
    ** Insert  : 'tensor.extract_slice'(0x33a2540)
    ** Insert  : 'tensor.extract_slice'(0x3395fe0)
    ** Insert  : 'linalg.matmul'(0x2e88720)
    ** Insert  : 'scf.for'(0x339a790)
    ** Insert  : 'tensor.insert_slice'(0x3398040)
    ** Insert  : 'scf.yield'(0x33a0fd0)
    ** Erase   : 'scf.for'(0x2085ea0)
    ** Replace : 'linalg.matmul'(0x1e89a60)
    ** Erase   : 'linalg.matmul'(0x1e89a60)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %36 = "tensor.insert_slice"(%35, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x3398040) {
  %41 = "tensor.insert_slice"(%40, %arg7) {operand_segment_sizes = array<i32: 1, 1, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<8x32xf32>) -> tensor<8x32xf32>

  ** Erase   : 'tensor.insert_slice'(0x3398040)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%40) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395fe0) {
  %39 = "tensor.extract_slice"(%arg7) {operand_segment_sizes = array<i32: 1, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>) -> tensor<8x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x3395fe0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33a2540) {
  %38 = "tensor.extract_slice"(%24, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3399040) {
  %37 = "tensor.extract_slice"(%22, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33a0ec0) {
  %34 = "arith.constant"() {value = 256 : index} : () -> index

  ** Erase   : 'arith.constant'(0x33a0ec0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33a0e60) {
  %33 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x33a0e60)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %32 = "arith.constant"() {value = 32 : index} : () -> index

  ** Erase   : 'arith.constant'(0x339a650)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396340) {
  %31 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3396340)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396580) {
  %30 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3396580)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33958a0) {
  %29 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x33958a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3395900) {
  %28 = "arith.constant"() {value = 16 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3395900)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3395960) {
  %28 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3395960)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339f180) {
  %27 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x339f180)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %25 = "tensor.extract_slice"(%20, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%28) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %28 = "tensor.insert_slice"(%27, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%31) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33a0f70) {
  "linalg.yield"(%33) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %33 = "arith.addf"(%arg10, %32) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::SCFTilingPattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2082490) {
  %32 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33a2540) {
  %30 = "tensor.extract_slice"(%25, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3399040) {
  %29 = "tensor.extract_slice"(%23, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %25 = "tensor.extract_slice"(%20, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyTilePass (iree-linalg-strategy-tile-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%28) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %28 = "tensor.insert_slice"(%27, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%31) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33a0f70) {
  "linalg.yield"(%33) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %33 = "arith.addf"(%arg10, %32) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2082490) {
  %32 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33a2540) {
  %30 = "tensor.extract_slice"(%25, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3399040) {
  %29 = "tensor.extract_slice"(%23, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %25 = "tensor.extract_slice"(%20, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%28) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %28 = "tensor.insert_slice"(%27, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%31) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33a0f70) {
  "linalg.yield"(%33) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %33 = "arith.addf"(%arg10, %32) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2082490) {
  %32 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33a2540) {
  %30 = "tensor.extract_slice"(%25, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3399040) {
  %29 = "tensor.extract_slice"(%23, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %25 = "tensor.extract_slice"(%20, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgSingleTilingExpert (linalg-single-tiling-expert-driver) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %25 = "tensor.extract_slice"(%20, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3399040) {
  %29 = "tensor.extract_slice"(%23, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33a2540) {
  %30 = "tensor.extract_slice"(%25, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x2082490) {
  %32 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32


  * Pattern (anonymous namespace)::MulFOfNegF : 'arith.mulf -> (arith.mulf)' {
    ** Failure : There's no operation that defines operand 0 of castedOp0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %33 = "arith.addf"(%arg10, %32) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32


  * Pattern CanonicalizeContractAdd<mlir::arith::AddFOp> : 'arith.addf -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33a0f70) {
  "linalg.yield"(%33) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%31) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %28 = "tensor.insert_slice"(%27, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertSliceIntoTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SwapExtractSliceOfTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%28) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorStoreShapeDims : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%28) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %28 = "tensor.insert_slice"(%27, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%31) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33a0f70) {
  "linalg.yield"(%33) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x1fb2a10) {
  %33 = "arith.addf"(%arg10, %32) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x2e88720) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
    ** Insert  : 'arith.constant'(0x33a0e60)
    ** Insert  : 'arith.constant'(0x33a0ec0)
    ** Insert  : 'linalg.matmul'(0x1e89a60)
    ** Insert  : 'tensor.extract_slice'(0x2e8c010)
    ** Replace : 'linalg.matmul'(0x2e88720)
    ** Erase   : 'linalg.matmul'(0x2e88720)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%34) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x2e8c010) {
  %34 = "tensor.extract_slice"(%33) {operand_segment_sizes = array<i32: 1, 0, 0, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>) -> tensor<8x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x2e8c010)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%33) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33a0ec0) {
  %32 = "arith.constant"() {value = 32 : index} : () -> index

  ** Erase   : 'arith.constant'(0x33a0ec0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33a0e60) {
  %31 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x33a0e60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33a2540) {
  %30 = "tensor.extract_slice"(%25, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3399040) {
  %29 = "tensor.extract_slice"(%23, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %25 = "tensor.extract_slice"(%20, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%28) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %28 = "tensor.insert_slice"(%27, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%31) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33966b0) {
  "linalg.yield"(%33) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %33 = "arith.addf"(%arg10, %32) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgPaddingPattern : 'linalg.matmul -> ()' {
    ** Failure :  does not have any filter from list: 
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x208c4c0) {
  %32 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33a2540) {
  %30 = "tensor.extract_slice"(%25, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3399040) {
  %29 = "tensor.extract_slice"(%23, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %25 = "tensor.extract_slice"(%20, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyPadPass (iree-linalg-strategy-pad-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%28) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %28 = "tensor.insert_slice"(%27, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%31) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33966b0) {
  "linalg.yield"(%33) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %33 = "arith.addf"(%arg10, %32) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x208c4c0) {
  %32 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33a2540) {
  %30 = "tensor.extract_slice"(%25, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3399040) {
  %29 = "tensor.extract_slice"(%23, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %25 = "tensor.extract_slice"(%20, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {__internal_linalg_transform__ = "1", lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%28) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %28 = "tensor.insert_slice"(%27, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%31) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33966b0) {
  "linalg.yield"(%33) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %33 = "arith.addf"(%arg10, %32) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'linalg.matmul -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x208c4c0) {
  %32 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33a2540) {
  %30 = "tensor.extract_slice"(%25, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3399040) {
  %29 = "tensor.extract_slice"(%23, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %25 = "tensor.extract_slice"(%20, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgFuse (linalg-fuse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
          %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
            %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
            %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
            %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
            scf.yield %13 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%28) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %28 = "tensor.insert_slice"(%27, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%31) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33966b0) {
  "linalg.yield"(%33) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %33 = "arith.addf"(%arg10, %32) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x208c4c0) {
  %32 = "arith.mulf"(%arg8, %arg9) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33a2540) {
  %30 = "tensor.extract_slice"(%25, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3399040) {
  %29 = "tensor.extract_slice"(%23, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %26 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %25 = "tensor.extract_slice"(%20, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %23 = "tensor.extract_slice"(%19, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %19 = "flow.dispatch.tensor.load"(%8, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %17 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %15 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %14 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %12 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %6 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %5 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %4 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %3 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %2 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %1 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0x1e943f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %0 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After ResolveShapedTypeResultDims (resolve-shaped-type-result-dims) //----- //
module {
  func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
    %c16 = arith.constant 16 : index
    %c8 = arith.constant 8 : index
    %c32 = arith.constant 32 : index
    %c256 = arith.constant 256 : index
    %c128 = arith.constant 128 : index
    %c1024 = arith.constant 1024 : index
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
    %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
    %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg0 = %3 to %c512 step %4 {
      %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
      scf.for %arg1 = %5 to %c1024 step %6 {
        %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
        %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
        %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
          %extracted_slice = tensor.extract_slice %7[%arg2, 0] [8, 256] [1, 1] : tensor<256x256xf32> to tensor<8x256xf32>
          %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
            %extracted_slice_0 = tensor.extract_slice %8[0, %arg4] [256, 32] [1, 1] : tensor<256x128xf32> to tensor<256x32xf32>
            %extracted_slice_1 = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
            %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice_1) -> (tensor<8x32xf32>) {
              %extracted_slice_2 = tensor.extract_slice %extracted_slice[0, %arg6] [8, 16] [1, 1] : tensor<8x256xf32> to tensor<8x16xf32>
              %extracted_slice_3 = tensor.extract_slice %extracted_slice_0[%arg6, 0] [16, 32] [1, 1] : tensor<256x32xf32> to tensor<16x32xf32>
              %13 = linalg.matmul {lowering_config = #iree_codegen.lowering_config<tile_sizes = [[256, 128, 0], [8, 32, 0], [0, 0, 16]]>} ins(%extracted_slice_2, %extracted_slice_3 : tensor<8x16xf32>, tensor<16x32xf32>) outs(%arg7 : tensor<8x32xf32>) -> tensor<8x32xf32>
              scf.yield %13 : tensor<8x32xf32>
            }
            %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
            scf.yield %inserted_slice : tensor<256x128xf32>
          }
          scf.yield %11 : tensor<256x128xf32>
        }
        flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
      }
    }
    return
  }
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%22, %10, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%28) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %28 = "tensor.insert_slice"(%27, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::FoldInsertSliceIntoTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SwapExtractSliceOfTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%31) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x33966b0) {
  "linalg.yield"(%33) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x20886c0) {
  %33 = "arith.addf"(%arg10, %32) {fastmath = #arith.fastmath<none>} : (f32, f32) -> f32


  * Pattern (anonymous namespace)::ReorderElementwiseOpsOnTranspose : 'arith.addf -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x1e89a60) {

  * Pattern mlir::iree_compiler::IREE::LinalgExt::LinalgVectorizationPattern : 'linalg.matmul -> ()' {
    ** Failure : failed to match conv::Nwc 3-par 2-red
    ** Failure : failed to match conv::Ncw 3-par 2-red
    ** Failure : failed to match pooling 3-par 1-red
    ** Failure : failed to match pooling 3-par 1-red
    ** Failure : failed to match depthwise::Nwc conv 3-par 1-red
    ** Insert  : 'arith.constant'(0x34c2c70)
    ** Insert  : 'arith.constant'(0x34c2c10)
    ** Insert  : 'vector.transfer_read'(0x3396d40)
    ** Insert  : 'arith.constant'(0x34bf230)
    ** Insert  : 'vector.transfer_read'(0x1e39900)
    ** Insert  : 'arith.constant'(0x34bf290)
    ** Insert  : 'vector.transfer_read'(0x1e2c680)
    ** Insert  : 'arith.mulf'(0x3394240)
    ** Insert  : 'vector.multi_reduction'(0x3398040)
    ** Insert  : 'arith.constant'(0x34c6de0)
    ** Insert  : 'vector.transfer_write'(0x1e2c530)
    ** Replace : 'linalg.matmul'(0x1e89a60)
    ** Erase   : 'linalg.matmul'(0x1e89a60)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%41) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %41 = "vector.transfer_write"(%39, %arg7, %40, %40) {operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
  ** Failure : source not a view or alloc
} -> failure : pattern failed to match

* Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
} -> failure : pattern failed to match

* Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
} -> failure : pattern failed to match

* Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %40 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x34c6de0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %40 = "vector.transfer_write"(%39, %arg7, %7, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.multi_reduction'(0x3398040) {
  %39 = "vector.multi_reduction"(%38, %37) {kind = #vector.kind<add>, reduction_dims = [2]} : (vector<8x32x16xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::MultiReduceToContract : 'vector.multi_reduction -> ()' {
    ** Insert  : 'vector.contract'(0x34c70b0)
    ** Replace : 'vector.multi_reduction'(0x3398040)
    ** Erase   : 'vector.multi_reduction'(0x3398040)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %40 = "vector.transfer_write"(%39, %arg7, %7, %7) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34c70b0) {
  %39 = "vector.contract"(%33, %35, %37) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<8x32x16xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x3394240) {
  %38 = "arith.mulf"(%33, %35) {fastmath = #arith.fastmath<none>} : (vector<8x32x16xf32>, vector<8x32x16xf32>) -> vector<8x32x16xf32>

  ** Erase   : 'arith.mulf'(0x3394240)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %37 = "vector.transfer_read"(%arg7, %31, %31, %36) {operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
  ** Failure : source not a view or alloc
} -> failure : pattern failed to match

* Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
} -> failure : pattern failed to match

* Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
} -> failure : pattern failed to match

* Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
} -> failure : pattern failed to match

* Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
} -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34bf290) {
  %36 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

  ** Erase   : 'arith.constant'(0x34bf290)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %37 = "vector.transfer_read"(%arg7, %32, %32, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %36 = "vector.transfer_read"(%31, %32, %32, %35) {operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (0, d1, d0)>} : (tensor<16x32xf32>, index, index, f32) -> vector<8x32x16xf32>

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
  ** Failure : source not a view or alloc
} -> failure : pattern failed to match

* Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  ** Insert  : 'vector.transfer_read'(0x1e2c3e0)
  ** Insert  : 'vector.transpose'(0x3395fe0)
  ** Replace : 'vector.transfer_read'(0x1e39900)
  ** Erase   : 'vector.transfer_read'(0x1e39900)
} -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34c70b0) {
  %39 = "vector.contract"(%34, %37, %38) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<8x32x16xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
    ** Insert  : 'vector.contract'(0x34d0400)
    ** Replace : 'vector.contract'(0x34c70b0)
    ** Erase   : 'vector.contract'(0x34c70b0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %40 = "vector.transfer_write"(%39, %arg7, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d0400) {
  %39 = "vector.contract"(%34, %36, %38) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<8x16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x3395fe0) {
  %37 = "vector.transpose"(%36) {transp = [0, 2, 1]} : (vector<8x16x32xf32>) -> vector<8x32x16xf32>

  ** Erase   : 'vector.transpose'(0x3395fe0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c3e0) {
  %36 = "vector.transfer_read"(%31, %32, %32, %35) {in_bounds = [true, true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (0, d0, d1)>} : (tensor<16x32xf32>, index, index, f32) -> vector<8x16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.transfer_read'(0x1e39900)
    ** Insert  : 'vector.broadcast'(0x3395fe0)
    ** Replace : 'vector.transfer_read'(0x1e2c3e0)
    ** Erase   : 'vector.transfer_read'(0x1e2c3e0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d0400) {
  %39 = "vector.contract"(%34, %37, %38) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<8x16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
    ** Insert  : 'vector.contract'(0x34d04d0)
    ** Replace : 'vector.contract'(0x34d0400)
    ** Erase   : 'vector.contract'(0x34d0400)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %40 = "vector.transfer_write"(%39, %arg7, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d04d0) {
  %39 = "vector.contract"(%34, %36, %38) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.broadcast'(0x3395fe0) {
  %37 = "vector.broadcast"(%36) : (vector<16x32xf32>) -> vector<8x16x32xf32>

  ** Erase   : 'vector.broadcast'(0x3395fe0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %36 = "vector.transfer_read"(%31, %32, %32, %35) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<16x32xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
    ** Insert  : 'arith.addi'(0x3394240)
    ** Insert  : 'arith.constant'(0x34bf290)
    ** Insert  : 'arith.addi'(0x3398040)
    ** Insert  : 'vector.transfer_read'(0x1e2c3e0)
    ** Replace : 'vector.transfer_read'(0x1e39900)
    ** Erase   : 'vector.transfer_read'(0x1e39900)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d04d0) {
  %41 = "vector.contract"(%34, %39, %40) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c3e0) {
  %39 = "vector.transfer_read"(%26, %36, %38, %35) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x32xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
    ** Insert  : 'arith.constant'(0x33966c0)
    ** Insert  : 'arith.addi'(0x34d05a0)
    ** Insert  : 'arith.addi'(0x34d0650)
    ** Insert  : 'vector.transfer_read'(0x1e39900)
    ** Replace : 'vector.transfer_read'(0x1e2c3e0)
    ** Erase   : 'vector.transfer_read'(0x1e2c3e0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d04d0) {
  %44 = "vector.contract"(%34, %42, %43) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %42 = "vector.transfer_read"(%21, %40, %41, %35) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x34d0650) {
  %41 = "arith.addi"(%38, %arg4) : (index, index) -> index


  * Pattern (anonymous namespace)::ReorderElementwiseOpsOnTranspose : 'arith.addi -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x34d05a0) {
  %40 = "arith.addi"(%36, %39) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x34d05a0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %41 = "vector.transfer_read"(%21, %36, %40, %35) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33966c0) {
  %39 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x33966c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x3398040) {
  %38 = "arith.addi"(%32, %37) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x3398040)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x34d0650) {
  %38 = "arith.addi"(%32, %arg4) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x34d0650)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %38 = "vector.transfer_read"(%21, %36, %arg4, %35) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34bf290) {
  %37 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x34bf290)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x3394240) {
  %36 = "arith.addi"(%32, %arg6) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x3394240)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %36 = "vector.transfer_read"(%21, %arg6, %arg4, %35) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34bf230) {
  %35 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

  ** Erase   : 'arith.constant'(0x34bf230)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %35 = "vector.transfer_read"(%21, %arg6, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %34 = "vector.transfer_read"(%30, %32, %32, %33) {operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, 0, d1)>} : (tensor<8x16xf32>, index, index, f32) -> vector<8x32x16xf32>

} -> success : operation was folded
//===-------------------------------------------===//

* Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
  ** Failure : source not a view or alloc
} -> failure : pattern failed to match

* Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  ** Insert  : 'vector.transfer_read'(0x1e2c3e0)
  ** Insert  : 'vector.transpose'(0x3395fe0)
  ** Replace : 'vector.transfer_read'(0x3396d40)
  ** Erase   : 'vector.transfer_read'(0x3396d40)
} -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d04d0) {
  %38 = "vector.contract"(%35, %36, %37) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x32x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
    ** Insert  : 'vector.contract'(0x34d0700)
    ** Replace : 'vector.contract'(0x34d04d0)
    ** Erase   : 'vector.contract'(0x34d04d0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %39 = "vector.transfer_write"(%38, %arg7, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d0700) {
  %38 = "vector.contract"(%34, %36, %37) {indexing_maps = [affine_map<(d0, d1, d2) -> (d1, d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<32x8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x3395fe0) {
  %35 = "vector.transpose"(%34) {transp = [1, 0, 2]} : (vector<32x8x16xf32>) -> vector<8x32x16xf32>

  ** Erase   : 'vector.transpose'(0x3395fe0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c3e0) {
  %34 = "vector.transfer_read"(%30, %32, %32, %33) {in_bounds = [true, true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (0, d0, d1)>} : (tensor<8x16xf32>, index, index, f32) -> vector<32x8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.transfer_read'(0x3396d40)
    ** Insert  : 'vector.broadcast'(0x3395fe0)
    ** Replace : 'vector.transfer_read'(0x1e2c3e0)
    ** Erase   : 'vector.transfer_read'(0x1e2c3e0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d0700) {
  %38 = "vector.contract"(%35, %36, %37) {indexing_maps = [affine_map<(d0, d1, d2) -> (d1, d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<32x8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
    ** Insert  : 'vector.contract'(0x34d1c20)
    ** Replace : 'vector.contract'(0x34d0700)
    ** Erase   : 'vector.contract'(0x34d0700)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %39 = "vector.transfer_write"(%38, %arg7, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %38 = "vector.contract"(%34, %36, %37) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.broadcast'(0x3395fe0) {
  %35 = "vector.broadcast"(%34) : (vector<8x16xf32>) -> vector<32x8x16xf32>

  ** Erase   : 'vector.broadcast'(0x3395fe0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %34 = "vector.transfer_read"(%30, %32, %32, %33) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x16xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
    ** Insert  : 'arith.constant'(0x34bf230)
    ** Insert  : 'arith.addi'(0x3394240)
    ** Insert  : 'arith.addi'(0x34d0650)
    ** Insert  : 'vector.transfer_read'(0x1e2c3e0)
    ** Replace : 'vector.transfer_read'(0x3396d40)
    ** Erase   : 'vector.transfer_read'(0x3396d40)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %40 = "vector.contract"(%37, %38, %39) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c3e0) {
  %37 = "vector.transfer_read"(%24, %35, %36, %33) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
    ** Insert  : 'arith.addi'(0x3398040)
    ** Insert  : 'arith.constant'(0x34bf290)
    ** Insert  : 'arith.addi'(0x34d05a0)
    ** Insert  : 'vector.transfer_read'(0x3396d40)
    ** Replace : 'vector.transfer_read'(0x1e2c3e0)
    ** Erase   : 'vector.transfer_read'(0x1e2c3e0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %43 = "vector.contract"(%40, %41, %42) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %40 = "vector.transfer_read"(%20, %37, %39, %33) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x34d05a0) {
  %39 = "arith.addi"(%36, %38) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x34d05a0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %39 = "vector.transfer_read"(%20, %37, %36, %33) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34bf290) {
  %38 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x34bf290)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x3398040) {
  %37 = "arith.addi"(%35, %arg2) : (index, index) -> index


  * Pattern (anonymous namespace)::ReorderElementwiseOpsOnTranspose : 'arith.addi -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x34d0650) {
  %36 = "arith.addi"(%32, %arg6) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x34d0650)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %37 = "vector.transfer_read"(%20, %36, %arg6, %33) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x3394240) {
  %35 = "arith.addi"(%32, %34) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x3394240)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x3398040) {
  %35 = "arith.addi"(%32, %arg2) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x3398040)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %35 = "vector.transfer_read"(%20, %arg2, %arg6, %33) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34bf230) {
  %34 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x34bf230)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c2c10) {
  %33 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

  ** Erase   : 'arith.constant'(0x34c2c10)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %33 = "vector.transfer_read"(%20, %arg2, %arg6, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c2c70) {
  %32 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x34c2c70)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %34 = "vector.transfer_read"(%arg7, %8, %8, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33a2540) {
  %31 = "tensor.extract_slice"(%26, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 16, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x32xf32>, index) -> tensor<16x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x33a2540)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3399040) {
  %30 = "tensor.extract_slice"(%24, %arg6) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 8, 16>, static_strides = array<i64: 1, 1>} : (tensor<8x256xf32>, index) -> tensor<8x16xf32>

  ** Erase   : 'tensor.extract_slice'(0x3399040)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %27 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395b40) {
  %26 = "tensor.extract_slice"(%21, %arg4) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index) -> tensor<256x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x3395b40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x33959c0) {
  %24 = "tensor.extract_slice"(%20, %arg2) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 8, 256>, static_strides = array<i64: 1, 1>} : (tensor<256x256xf32>, index) -> tensor<8x256xf32>

  ** Erase   : 'tensor.extract_slice'(0x33959c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %22 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::FoldInsertSliceIntoTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SwapExtractSliceOfTransferWrite : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%32) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %32 = "vector.transfer_write"(%31, %arg7, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTWForwardingPattern : 'vector.transfer_write -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %31 = "vector.contract"(%28, %29, %30) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::CombineContractBroadcast : 'vector.contract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::CombineContractABTranspose : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %30 = "vector.transfer_read"(%arg7, %8, %8, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %29 = "vector.transfer_read"(%21, %arg6, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %28 = "vector.transfer_read"(%20, %arg2, %arg6, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::linalg::LinalgCopyVTRForwardingPattern : 'vector.transfer_read -> ()' {
    ** Failure : source not a view or alloc
  } -> failure : pattern failed to match

  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %22 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%32) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %32 = "vector.transfer_write"(%31, %arg7, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %31 = "vector.contract"(%28, %29, %30) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %30 = "vector.transfer_read"(%arg7, %8, %8, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %29 = "vector.transfer_read"(%21, %arg6, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %28 = "vector.transfer_read"(%20, %arg2, %arg6, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %22 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyVectorizePass (iree-linalg-strategy-vectorize-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %extracted_slice) -> (tensor<8x32xf32>) {
            %13 = vector.transfer_read %7[%arg2, %arg6], %cst {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %14 = vector.transfer_read %8[%arg6, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %15 = vector.transfer_read %arg7[%c0, %c0], %cst {in_bounds = [true, true]} : tensor<8x32xf32>, vector<8x32xf32>
            %16 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %13, %14, %15 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            %17 = vector.transfer_write %16, %arg7[%c0, %c0] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<8x32xf32>
            scf.yield %17 : tensor<8x32xf32>
          }
          %inserted_slice = tensor.insert_slice %12 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %27 = "tensor.insert_slice"(%26, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%32) : (tensor<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %32 = "vector.transfer_write"(%31, %arg7, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %31 = "vector.contract"(%28, %29, %30) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %30 = "vector.transfer_read"(%arg7, %8, %8, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %29 = "vector.transfer_read"(%21, %arg6, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %28 = "vector.transfer_read"(%20, %arg2, %arg6, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %22 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%29) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %29 = "tensor.insert_slice"(%28, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %28 = "vector.transfer_write"(%27#1, %27#0, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33a0f10) {
  "scf.yield"(%arg7, %32) : (tensor<8x32xf32>, vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %32 = "vector.contract"(%30, %31, %arg8) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %31 = "vector.transfer_read"(%21, %arg6, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2690) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
    ** Insert  : 'scf.for'(0x339a790)
    ** Insert  : 'scf.yield'(0x2e86680)
    ** Erase   : 'scf.yield'(0x33a0f10)
    ** Replace : 'scf.for'(0x34c2690)
    ** Erase   : 'scf.for'(0x34c2690)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %28 = "vector.transfer_write"(%27, %25, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%32) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %30 = "vector.transfer_read"(%20, %arg2, %arg6, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %26 = "vector.transfer_read"(%25, %8, %8, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %22 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%29) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %29 = "tensor.insert_slice"(%28, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %28 = "vector.transfer_write"(%27, %25, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%32) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %32 = "vector.contract"(%30, %31, %arg7) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %31 = "vector.transfer_read"(%21, %arg6, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %30 = "vector.transfer_read"(%20, %arg2, %arg6, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %26 = "vector.transfer_read"(%25, %8, %8, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %22 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = vector.transfer_read %extracted_slice[%c0, %c0], %cst {in_bounds = [true, true]} : tensor<8x32xf32>, vector<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %8[%arg6, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %14 = vector.transfer_write %13, %extracted_slice[%c0, %c0] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = vector.transfer_read %extracted_slice[%c0, %c0], %cst {in_bounds = [true, true]} : tensor<8x32xf32>, vector<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %8[%arg6, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %14 = vector.transfer_write %13, %extracted_slice[%c0, %c0] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = vector.transfer_read %extracted_slice[%c0, %c0], %cst {in_bounds = [true, true]} : tensor<8x32xf32>, vector<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %8[%arg6, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %14 = vector.transfer_write %13, %extracted_slice[%c0, %c0] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%29) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %29 = "tensor.insert_slice"(%28, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern (anonymous namespace)::InsertSliceOpConstantArgumentFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpCastFolder<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSliceOpSourceCastInserter<mlir::tensor::InsertSliceOp> : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertPadIntoFill : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %28 = "vector.transfer_write"(%27, %25, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%32) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %32 = "vector.contract"(%30, %31, %arg7) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %31 = "vector.transfer_read"(%21, %arg6, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %30 = "vector.transfer_read"(%20, %arg2, %arg6, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %26 = "vector.transfer_read"(%25, %8, %8, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldEmptyTensorWithExtractSliceOp : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %22 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = vector.transfer_read %extracted_slice[%c0, %c0], %cst {in_bounds = [true, true]} : tensor<8x32xf32>, vector<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %8[%arg6, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %14 = vector.transfer_write %13, %extracted_slice[%c0, %c0] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = vector.transfer_read %extracted_slice[%c0, %c0], %cst {in_bounds = [true, true]} : tensor<8x32xf32>, vector<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %8[%arg6, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %14 = vector.transfer_write %13, %extracted_slice[%c0, %c0] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After LinalgSingleTilingExpert (linalg-single-tiling-expert-driver) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %extracted_slice = tensor.extract_slice %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<256x128xf32> to tensor<8x32xf32>
          %12 = vector.transfer_read %extracted_slice[%c0, %c0], %cst {in_bounds = [true, true]} : tensor<8x32xf32>, vector<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %8[%arg6, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %14 = vector.transfer_write %13, %extracted_slice[%c0, %c0] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<8x32xf32>
          %inserted_slice = tensor.insert_slice %14 into %arg5[%arg2, %arg4] [8, 32] [1, 1] : tensor<8x32xf32> into tensor<256x128xf32>
          scf.yield %inserted_slice : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %22 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::tensor::ExtractSliceOp, SliceReturnTypeCanonicalizer, SliceCanonicalizer> : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractSliceOpCastFolder : 'tensor.extract_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %26 = "vector.transfer_read"(%25, %8, %8, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<8x32xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
    ** Insert  : 'arith.addi'(0x3395b40)
    ** Insert  : 'arith.addi'(0x3399040)
    ** Insert  : 'vector.transfer_read'(0x34c53f0)
    ** Replace : 'vector.transfer_read'(0x1e2c680)
    ** Erase   : 'vector.transfer_read'(0x1e2c680)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34c53f0) {
  %28 = "vector.transfer_read"(%arg5, %26, %27, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x3399040) {
  %27 = "arith.addi"(%8, %arg4) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x3399040)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34c53f0) {
  %27 = "vector.transfer_read"(%arg5, %26, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addi'(0x3395b40) {
  %26 = "arith.addi"(%8, %arg2) : (index, index) -> index

  ** Erase   : 'arith.addi'(0x3395b40)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34c53f0) {
  %26 = "vector.transfer_read"(%arg5, %arg2, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %30 = "vector.transfer_read"(%20, %arg2, %arg6, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %31 = "vector.transfer_read"(%21, %arg6, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %32 = "vector.contract"(%30, %31, %arg7) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%32) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %28 = "vector.transfer_write"(%27, %25, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.insert_slice'(0x1e5e440) {
  %29 = "tensor.insert_slice"(%28, %arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern FoldTensorCastProducerOp : 'tensor.insert_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertSliceIntoTransferWrite : 'tensor.insert_slice -> ()' {
    ** Insert  : 'vector.transfer_write'(0x1e2c680)
    ** Replace : 'tensor.insert_slice'(0x1e5e440)
    ** Erase   : 'tensor.insert_slice'(0x1e5e440)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c530) {
  %28 = "vector.transfer_write"(%27, %25, %8, %8) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<8x32xf32>, index, index) -> tensor<8x32xf32>

  ** Erase   : 'vector.transfer_write'(0x1e2c530)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'tensor.extract_slice'(0x3395cc0) {
  %25 = "tensor.extract_slice"(%arg5, %arg2, %arg4) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 8, 32>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, index, index) -> tensor<8x32xf32>

  ** Erase   : 'tensor.extract_slice'(0x3395cc0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c680) {
  %27 = "vector.transfer_write"(%26, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorStoreShapeDims : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %22 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorLoadShapeDims : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ConvertDispatchInputLoadOfTensorToSubTensor : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorLoadOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34c53f0) {
  %25 = "vector.transfer_read"(%arg5, %arg2, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %28 = "vector.transfer_read"(%20, %arg2, %arg6, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %29 = "vector.transfer_read"(%21, %arg6, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %30 = "vector.contract"(%28, %29, %arg7) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%30) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c680) {
  %27 = "vector.transfer_write"(%26, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()


  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::DispatchTensorStoreOpWithOffsetSizesAndStridesConstantArgumentFolder : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::FoldCastOpIntoDispatchStoreOp : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::iree_compiler::IREE::Flow::(anonymous namespace)::ReuseDispatchTensorStoreShapeDims : 'flow.dispatch.tensor.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %12 = vector.transfer_read %arg5[%arg2, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %8[%arg6, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %14 = vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
          scf.yield %14 : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
      %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
      %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
        %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
          %12 = vector.transfer_read %arg5[%arg2, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<8x32xf32>
          %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (vector<8x32xf32>) {
            %15 = vector.transfer_read %7[%arg2, %arg6], %cst {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
            %16 = vector.transfer_read %8[%arg6, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
            %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %17 : vector<8x32xf32>
          }
          %14 = vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
          scf.yield %14 : tensor<256x128xf32>
        }
        scf.yield %11 : tensor<256x128xf32>
      }
      flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    }
  }
  return
}

// -----// IR Dump After EliminateEmptyTensors (iree-eliminate-empty-tensors) //----- //
module {
  func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
    %cst = arith.constant 0.000000e+00 : f32
    %c16 = arith.constant 16 : index
    %c8 = arith.constant 8 : index
    %c32 = arith.constant 32 : index
    %c256 = arith.constant 256 : index
    %c128 = arith.constant 128 : index
    %c1024 = arith.constant 1024 : index
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
    %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
    %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg0 = %3 to %c512 step %4 {
      %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
      scf.for %arg1 = %5 to %c1024 step %6 {
        %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
        %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
        %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
          %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
            %12 = vector.transfer_read %arg5[%arg2, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<8x32xf32>
            %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (vector<8x32xf32>) {
              %15 = vector.transfer_read %7[%arg2, %arg6], %cst {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
              %16 = vector.transfer_read %8[%arg6, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
              %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
              scf.yield %17 : vector<8x32xf32>
            }
            %14 = vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
            scf.yield %14 : tensor<256x128xf32>
          }
          scf.yield %11 : tensor<256x128xf32>
        }
        flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
      }
    }
    return
  }
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.store'(0x1e7bc10) {
  "flow.dispatch.tensor.store"(%23, %11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (tensor<256x128xf32>, !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33962d0) {
  "scf.yield"(%24) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x33965f0) {
  "scf.yield"(%27) : (tensor<256x128xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e2c680) {
  %27 = "vector.transfer_write"(%26, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, tensor<256x128xf32>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%30) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %30 = "vector.contract"(%28, %29, %arg7) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %29 = "vector.transfer_read"(%21, %arg6, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %28 = "vector.transfer_read"(%20, %arg2, %arg6, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x256xf32>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x1e33ad0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34c53f0) {
  %25 = "vector.transfer_read"(%arg5, %arg2, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (tensor<256x128xf32>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x208d650) {
  %22 = "flow.dispatch.tensor.load"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 0, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>, index, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a0a0) {
  %21 = "flow.dispatch.tensor.load"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<256x1024xf32>>, index) -> tensor<256x128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'flow.dispatch.tensor.load'(0x1e5a150) {
  %20 = "flow.dispatch.tensor.load"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 0, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (!flow.dispatch.tensor<readonly:tensor<512x256xf32>>, index) -> tensor<256x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0x1e943f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After EmptyTensorToAllocTensor (empty-tensor-to-alloc-tensor) //----- //
module {
  func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
    %cst = arith.constant 0.000000e+00 : f32
    %c16 = arith.constant 16 : index
    %c8 = arith.constant 8 : index
    %c32 = arith.constant 32 : index
    %c256 = arith.constant 256 : index
    %c128 = arith.constant 128 : index
    %c1024 = arith.constant 1024 : index
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
    %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
    %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
    %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
    %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg0 = %3 to %c512 step %4 {
      %7 = flow.dispatch.tensor.load %0, offsets = [%arg0, 0], sizes = [256, 256], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<512x256xf32>> -> tensor<256x256xf32>
      scf.for %arg1 = %5 to %c1024 step %6 {
        %8 = flow.dispatch.tensor.load %1, offsets = [0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>> -> tensor<256x128xf32>
        %9 = flow.dispatch.tensor.load %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>> -> tensor<256x128xf32>
        %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %9) -> (tensor<256x128xf32>) {
          %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (tensor<256x128xf32>) {
            %12 = vector.transfer_read %arg5[%arg2, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<8x32xf32>
            %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (vector<8x32xf32>) {
              %15 = vector.transfer_read %7[%arg2, %arg6], %cst {in_bounds = [true, true]} : tensor<256x256xf32>, vector<8x16xf32>
              %16 = vector.transfer_read %8[%arg6, %arg4], %cst {in_bounds = [true, true]} : tensor<256x128xf32>, vector<16x32xf32>
              %17 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %15, %16, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
              scf.yield %17 : vector<8x32xf32>
            }
            %14 = vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, tensor<256x128xf32>
            scf.yield %14 : tensor<256x128xf32>
          }
          scf.yield %11 : tensor<256x128xf32>
        }
        flow.dispatch.tensor.store %10, %2, offsets = [%arg0, %arg1], sizes = [256, 128], strides = [1, 1] : tensor<256x128xf32> -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
      }
    }
    return
  }
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0x1e5a090) {

  * Pattern (anonymous namespace)::DeduplicateAndRemoveDeadOperandsAndResults : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::RemoveUnusedCycleInGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x34c52c0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x208d650) {
  %27 = "memref.subview"(%13, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x206bae0) {
  "scf.yield"(%28) : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x206e830) {
  "scf.yield"(%arg5) : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x2e88710) {
  "vector.transfer_write"(%30, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%33) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %33 = "vector.contract"(%31, %32, %arg7) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %32 = "vector.transfer_read"(%24, %arg6, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34c53f0) {
  %31 = "vector.transfer_read"(%23, %arg2, %arg6, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34d3110) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c530) {
  %29 = "vector.transfer_read"(%arg5, %arg2, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x34c3240) {
  %25 = "memref.subview"(%13, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a150) {
  %24 = "memref.subview"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3395b40) {
  %23 = "memref.subview"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %22 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %21 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %19 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %18 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %17 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %16 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %15 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %14 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1e5a1f0) {
  "memref.assume_alignment"(%13) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bf80) {
  %13 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x20688b0) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3395fe0) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1ea9130) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bac20) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0x1e943f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After IREEComprehensiveBufferize (iree-codegen-iree-comprehensive-bufferize) //----- //
module {
  func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
    %cst = arith.constant 0.000000e+00 : f32
    %c16 = arith.constant 16 : index
    %c8 = arith.constant 8 : index
    %c32 = arith.constant 32 : index
    %c256 = arith.constant 256 : index
    %c128 = arith.constant 128 : index
    %c1024 = arith.constant 1024 : index
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
    memref.assume_alignment %0, 64 : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
    %1 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
    %2 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
    memref.assume_alignment %2, 64 : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
    %3 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
    %4 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
    memref.assume_alignment %4, 64 : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
    %5 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %6 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg0 = %6 to %c512 step %7 {
      %subview = memref.subview %0[%arg0, 0] [256, 256] [1, 1] : memref<512x256xf32, #hal.descriptor_type<storage_buffer>> to memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      scf.for %arg1 = %8 to %c1024 step %9 {
        %subview_0 = memref.subview %2[0, %arg1] [256, 128] [1, 1] : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        %subview_1 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %subview_1) -> (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
          %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
            %12 = vector.transfer_read %arg5[%arg2, %arg4], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x32xf32>
            %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (vector<8x32xf32>) {
              %14 = vector.transfer_read %subview[%arg2, %arg6], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x16xf32>
              %15 = vector.transfer_read %subview_0[%arg6, %arg4], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<16x32xf32>
              %16 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %14, %15, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
              scf.yield %16 : vector<8x32xf32>
            }
            vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
            scf.yield %arg5 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
          }
          scf.yield %11 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        }
        %subview_2 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%10 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) outs(%subview_2 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
        ^bb0(%in: f32, %out: f32):
          linalg.yield %in : f32
        }
      }
    }
    return
  }
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0x1e5a090) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x34c52c0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x208d650) {
  %27 = "memref.subview"(%13, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x206bae0) {
  "scf.yield"(%28) : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x206e830) {
  "scf.yield"(%arg5) : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x2e88710) {
  "vector.transfer_write"(%30, %arg5, %arg2, %arg4) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%33) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %33 = "vector.contract"(%31, %32, %arg7) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %32 = "vector.transfer_read"(%24, %arg6, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34c53f0) {
  %31 = "vector.transfer_read"(%23, %arg2, %arg6, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34d3110) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c530) {
  %29 = "vector.transfer_read"(%arg5, %arg2, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x34c3240) {
  %25 = "memref.subview"(%13, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a150) {
  %24 = "memref.subview"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3395b40) {
  %23 = "memref.subview"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %22 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %21 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %19 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %18 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %17 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %16 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %15 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %14 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1e5a1f0) {
  "memref.assume_alignment"(%13) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bf80) {
  %13 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x20688b0) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3395fe0) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1ea9130) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bac20) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0x1e943f0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After ResolveShapedTypeResultDims (resolve-shaped-type-result-dims) //----- //
module {
  func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
    %cst = arith.constant 0.000000e+00 : f32
    %c16 = arith.constant 16 : index
    %c8 = arith.constant 8 : index
    %c32 = arith.constant 32 : index
    %c256 = arith.constant 256 : index
    %c128 = arith.constant 128 : index
    %c1024 = arith.constant 1024 : index
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
    memref.assume_alignment %0, 64 : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
    %1 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
    %2 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
    memref.assume_alignment %2, 64 : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
    %3 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
    %4 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
    memref.assume_alignment %4, 64 : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
    %5 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_count_x = hal.interface.workgroup.count[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %workgroup_count_y = hal.interface.workgroup.count[1] : index
    %6 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
    %7 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
    %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
    %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
    scf.for %arg0 = %6 to %c512 step %7 {
      %subview = memref.subview %0[%arg0, 0] [256, 256] [1, 1] : memref<512x256xf32, #hal.descriptor_type<storage_buffer>> to memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      scf.for %arg1 = %8 to %c1024 step %9 {
        %subview_0 = memref.subview %2[0, %arg1] [256, 128] [1, 1] : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        %subview_1 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        %10 = scf.for %arg2 = %c0 to %c256 step %c8 iter_args(%arg3 = %subview_1) -> (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
          %11 = scf.for %arg4 = %c0 to %c128 step %c32 iter_args(%arg5 = %arg3) -> (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
            %12 = vector.transfer_read %arg5[%arg2, %arg4], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x32xf32>
            %13 = scf.for %arg6 = %c0 to %c256 step %c16 iter_args(%arg7 = %12) -> (vector<8x32xf32>) {
              %14 = vector.transfer_read %subview[%arg2, %arg6], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x16xf32>
              %15 = vector.transfer_read %subview_0[%arg6, %arg4], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<16x32xf32>
              %16 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %14, %15, %arg7 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
              scf.yield %16 : vector<8x32xf32>
            }
            vector.transfer_write %13, %arg5[%arg2, %arg4] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
            scf.yield %arg5 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
          }
          scf.yield %11 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        }
        %subview_2 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%10 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) outs(%subview_2 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
        ^bb0(%in: f32, %out: f32):
          linalg.yield %in : f32
        }
      }
    }
    return
  }
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bac20) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1ea9130) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3395fe0) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x20688b0) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bf80) {
  %13 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1e5a1f0) {
  "memref.assume_alignment"(%13) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %14 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %15 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %16 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %17 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %18 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %19 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %21 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %22 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3395b40) {
  %23 = "memref.subview"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a150) {
  %24 = "memref.subview"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x34c3240) {
  %25 = "memref.subview"(%13, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34d3110) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
    ** Insert  : 'scf.yield'(0x3b22430)
    ** Insert  : 'scf.for'(0x34c2170)
    ** Erase   : 'scf.yield'(0x206e830)
    ** Replace : 'scf.for'(0x34d3110)
    ** Erase   : 'scf.for'(0x34d3110)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339f3b0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
    ** Insert  : 'scf.yield'(0x3b224d0)
    ** Insert  : 'scf.for'(0x3b22530)
    ** Erase   : 'scf.yield'(0x206bae0)
    ** Replace : 'scf.for'(0x339f3b0)
    ** Erase   : 'scf.for'(0x339f3b0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c530) {
  %27 = "vector.transfer_read"(%25, %arg2, %arg3, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34c53f0) {
  %29 = "vector.transfer_read"(%23, %arg2, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %30 = "vector.transfer_read"(%24, %arg4, %arg3, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %31 = "vector.contract"(%29, %30, %arg5) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%31) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x2e88710) {
  "vector.transfer_write"(%28, %25, %arg2, %arg3) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x208d650) {
  %26 = "memref.subview"(%13, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0x1e5a090) {

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x34c52c0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bac20) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1ea9130) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3395fe0) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x20688b0) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bf80) {
  %13 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1e5a1f0) {
  "memref.assume_alignment"(%13) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %14 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %15 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %16 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %17 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %18 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %19 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %21 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %22 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3395b40) {
  %23 = "memref.subview"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a150) {
  %24 = "memref.subview"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x34c3240) {
  %25 = "memref.subview"(%13, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c530) {
  %27 = "vector.transfer_read"(%25, %arg2, %arg3, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34c53f0) {
  %29 = "vector.transfer_read"(%23, %arg2, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %30 = "vector.transfer_read"(%24, %arg4, %arg3, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %31 = "vector.contract"(%29, %30, %arg5) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%31) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x2e88710) {
  "vector.transfer_write"(%28, %25, %arg2, %arg3) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x208d650) {
  %26 = "memref.subview"(%13, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0x1e5a090) {

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x34c52c0) {
  "linalg.yield"(%arg2) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %0, 64 : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  %1 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %2, 64 : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  %3 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %4 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %4, 64 : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  %5 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %6 to %c512 step %7 {
    %subview = memref.subview %0[%arg0, 0] [256, 256] [1, 1] : memref<512x256xf32, #hal.descriptor_type<storage_buffer>> to memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
    scf.for %arg1 = %8 to %c1024 step %9 {
      %subview_0 = memref.subview %2[0, %arg1] [256, 128] [1, 1] : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      %subview_1 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      scf.for %arg2 = %c0 to %c256 step %c8 {
        scf.for %arg3 = %c0 to %c128 step %c32 {
          %10 = vector.transfer_read %subview_1[%arg2, %arg3], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x32xf32>
          %11 = scf.for %arg4 = %c0 to %c256 step %c16 iter_args(%arg5 = %10) -> (vector<8x32xf32>) {
            %12 = vector.transfer_read %subview[%arg2, %arg4], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x16xf32>
            %13 = vector.transfer_read %subview_0[%arg4, %arg3], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<16x32xf32>
            %14 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %12, %13, %arg5 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %14 : vector<8x32xf32>
          }
          vector.transfer_write %11, %subview_1[%arg2, %arg3] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        }
      }
      %subview_2 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%subview_1 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) outs(%subview_2 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
      ^bb0(%in: f32, %out: f32):
        linalg.yield %in : f32
      }
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %0, 64 : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  %1 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %2, 64 : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  %3 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %4 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %4, 64 : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  %5 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %6 to %c512 step %7 {
    %subview = memref.subview %0[%arg0, 0] [256, 256] [1, 1] : memref<512x256xf32, #hal.descriptor_type<storage_buffer>> to memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
    scf.for %arg1 = %8 to %c1024 step %9 {
      %subview_0 = memref.subview %2[0, %arg1] [256, 128] [1, 1] : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      %subview_1 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      scf.for %arg2 = %c0 to %c256 step %c8 {
        scf.for %arg3 = %c0 to %c128 step %c32 {
          %10 = vector.transfer_read %subview_1[%arg2, %arg3], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x32xf32>
          %11 = scf.for %arg4 = %c0 to %c256 step %c16 iter_args(%arg5 = %10) -> (vector<8x32xf32>) {
            %12 = vector.transfer_read %subview[%arg2, %arg4], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x16xf32>
            %13 = vector.transfer_read %subview_0[%arg4, %arg3], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<16x32xf32>
            %14 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %12, %13, %arg5 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %14 : vector<8x32xf32>
          }
          vector.transfer_write %11, %subview_1[%arg2, %arg3] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        }
      }
      linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%subview_1 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) outs(%subview_1 : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>) {
      ^bb0(%in: f32, %out: f32):
        linalg.yield %in : f32
      }
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bac20) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1ea9130) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3395fe0) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x20688b0) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bf80) {
  %13 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1e5a1f0) {
  "memref.assume_alignment"(%13) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %14 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %15 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %16 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %17 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %18 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %19 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %21 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %22 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3395b40) {
  %23 = "memref.subview"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a150) {
  %24 = "memref.subview"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x34c3240) {
  %25 = "memref.subview"(%13, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c530) {
  %26 = "vector.transfer_read"(%25, %arg2, %arg3, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34c53f0) {
  %28 = "vector.transfer_read"(%23, %arg2, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %29 = "vector.transfer_read"(%24, %arg4, %arg3, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %30 = "vector.contract"(%28, %29, %arg5) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%30) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x2e88710) {
  "vector.transfer_write"(%27, %25, %arg2, %arg3) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.generic'(0x1e5a090) {

  * Pattern FoldTensorCastProducerOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseDeadLinalgOp : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InferStaticShapeOfOperands : 'linalg.generic -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::EraseIdentityGenericOp : 'linalg.generic -> ()' {
    ** Erase   : 'linalg.generic'(0x1e5a090)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bac20) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1ea9130) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3395fe0) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x20688b0) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bf80) {
  %13 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1e5a1f0) {
  "memref.assume_alignment"(%13) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %14 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %15 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %16 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %17 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %18 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %19 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %21 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %22 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3395b40) {
  %23 = "memref.subview"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a150) {
  %24 = "memref.subview"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x34c3240) {
  %25 = "memref.subview"(%13, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c530) {
  %26 = "vector.transfer_read"(%25, %arg2, %arg3, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34c53f0) {
  %28 = "vector.transfer_read"(%23, %arg2, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %29 = "vector.transfer_read"(%24, %arg4, %arg3, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %30 = "vector.contract"(%28, %29, %arg5) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%30) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x2e88710) {
  "vector.transfer_write"(%27, %25, %arg2, %arg3) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %0, 64 : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  %1 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<512x256xf32>>
  %2 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %2, 64 : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  %3 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>
  %4 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %4, 64 : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  %5 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %6 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %7 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %8 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %9 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %6 to %c512 step %7 {
    %subview = memref.subview %0[%arg0, 0] [256, 256] [1, 1] : memref<512x256xf32, #hal.descriptor_type<storage_buffer>> to memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
    scf.for %arg1 = %8 to %c1024 step %9 {
      %subview_0 = memref.subview %2[0, %arg1] [256, 128] [1, 1] : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      %subview_1 = memref.subview %4[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      scf.for %arg2 = %c0 to %c256 step %c8 {
        scf.for %arg3 = %c0 to %c128 step %c32 {
          %10 = vector.transfer_read %subview_1[%arg2, %arg3], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x32xf32>
          %11 = scf.for %arg4 = %c0 to %c256 step %c16 iter_args(%arg5 = %10) -> (vector<8x32xf32>) {
            %12 = vector.transfer_read %subview[%arg2, %arg4], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x16xf32>
            %13 = vector.transfer_read %subview_0[%arg4, %arg3], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<16x32xf32>
            %14 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %12, %13, %arg5 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %14 : vector<8x32xf32>
          }
          vector.transfer_write %11, %subview_1[%arg2, %arg3] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        }
      }
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x2e88710) {
  "vector.transfer_write"(%27, %25, %arg2, %arg3) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%30) : (vector<8x32xf32>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %30 = "vector.contract"(%28, %29, %arg5) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %29 = "vector.transfer_read"(%24, %arg4, %arg3, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34c53f0) {
  %28 = "vector.transfer_read"(%23, %arg2, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c530) {
  %26 = "vector.transfer_read"(%25, %arg2, %arg3, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x32xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x34c3240) {
  %25 = "memref.subview"(%13, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a150) {
  %24 = "memref.subview"(%11, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3395b40) {
  %23 = "memref.subview"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %22 = "affine.apply"(%16) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %21 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %20 = "affine.apply"(%18) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %19 = "affine.apply"(%17) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %18 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.count -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %17 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %16 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.count -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %15 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1ea3a30) {
  %14 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readwrite:tensor<512x1024xf32>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
    ** Erase   : 'hal.interface.binding.subspan'(0x1ea3a30)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1e5a1f0) {
  "memref.assume_alignment"(%13) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bf80) {
  %13 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9fab0) {
  %12 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<256x1024xf32>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
    ** Erase   : 'hal.interface.binding.subspan'(0x1e9fab0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x20688b0) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3395fe0) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x1e9bb50) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> !flow.dispatch.tensor<readonly:tensor<512x256xf32>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
    ** Erase   : 'hal.interface.binding.subspan'(0x1e9bb50)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1ea9130) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bac20) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x2e88710) {
  "vector.transfer_write"(%24, %22, %arg2, %arg3) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%27) : (vector<8x32xf32>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %27 = "vector.contract"(%25, %26, %arg5) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.contract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %26 = "vector.transfer_read"(%21, %arg4, %arg3, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<16x32xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34c53f0) {
  %25 = "vector.transfer_read"(%20, %arg2, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x16xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c530) {
  %23 = "vector.transfer_read"(%22, %arg2, %arg3, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, index, index, f32) -> vector<8x32xf32>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x34c3240) {
  %22 = "memref.subview"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a150) {
  %21 = "memref.subview"(%10, %arg1) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3395b40) {
  %20 = "memref.subview"(%9, %arg0) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.count -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.count -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1e5a1f0) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bf80) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x20688b0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3395fe0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x1ea9130) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x256xf32, #hal.descriptor_type<storage_buffer>>) -> ()


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bac20) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32, #hal.descriptor_type<storage_buffer>>


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32


  * Pattern mlir::iree_compiler::(anonymous namespace)::RemoveDeadMemAllocs : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CleanupBufferAllocView (iree-codegen-cleanup-buffer-alloc-view) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %0, 64 : memref<512x256xf32, #hal.descriptor_type<storage_buffer>>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %1, 64 : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  memref.assume_alignment %2, 64 : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %subview = memref.subview %0[%arg0, 0] [256, 256] [1, 1] : memref<512x256xf32, #hal.descriptor_type<storage_buffer>> to memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %subview_0 = memref.subview %1[0, %arg1] [256, 128] [1, 1] : memref<256x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      %subview_1 = memref.subview %2[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32, #hal.descriptor_type<storage_buffer>> to memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
      scf.for %arg2 = %c0 to %c256 step %c8 {
        scf.for %arg3 = %c0 to %c128 step %c32 {
          %7 = vector.transfer_read %subview_1[%arg2, %arg3], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x32xf32>
          %8 = scf.for %arg4 = %c0 to %c256 step %c16 iter_args(%arg5 = %7) -> (vector<8x32xf32>) {
            %9 = vector.transfer_read %subview[%arg2, %arg4], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<8x16xf32>
            %10 = vector.transfer_read %subview_0[%arg4, %arg3], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>, vector<16x32xf32>
            %11 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %9, %10, %arg5 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %11 : vector<8x32xf32>
          }
          vector.transfer_write %8, %subview_1[%arg2, %arg3] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>, #hal.descriptor_type<storage_buffer>>
        }
      }
    }
  }
  return
}

// -----// IR Dump After EraseHALDescriptorTypeFromMemRef (iree-codegen-erase-hal-descriptor-type-from-memref) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c1024 = arith.constant 1024 : index
  %c512 = arith.constant 512 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_count_x = hal.interface.workgroup.count[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %workgroup_count_y = hal.interface.workgroup.count[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_count_y]
  %5 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %6 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_count_x]
  scf.for %arg0 = %3 to %c512 step %4 {
    %subview = memref.subview %0[%arg0, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
    scf.for %arg1 = %5 to %c1024 step %6 {
      %subview_0 = memref.subview %1[0, %arg1] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
      %subview_1 = memref.subview %2[%arg0, %arg1] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
      scf.for %arg2 = %c0 to %c256 step %c8 {
        scf.for %arg3 = %c0 to %c128 step %c32 {
          %7 = vector.transfer_read %subview_1[%arg2, %arg3], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
          %8 = scf.for %arg4 = %c0 to %c256 step %c16 iter_args(%arg5 = %7) -> (vector<8x32xf32>) {
            %9 = vector.transfer_read %subview[%arg2, %arg4], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
            %10 = vector.transfer_read %subview_0[%arg4, %arg3], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
            %11 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %9, %10, %arg5 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
            scf.yield %11 : vector<8x32xf32>
          }
          vector.transfer_write %8, %subview_1[%arg2, %arg3] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
        }
      }
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2069e80) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x20682f0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%24, %22, %arg2, %arg3) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%27) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %27 = "vector.contract"(%25, %26, %arg5) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %26 = "vector.transfer_read"(%21, %arg4, %arg3, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %25 = "vector.transfer_read"(%20, %arg2, %arg4, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %23 = "vector.transfer_read"(%22, %arg2, %arg3, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %22 = "memref.subview"(%11, %arg0, %arg1) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x207f5f0) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
    ** Replace : 'scf.for'(0x207f5f0)
    ** Erase   : 'scf.for'(0x207f5f0)
    ** Erase   : 'scf.yield'(0x20682f0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %21 = "memref.subview"(%10, %18) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x2067fa0) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
    ** Replace : 'scf.for'(0x2067fa0)
    ** Erase   : 'scf.for'(0x2067fa0)
    ** Erase   : 'scf.yield'(0x2069e80)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %20 = "memref.subview"(%9, %16) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %19 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x2068110)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %18 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2078870) {
  %17 = "affine.apply"(%15) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x2078870)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %16 = "affine.apply"(%14) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x2068a60) {
  %15 = "hal.interface.workgroup.count"() {dimension = 1 : index} : () -> index

  ** Erase   : 'hal.interface.workgroup.count'(0x2068a60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %14 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.count'(0x20689a0) {
  %13 = "hal.interface.workgroup.count"() {dimension = 0 : index} : () -> index

  ** Erase   : 'hal.interface.workgroup.count'(0x20689a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x206e8c0) {
  %7 = "arith.constant"() {value = 512 : index} : () -> index

  ** Erase   : 'arith.constant'(0x206e8c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1f9a4f0) {
  %6 = "arith.constant"() {value = 1024 : index} : () -> index

  ** Erase   : 'arith.constant'(0x1f9a4f0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%21) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %21 = "vector.contract"(%19, %20, %arg3) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern mlir::iree_compiler::(anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After RemoveSingleIterationLoop (iree-codegen-remove-single-iteration-loop) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.contract {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"], kind = #vector.kind<add>} %7, %8, %arg3 : vector<8x16xf32>, vector<16x32xf32> into vector<8x32xf32>
        scf.yield %9 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%21) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.contract'(0x34d1c20) {
  %21 = "vector.contract"(%19, %20, %arg3) {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#vector.iterator_type<parallel>, #vector.iterator_type<parallel>, #vector.iterator_type<reduction>], kind = #vector.kind<add>} : (vector<8x16xf32>, vector<16x32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::ContractionOpToOuterProductOpLowering : 'vector.contract -> ()' {
    ** Insert  : 'vector.transpose'(0x2e8bf80)
    ** Insert  : 'vector.extract'(0x33980f0)
    ** Insert  : 'vector.extract'(0x339f0f0)
    ** Insert  : 'vector.outerproduct'(0x207f600)
    ** Insert  : 'vector.extract'(0x34c51a0)
    ** Insert  : 'vector.extract'(0x34c20f0)
    ** Insert  : 'vector.outerproduct'(0x34c3240)
    ** Insert  : 'vector.extract'(0x2078870)
    ** Insert  : 'vector.extract'(0x34bac20)
    ** Insert  : 'vector.outerproduct'(0x3b226e0)
    ** Insert  : 'vector.extract'(0x3b227b0)
    ** Insert  : 'vector.extract'(0x3b22840)
    ** Insert  : 'vector.outerproduct'(0x3b228d0)
    ** Insert  : 'vector.extract'(0x3b229a0)
    ** Insert  : 'vector.extract'(0x3b22a30)
    ** Insert  : 'vector.outerproduct'(0x3b22ac0)
    ** Insert  : 'vector.extract'(0x3b22b90)
    ** Insert  : 'vector.extract'(0x3b1fb00)
    ** Insert  : 'vector.outerproduct'(0x339bc00)
    ** Insert  : 'vector.extract'(0x339bcd0)
    ** Insert  : 'vector.extract'(0x339bd60)
    ** Insert  : 'vector.outerproduct'(0x339bdf0)
    ** Insert  : 'vector.extract'(0x339bec0)
    ** Insert  : 'vector.extract'(0x339bf50)
    ** Insert  : 'vector.outerproduct'(0x339bfe0)
    ** Insert  : 'vector.extract'(0x339c0b0)
    ** Insert  : 'vector.extract'(0x339c140)
    ** Insert  : 'vector.outerproduct'(0x339c1d0)
    ** Insert  : 'vector.extract'(0x339c2a0)
    ** Insert  : 'vector.extract'(0x339c330)
    ** Insert  : 'vector.outerproduct'(0x3b2a4f0)
    ** Insert  : 'vector.extract'(0x3b2a5c0)
    ** Insert  : 'vector.extract'(0x3b2a650)
    ** Insert  : 'vector.outerproduct'(0x3b2a6e0)
    ** Insert  : 'vector.extract'(0x3b2a7b0)
    ** Insert  : 'vector.extract'(0x3b2a840)
    ** Insert  : 'vector.outerproduct'(0x3b2a8d0)
    ** Insert  : 'vector.extract'(0x3b2a9a0)
    ** Insert  : 'vector.extract'(0x3b2aa30)
    ** Insert  : 'vector.outerproduct'(0x3b2aac0)
    ** Insert  : 'vector.extract'(0x3b2ab90)
    ** Insert  : 'vector.extract'(0x3b2ac20)
    ** Insert  : 'vector.outerproduct'(0x3b2acb0)
    ** Insert  : 'vector.extract'(0x3b2ad80)
    ** Insert  : 'vector.extract'(0x3b2ae10)
    ** Insert  : 'vector.outerproduct'(0x3b2aea0)
    ** Insert  : 'vector.extract'(0x3b2af70)
    ** Insert  : 'vector.extract'(0x3b2b000)
    ** Insert  : 'vector.outerproduct'(0x3b2b090)
    ** Replace : 'vector.contract'(0x34d1c20)
    ** Erase   : 'vector.contract'(0x34d1c20)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyLowerVectorsPass (iree-linalg-strategy-lower-vectors-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgVectorLowering (linalg-vector-lowering) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::FoldTransposedScalarBroadcast : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTransposeSplat : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyLowerVectorsPass (iree-linalg-strategy-lower-vectors-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgVectorLowering (linalg-vector-lowering) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::FoldTransposedScalarBroadcast : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTransposeSplat : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyLowerVectorsPass (iree-linalg-strategy-lower-vectors-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgVectorLowering (linalg-vector-lowering) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::FoldTransposedScalarBroadcast : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTransposeSplat : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Failure : rank exceeds maxTransferRank: vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyLowerVectorsPass (iree-linalg-strategy-lower-vectors-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After LinalgVectorLowering (linalg-vector-lowering) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %0 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %1 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %2 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %3 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %4 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %5 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %6 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %7 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%7) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %8 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %9 = "hal.interface.binding.subspan"(%6) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %10 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %11 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %12 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %13 = "affine.apply"(%10) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %14 = "memref.subview"(%7, %12) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %16 = "memref.subview"(%9, %12, %13) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %17 = "vector.transfer_read"(%16, %arg0, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %19 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %20 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern (anonymous namespace)::FoldExtractSliceIntoTransferRead : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransferReadAfterWriteToBroadcast : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %21 = "vector.transpose"(%19) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::FoldTransposedScalarBroadcast : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTransposeSplat : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %22 = "vector.extract"(%21) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %23 = "vector.extract"(%20) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %24 = "vector.outerproduct"(%22, %23, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %25 = "vector.extract"(%21) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %26 = "vector.extract"(%20) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %27 = "vector.outerproduct"(%25, %26, %24) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %28 = "vector.extract"(%21) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %29 = "vector.extract"(%20) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %30 = "vector.outerproduct"(%28, %29, %27) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %31 = "vector.extract"(%21) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %32 = "vector.extract"(%20) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %33 = "vector.outerproduct"(%31, %32, %30) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %34 = "vector.extract"(%21) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %35 = "vector.extract"(%20) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %36 = "vector.outerproduct"(%34, %35, %33) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %37 = "vector.extract"(%21) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %38 = "vector.extract"(%20) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %39 = "vector.outerproduct"(%37, %38, %36) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %40 = "vector.extract"(%21) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %41 = "vector.extract"(%20) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %43 = "vector.extract"(%21) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %44 = "vector.extract"(%20) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %46 = "vector.extract"(%21) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %47 = "vector.extract"(%20) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %49 = "vector.extract"(%21) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %50 = "vector.extract"(%20) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %52 = "vector.extract"(%21) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %53 = "vector.extract"(%20) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %55 = "vector.extract"(%21) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %56 = "vector.extract"(%20) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %58 = "vector.extract"(%21) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %59 = "vector.extract"(%20) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %61 = "vector.extract"(%21) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %62 = "vector.extract"(%20) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %64 = "vector.extract"(%21) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %65 = "vector.extract"(%20) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %67 = "vector.extract"(%21) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %68 = "vector.extract"(%20) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%69) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern FoldTensorCastProducerOp : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldWaw : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant 0.000000e+00 : f32
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_0 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_1 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.transfer_read %subview_1[%arg0, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<8x32xf32>
      %6 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %5) -> (vector<8x32xf32>) {
        %7 = vector.transfer_read %subview[%arg0, %arg2], %cst {in_bounds = [true, true]} : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<8x16xf32>
        %8 = vector.transfer_read %subview_0[%arg2, %arg1], %cst {in_bounds = [true, true]} : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<16x32xf32>
        %9 = vector.transpose %7, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %10 = vector.extract %9[0] : vector<16x8xf32>
        %11 = vector.extract %8[0] : vector<16x32xf32>
        %12 = vector.outerproduct %10, %11, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %13 = vector.extract %9[1] : vector<16x8xf32>
        %14 = vector.extract %8[1] : vector<16x32xf32>
        %15 = vector.outerproduct %13, %14, %12 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %16 = vector.extract %9[2] : vector<16x8xf32>
        %17 = vector.extract %8[2] : vector<16x32xf32>
        %18 = vector.outerproduct %16, %17, %15 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %19 = vector.extract %9[3] : vector<16x8xf32>
        %20 = vector.extract %8[3] : vector<16x32xf32>
        %21 = vector.outerproduct %19, %20, %18 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %22 = vector.extract %9[4] : vector<16x8xf32>
        %23 = vector.extract %8[4] : vector<16x32xf32>
        %24 = vector.outerproduct %22, %23, %21 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %25 = vector.extract %9[5] : vector<16x8xf32>
        %26 = vector.extract %8[5] : vector<16x32xf32>
        %27 = vector.outerproduct %25, %26, %24 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %28 = vector.extract %9[6] : vector<16x8xf32>
        %29 = vector.extract %8[6] : vector<16x32xf32>
        %30 = vector.outerproduct %28, %29, %27 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %31 = vector.extract %9[7] : vector<16x8xf32>
        %32 = vector.extract %8[7] : vector<16x32xf32>
        %33 = vector.outerproduct %31, %32, %30 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %34 = vector.extract %9[8] : vector<16x8xf32>
        %35 = vector.extract %8[8] : vector<16x32xf32>
        %36 = vector.outerproduct %34, %35, %33 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %37 = vector.extract %9[9] : vector<16x8xf32>
        %38 = vector.extract %8[9] : vector<16x32xf32>
        %39 = vector.outerproduct %37, %38, %36 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %40 = vector.extract %9[10] : vector<16x8xf32>
        %41 = vector.extract %8[10] : vector<16x32xf32>
        %42 = vector.outerproduct %40, %41, %39 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %43 = vector.extract %9[11] : vector<16x8xf32>
        %44 = vector.extract %8[11] : vector<16x32xf32>
        %45 = vector.outerproduct %43, %44, %42 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %46 = vector.extract %9[12] : vector<16x8xf32>
        %47 = vector.extract %8[12] : vector<16x32xf32>
        %48 = vector.outerproduct %46, %47, %45 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %49 = vector.extract %9[13] : vector<16x8xf32>
        %50 = vector.extract %8[13] : vector<16x32xf32>
        %51 = vector.outerproduct %49, %50, %48 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %52 = vector.extract %9[14] : vector<16x8xf32>
        %53 = vector.extract %8[14] : vector<16x32xf32>
        %54 = vector.outerproduct %52, %53, %51 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %55 = vector.extract %9[15] : vector<16x8xf32>
        %56 = vector.extract %8[15] : vector<16x32xf32>
        %57 = vector.outerproduct %55, %56, %54 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %57 : vector<8x32xf32>
      }
      vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e7bc10) {
  "vector.transfer_write"(%18, %16, %arg0, %arg1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Failure : rank exceeds maxTransferRank: vector.transfer_write %6, %subview_1[%arg0, %arg1] {in_bounds = [true, true]} : vector<8x32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::lowering_n_d_unrolled::UnrollTransferWriteConversion : 'vector.transfer_write -> ()' {
    ** Insert  : 'arith.constant'(0x3b2e750)
    ** Insert  : 'affine.apply'(0x2068110)
    ** Insert  : 'vector.extract'(0x3395fe0)
    ** Insert  : 'vector.transfer_write'(0x2e88710)
    ** Insert  : 'arith.constant'(0x2069e90)
    ** Insert  : 'affine.apply'(0x3b263c0)
    ** Insert  : 'vector.extract'(0x3b26450)
    ** Insert  : 'vector.transfer_write'(0x1e5ec00)
    ** Insert  : 'arith.constant'(0x3b1f9d0)
    ** Insert  : 'affine.apply'(0x3b264e0)
    ** Insert  : 'vector.extract'(0x3b2d570)
    ** Insert  : 'vector.transfer_write'(0x1e6cd70)
    ** Insert  : 'arith.constant'(0x3b1f7f0)
    ** Insert  : 'affine.apply'(0x3b2d600)
    ** Insert  : 'vector.extract'(0x3b2d690)
    ** Insert  : 'vector.transfer_write'(0x1d53430)
    ** Insert  : 'arith.constant'(0x3b1f6a0)
    ** Insert  : 'affine.apply'(0x3b2d1b0)
    ** Insert  : 'vector.extract'(0x3b2d240)
    ** Insert  : 'vector.transfer_write'(0x1d52ce0)
    ** Insert  : 'arith.constant'(0x3b24a00)
    ** Insert  : 'affine.apply'(0x3b2d3a0)
    ** Insert  : 'vector.extract'(0x3b2d430)
    ** Insert  : 'vector.transfer_write'(0x1d47190)
    ** Insert  : 'arith.constant'(0x2068300)
    ** Insert  : 'affine.apply'(0x3b2d4c0)
    ** Insert  : 'vector.extract'(0x3b2a310)
    ** Insert  : 'vector.transfer_write'(0x1d494b0)
    ** Insert  : 'arith.constant'(0x339f260)
    ** Insert  : 'affine.apply'(0x3b2a3a0)
    ** Insert  : 'vector.extract'(0x3b32810)
    ** Insert  : 'vector.transfer_write'(0x3b32890)
    ** Erase   : 'vector.transfer_write'(0x1e7bc10)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x3b32890) {
  "vector.transfer_write"(%42, %16, %41, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0x1e7bc10)
    ** Replace : 'vector.transfer_write'(0x3b32890)
    ** Erase   : 'vector.transfer_write'(0x3b32890)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%42, %16, %41, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %42 = "vector.extract"(%18) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a3a0) {
  %41 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339f260) {
  %40 = "arith.constant"() {value = 7 : index} : () -> index

  ** Erase   : 'arith.constant'(0x339f260)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1d494b0) {
  "vector.transfer_write"(%39, %16, %38, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0x3b32890)
    ** Replace : 'vector.transfer_write'(0x1d494b0)
    ** Erase   : 'vector.transfer_write'(0x1d494b0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%39, %16, %38, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %39 = "vector.extract"(%18) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2d4c0) {
  %38 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2068300) {
  %37 = "arith.constant"() {value = 6 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2068300)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1d47190) {
  "vector.transfer_write"(%36, %16, %35, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0x1d494b0)
    ** Replace : 'vector.transfer_write'(0x1d47190)
    ** Erase   : 'vector.transfer_write'(0x1d47190)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%36, %16, %35, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %36 = "vector.extract"(%18) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2d3a0) {
  %35 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b24a00) {
  %34 = "arith.constant"() {value = 5 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b24a00)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1d52ce0) {
  "vector.transfer_write"(%33, %16, %32, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0x1d47190)
    ** Replace : 'vector.transfer_write'(0x1d52ce0)
    ** Erase   : 'vector.transfer_write'(0x1d52ce0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%33, %16, %32, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %33 = "vector.extract"(%18) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2d1b0) {
  %32 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b1f6a0) {
  %31 = "arith.constant"() {value = 4 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b1f6a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1d53430) {
  "vector.transfer_write"(%30, %16, %29, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0x1d52ce0)
    ** Replace : 'vector.transfer_write'(0x1d53430)
    ** Erase   : 'vector.transfer_write'(0x1d53430)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%30, %16, %29, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %30 = "vector.extract"(%18) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2d600) {
  %29 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b1f7f0) {
  %28 = "arith.constant"() {value = 3 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b1f7f0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e6cd70) {
  "vector.transfer_write"(%27, %16, %26, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0x1d53430)
    ** Replace : 'vector.transfer_write'(0x1e6cd70)
    ** Erase   : 'vector.transfer_write'(0x1e6cd70)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%27, %16, %26, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %27 = "vector.extract"(%18) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b264e0) {
  %26 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b1f9d0) {
  %25 = "arith.constant"() {value = 2 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b1f9d0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x1e5ec00) {
  "vector.transfer_write"(%24, %16, %23, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0x1e6cd70)
    ** Replace : 'vector.transfer_write'(0x1e5ec00)
    ** Erase   : 'vector.transfer_write'(0x1e5ec00)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%24, %16, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %24 = "vector.extract"(%18) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b263c0) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2069e90) {
  %22 = "arith.constant"() {value = 1 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2069e90)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_write'(0x2e88710) {
  "vector.transfer_write"(%21, %16, %20, %arg1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 1, 2, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern TransferWritePermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteNonPermutationLowering : 'vector.transfer_write -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferWriteToVectorStoreLowering : 'vector.transfer_write -> ()' {
    ** Insert  : 'vector.store'(0x1e5ec00)
    ** Replace : 'vector.transfer_write'(0x2e88710)
    ** Erase   : 'vector.transfer_write'(0x2e88710)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%21, %16, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %21 = "vector.extract"(%18) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068110) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x2068110)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%20, %16, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %19 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b2e750)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%84) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %84 = "vector.outerproduct"(%82, %83, %81) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %83 = "vector.extract"(%35) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %82 = "vector.extract"(%36) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %81 = "vector.outerproduct"(%79, %80, %78) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %80 = "vector.extract"(%35) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %79 = "vector.extract"(%36) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %78 = "vector.outerproduct"(%76, %77, %75) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %77 = "vector.extract"(%35) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %76 = "vector.extract"(%36) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %75 = "vector.outerproduct"(%73, %74, %72) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %74 = "vector.extract"(%35) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %73 = "vector.extract"(%36) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %72 = "vector.outerproduct"(%70, %71, %69) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %71 = "vector.extract"(%35) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %70 = "vector.extract"(%36) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %69 = "vector.outerproduct"(%67, %68, %66) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %68 = "vector.extract"(%35) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %67 = "vector.extract"(%36) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %66 = "vector.outerproduct"(%64, %65, %63) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %65 = "vector.extract"(%35) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %64 = "vector.extract"(%36) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %63 = "vector.outerproduct"(%61, %62, %60) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %62 = "vector.extract"(%35) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %61 = "vector.extract"(%36) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %60 = "vector.outerproduct"(%58, %59, %57) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %59 = "vector.extract"(%35) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %58 = "vector.extract"(%36) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %57 = "vector.outerproduct"(%55, %56, %54) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %56 = "vector.extract"(%35) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %55 = "vector.extract"(%36) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %54 = "vector.outerproduct"(%52, %53, %51) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %53 = "vector.extract"(%35) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %52 = "vector.extract"(%36) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %51 = "vector.outerproduct"(%49, %50, %48) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %50 = "vector.extract"(%35) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %49 = "vector.extract"(%36) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %48 = "vector.outerproduct"(%46, %47, %45) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %47 = "vector.extract"(%35) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %46 = "vector.extract"(%36) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %45 = "vector.outerproduct"(%43, %44, %42) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %44 = "vector.extract"(%35) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %43 = "vector.extract"(%36) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %42 = "vector.outerproduct"(%40, %41, %39) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %41 = "vector.extract"(%35) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %40 = "vector.extract"(%36) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %39 = "vector.outerproduct"(%37, %38, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %38 = "vector.extract"(%35) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %37 = "vector.extract"(%36) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %36 = "vector.transpose"(%34) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %35 = "vector.transfer_read"(%15, %arg2, %arg1, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<16x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::lowering_n_d_unrolled::UnrollTransferReadConversion : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.splat'(0x2068110)
    ** Insert  : 'arith.constant'(0x2069e90)
    ** Insert  : 'affine.apply'(0x3b2c3f0)
    ** Insert  : 'vector.transfer_read'(0x1e2c530)
    ** Insert  : 'vector.insert'(0x3395b40)
    ** Insert  : 'arith.constant'(0x3b1f9d0)
    ** Insert  : 'affine.apply'(0x3b2c480)
    ** Insert  : 'vector.transfer_read'(0x34c53f0)
    ** Insert  : 'vector.insert'(0x1e5a150)
    ** Insert  : 'arith.constant'(0x3b1f7f0)
    ** Insert  : 'affine.apply'(0x3b2c510)
    ** Insert  : 'vector.transfer_read'(0x3396d40)
    ** Insert  : 'vector.insert'(0x33a2540)
    ** Insert  : 'arith.constant'(0x3b1f6a0)
    ** Insert  : 'affine.apply'(0x3b2c5a0)
    ** Insert  : 'vector.transfer_read'(0x1e5e440)
    ** Insert  : 'vector.insert'(0x3398040)
    ** Insert  : 'arith.constant'(0x3b24a00)
    ** Insert  : 'affine.apply'(0x3b2c630)
    ** Insert  : 'vector.transfer_read'(0x1e2c3e0)
    ** Insert  : 'vector.insert'(0x3394240)
    ** Insert  : 'arith.constant'(0x2068300)
    ** Insert  : 'affine.apply'(0x3b2dfd0)
    ** Insert  : 'vector.transfer_read'(0x1e112b0)
    ** Insert  : 'vector.insert'(0x34d0650)
    ** Insert  : 'arith.constant'(0x339f260)
    ** Insert  : 'affine.apply'(0x3b2e060)
    ** Insert  : 'vector.transfer_read'(0x1dce9a0)
    ** Insert  : 'vector.insert'(0x34d05a0)
    ** Insert  : 'arith.constant'(0x3b2e750)
    ** Insert  : 'affine.apply'(0x3b2e0f0)
    ** Insert  : 'vector.transfer_read'(0x3b2e180)
    ** Insert  : 'vector.insert'(0x3b2e270)
    ** Insert  : 'arith.constant'(0x3b2d720)
    ** Insert  : 'affine.apply'(0x3b25810)
    ** Insert  : 'vector.transfer_read'(0x3b258a0)
    ** Insert  : 'vector.insert'(0x3b25990)
    ** Insert  : 'arith.constant'(0x3b25a40)
    ** Insert  : 'affine.apply'(0x3b25aa0)
    ** Insert  : 'vector.transfer_read'(0x3b2cbf0)
    ** Insert  : 'vector.insert'(0x3b2cce0)
    ** Insert  : 'arith.constant'(0x3b2cd90)
    ** Insert  : 'affine.apply'(0x3b2cdf0)
    ** Insert  : 'vector.transfer_read'(0x3b2ce80)
    ** Insert  : 'vector.insert'(0x3b36b00)
    ** Insert  : 'arith.constant'(0x3b24d60)
    ** Insert  : 'affine.apply'(0x3b36bb0)
    ** Insert  : 'vector.transfer_read'(0x3b36c40)
    ** Insert  : 'vector.insert'(0x3b36d30)
    ** Insert  : 'arith.constant'(0x3b25b30)
    ** Insert  : 'affine.apply'(0x3b36de0)
    ** Insert  : 'vector.transfer_read'(0x3b36e70)
    ** Insert  : 'vector.insert'(0x3b36f60)
    ** Insert  : 'arith.constant'(0x3b37820)
    ** Insert  : 'affine.apply'(0x3b37880)
    ** Insert  : 'vector.transfer_read'(0x3b37910)
    ** Insert  : 'vector.insert'(0x3b37a00)
    ** Insert  : 'arith.constant'(0x3b37ab0)
    ** Insert  : 'affine.apply'(0x3b38320)
    ** Insert  : 'vector.transfer_read'(0x3b383b0)
    ** Insert  : 'vector.insert'(0x3b384a0)
    ** Insert  : 'arith.constant'(0x3b38550)
    ** Insert  : 'affine.apply'(0x3b385b0)
    ** Insert  : 'vector.transfer_read'(0x3b38640)
    ** Insert  : 'vector.insert'(0x3b38730)
    ** Replace : 'vector.transfer_read'(0x1e39900)
    ** Erase   : 'vector.transfer_read'(0x1e39900)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339f0f0) {
  %102 = "vector.extract"(%99) {position = [0]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x339f0f0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %102 = "vector.outerproduct"(%101, %38, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c20f0) {
  %104 = "vector.extract"(%99) {position = [1]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x34c20f0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %104 = "vector.outerproduct"(%103, %42, %102) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %106 = "vector.extract"(%99) {position = [2]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x34bac20)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %106 = "vector.outerproduct"(%105, %46, %104) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22840) {
  %108 = "vector.extract"(%99) {position = [3]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x3b22840)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %108 = "vector.outerproduct"(%107, %50, %106) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22a30) {
  %110 = "vector.extract"(%99) {position = [4]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x3b22a30)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %110 = "vector.outerproduct"(%109, %54, %108) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b1fb00) {
  %112 = "vector.extract"(%99) {position = [5]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x3b1fb00)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %112 = "vector.outerproduct"(%111, %58, %110) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bd60) {
  %114 = "vector.extract"(%99) {position = [6]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x339bd60)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %114 = "vector.outerproduct"(%113, %62, %112) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bf50) {
  %116 = "vector.extract"(%99) {position = [7]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x339bf50)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %116 = "vector.outerproduct"(%115, %66, %114) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c140) {
  %118 = "vector.extract"(%99) {position = [8]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x339c140)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %118 = "vector.outerproduct"(%117, %70, %116) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c330) {
  %120 = "vector.extract"(%99) {position = [9]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x339c330)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %120 = "vector.outerproduct"(%119, %74, %118) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a650) {
  %122 = "vector.extract"(%99) {position = [10]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x3b2a650)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %122 = "vector.outerproduct"(%121, %78, %120) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a840) {
  %124 = "vector.extract"(%99) {position = [11]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x3b2a840)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %124 = "vector.outerproduct"(%123, %82, %122) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2aa30) {
  %126 = "vector.extract"(%99) {position = [12]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x3b2aa30)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %126 = "vector.outerproduct"(%125, %86, %124) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ac20) {
  %128 = "vector.extract"(%99) {position = [13]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x3b2ac20)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %128 = "vector.outerproduct"(%127, %90, %126) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ae10) {
  %130 = "vector.extract"(%99) {position = [14]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x3b2ae10)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %130 = "vector.outerproduct"(%129, %94, %128) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2b000) {
  %132 = "vector.extract"(%99) {position = [15]} : (vector<16x32xf32>) -> vector<32xf32>

  ** Erase   : 'vector.extract'(0x3b2b000)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %132 = "vector.outerproduct"(%131, %98, %130) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b38730) {
  %99 = "vector.insert"(%98, %95) {position = [15]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x3b38730)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b38640) {
  %98 = "vector.transfer_read"(%15, %97, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b32980)
    ** Replace : 'vector.transfer_read'(0x3b38640)
    ** Erase   : 'vector.transfer_read'(0x3b38640)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %131 = "vector.outerproduct"(%130, %98, %129) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %98 = "vector.load"(%15, %97, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %97 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b38550) {
  %96 = "arith.constant"() {value = 15 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b38550)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b384a0) {
  %95 = "vector.insert"(%94, %91) {position = [14]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x3b384a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b383b0) {
  %94 = "vector.transfer_read"(%15, %93, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b387e0)
    ** Replace : 'vector.transfer_read'(0x3b383b0)
    ** Erase   : 'vector.transfer_read'(0x3b383b0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %127 = "vector.outerproduct"(%126, %94, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %94 = "vector.load"(%15, %93, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %93 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b37ab0) {
  %92 = "arith.constant"() {value = 14 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b37ab0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b37a00) {
  %91 = "vector.insert"(%90, %87) {position = [13]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x3b37a00)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b37910) {
  %90 = "vector.transfer_read"(%15, %89, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b388b0)
    ** Replace : 'vector.transfer_read'(0x3b37910)
    ** Erase   : 'vector.transfer_read'(0x3b37910)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %123 = "vector.outerproduct"(%122, %90, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %90 = "vector.load"(%15, %89, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %89 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b37820) {
  %88 = "arith.constant"() {value = 13 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b37820)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36f60) {
  %87 = "vector.insert"(%86, %83) {position = [12]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x3b36f60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b36e70) {
  %86 = "vector.transfer_read"(%15, %85, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b38980)
    ** Replace : 'vector.transfer_read'(0x3b36e70)
    ** Erase   : 'vector.transfer_read'(0x3b36e70)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %119 = "vector.outerproduct"(%118, %86, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %86 = "vector.load"(%15, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b25b30) {
  %84 = "arith.constant"() {value = 12 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b25b30)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36d30) {
  %83 = "vector.insert"(%82, %79) {position = [11]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x3b36d30)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b36c40) {
  %82 = "vector.transfer_read"(%15, %81, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b38a50)
    ** Replace : 'vector.transfer_read'(0x3b36c40)
    ** Erase   : 'vector.transfer_read'(0x3b36c40)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %115 = "vector.outerproduct"(%114, %82, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %82 = "vector.load"(%15, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b24d60) {
  %80 = "arith.constant"() {value = 11 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b24d60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36b00) {
  %79 = "vector.insert"(%78, %75) {position = [10]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x3b36b00)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b2ce80) {
  %78 = "vector.transfer_read"(%15, %77, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b38b20)
    ** Replace : 'vector.transfer_read'(0x3b2ce80)
    ** Erase   : 'vector.transfer_read'(0x3b2ce80)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %111 = "vector.outerproduct"(%110, %78, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %78 = "vector.load"(%15, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2cd90) {
  %76 = "arith.constant"() {value = 10 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b2cd90)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cce0) {
  %75 = "vector.insert"(%74, %71) {position = [9]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x3b2cce0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b2cbf0) {
  %74 = "vector.transfer_read"(%15, %73, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b38bf0)
    ** Replace : 'vector.transfer_read'(0x3b2cbf0)
    ** Erase   : 'vector.transfer_read'(0x3b2cbf0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %107 = "vector.outerproduct"(%106, %74, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %74 = "vector.load"(%15, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b25a40) {
  %72 = "arith.constant"() {value = 9 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b25a40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b25990) {
  %71 = "vector.insert"(%70, %67) {position = [8]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x3b25990)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b258a0) {
  %70 = "vector.transfer_read"(%15, %69, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b2cbf0)
    ** Replace : 'vector.transfer_read'(0x3b258a0)
    ** Erase   : 'vector.transfer_read'(0x3b258a0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %103 = "vector.outerproduct"(%102, %70, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %70 = "vector.load"(%15, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2d720) {
  %68 = "arith.constant"() {value = 8 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b2d720)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2e270) {
  %67 = "vector.insert"(%66, %63) {position = [7]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x3b2e270)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b2e180) {
  %66 = "vector.transfer_read"(%15, %65, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b258a0)
    ** Replace : 'vector.transfer_read'(0x3b2e180)
    ** Erase   : 'vector.transfer_read'(0x3b2e180)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %99 = "vector.outerproduct"(%98, %66, %97) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %66 = "vector.load"(%15, %65, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %65 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %64 = "arith.constant"() {value = 7 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b2e750)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x34d05a0) {
  %63 = "vector.insert"(%62, %59) {position = [6]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x34d05a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1dce9a0) {
  %62 = "vector.transfer_read"(%15, %61, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b25970)
    ** Replace : 'vector.transfer_read'(0x1dce9a0)
    ** Erase   : 'vector.transfer_read'(0x1dce9a0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %95 = "vector.outerproduct"(%94, %62, %93) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %62 = "vector.load"(%15, %61, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %61 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339f260) {
  %60 = "arith.constant"() {value = 6 : index} : () -> index

  ** Erase   : 'arith.constant'(0x339f260)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x34d0650) {
  %59 = "vector.insert"(%58, %55) {position = [5]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x34d0650)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e112b0) {
  %58 = "vector.transfer_read"(%15, %57, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x1dce9a0)
    ** Replace : 'vector.transfer_read'(0x1e112b0)
    ** Erase   : 'vector.transfer_read'(0x1e112b0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %91 = "vector.outerproduct"(%90, %58, %89) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %58 = "vector.load"(%15, %57, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %57 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2068300) {
  %56 = "arith.constant"() {value = 5 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2068300)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3394240) {
  %55 = "vector.insert"(%54, %51) {position = [4]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x3394240)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c3e0) {
  %54 = "vector.transfer_read"(%15, %53, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x1e112b0)
    ** Replace : 'vector.transfer_read'(0x1e2c3e0)
    ** Erase   : 'vector.transfer_read'(0x1e2c3e0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %87 = "vector.outerproduct"(%86, %54, %85) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %54 = "vector.load"(%15, %53, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %53 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b24a00) {
  %52 = "arith.constant"() {value = 4 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b24a00)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %51 = "vector.insert"(%50, %47) {position = [3]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x3398040)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e5e440) {
  %50 = "vector.transfer_read"(%15, %49, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x1e2c3e0)
    ** Replace : 'vector.transfer_read'(0x1e5e440)
    ** Erase   : 'vector.transfer_read'(0x1e5e440)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %83 = "vector.outerproduct"(%82, %50, %81) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %50 = "vector.load"(%15, %49, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %49 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b1f6a0) {
  %48 = "arith.constant"() {value = 3 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b1f6a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %47 = "vector.insert"(%46, %43) {position = [2]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x33a2540)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3396d40) {
  %46 = "vector.transfer_read"(%15, %45, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x1e5e440)
    ** Replace : 'vector.transfer_read'(0x3396d40)
    ** Erase   : 'vector.transfer_read'(0x3396d40)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %79 = "vector.outerproduct"(%78, %46, %77) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %46 = "vector.load"(%15, %45, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %45 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b1f7f0) {
  %44 = "arith.constant"() {value = 2 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b1f7f0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %43 = "vector.insert"(%42, %39) {position = [1]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x1e5a150)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34c53f0) {
  %42 = "vector.transfer_read"(%15, %41, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3396d40)
    ** Replace : 'vector.transfer_read'(0x34c53f0)
    ** Erase   : 'vector.transfer_read'(0x34c53f0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %75 = "vector.outerproduct"(%74, %42, %73) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %42 = "vector.load"(%15, %41, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %41 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b1f9d0) {
  %40 = "arith.constant"() {value = 1 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b1f9d0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %39 = "vector.insert"(%38, %35) {position = [0]} : (vector<32xf32>, vector<16x32xf32>) -> vector<16x32xf32>

  ** Erase   : 'vector.insert'(0x3395b40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c530) {
  %38 = "vector.transfer_read"(%15, %37, %arg1, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x34c53f0)
    ** Replace : 'vector.transfer_read'(0x1e2c530)
    ** Erase   : 'vector.transfer_read'(0x1e2c530)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %71 = "vector.outerproduct"(%70, %38, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %38 = "vector.load"(%15, %37, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c3f0) {
  %37 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x3b2c3f0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %37 = "vector.load"(%15, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2069e90) {
  %36 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2069e90)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.splat'(0x2068110) {
  %35 = "vector.splat"(%0) : (f32) -> vector<16x32xf32>

  ** Erase   : 'vector.splat'(0x2068110)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %34 = "vector.transfer_read"(%14, %arg0, %arg2, %0) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<8x16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::lowering_n_d_unrolled::UnrollTransferReadConversion : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.splat'(0x339bd60)
    ** Insert  : 'arith.constant'(0x3b25a40)
    ** Insert  : 'affine.apply'(0x3b1fb00)
    ** Insert  : 'vector.transfer_read'(0x3b2ce80)
    ** Insert  : 'vector.insert'(0x3b2cce0)
    ** Insert  : 'arith.constant'(0x3b2cd90)
    ** Insert  : 'affine.apply'(0x3b22a30)
    ** Insert  : 'vector.transfer_read'(0x3b36c40)
    ** Insert  : 'vector.insert'(0x3b36b00)
    ** Insert  : 'arith.constant'(0x3b24d60)
    ** Insert  : 'affine.apply'(0x3b22840)
    ** Insert  : 'vector.transfer_read'(0x3b36e70)
    ** Insert  : 'vector.insert'(0x3b36d30)
    ** Insert  : 'arith.constant'(0x3b25b30)
    ** Insert  : 'affine.apply'(0x34bac20)
    ** Insert  : 'vector.transfer_read'(0x3b37910)
    ** Insert  : 'vector.insert'(0x3b36f60)
    ** Insert  : 'arith.constant'(0x3b37820)
    ** Insert  : 'affine.apply'(0x34c20f0)
    ** Insert  : 'vector.transfer_read'(0x3b383b0)
    ** Insert  : 'vector.insert'(0x3b37a00)
    ** Insert  : 'arith.constant'(0x3b37ab0)
    ** Insert  : 'affine.apply'(0x339f0f0)
    ** Insert  : 'vector.transfer_read'(0x3b38640)
    ** Insert  : 'vector.insert'(0x3b384a0)
    ** Insert  : 'arith.constant'(0x3b38550)
    ** Insert  : 'affine.apply'(0x339bf50)
    ** Insert  : 'vector.transfer_read'(0x1e39900)
    ** Insert  : 'vector.insert'(0x3b38730)
    ** Insert  : 'arith.constant'(0x3b2e750)
    ** Insert  : 'affine.apply'(0x3b2ae10)
    ** Insert  : 'vector.transfer_read'(0x34d05a0)
    ** Insert  : 'vector.insert'(0x3394240)
    ** Replace : 'vector.transfer_read'(0x1e2c680)
    ** Erase   : 'vector.transfer_read'(0x1e2c680)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %98 = "vector.transpose"(%66) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3394240) {
  %66 = "vector.insert"(%65, %62) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34d05a0) {
  %65 = "vector.transfer_read"(%14, %64, %arg2, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x1e2c530)
    ** Replace : 'vector.transfer_read'(0x34d05a0)
    ** Erase   : 'vector.transfer_read'(0x34d05a0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3394240) {
  %66 = "vector.insert"(%65, %62) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %65 = "vector.load"(%14, %64, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2ae10) {
  %64 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %63 = "arith.constant"() {value = 7 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b2e750)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b38730) {
  %62 = "vector.insert"(%61, %58) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %61 = "vector.transfer_read"(%14, %60, %arg2, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b2e180)
    ** Replace : 'vector.transfer_read'(0x1e39900)
    ** Erase   : 'vector.transfer_read'(0x1e39900)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b38730) {
  %62 = "vector.insert"(%61, %58) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %61 = "vector.load"(%14, %60, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bf50) {
  %60 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b38550) {
  %59 = "arith.constant"() {value = 6 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b38550)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b384a0) {
  %58 = "vector.insert"(%57, %54) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b38640) {
  %57 = "vector.transfer_read"(%14, %56, %arg2, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b38cc0)
    ** Replace : 'vector.transfer_read'(0x3b38640)
    ** Erase   : 'vector.transfer_read'(0x3b38640)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b384a0) {
  %58 = "vector.insert"(%57, %54) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %57 = "vector.load"(%14, %56, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339f0f0) {
  %56 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b37ab0) {
  %55 = "arith.constant"() {value = 5 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b37ab0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b37a00) {
  %54 = "vector.insert"(%53, %50) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b383b0) {
  %53 = "vector.transfer_read"(%14, %52, %arg2, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b38d90)
    ** Replace : 'vector.transfer_read'(0x3b383b0)
    ** Erase   : 'vector.transfer_read'(0x3b383b0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b37a00) {
  %54 = "vector.insert"(%53, %50) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %53 = "vector.load"(%14, %52, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x34c20f0) {
  %52 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b37820) {
  %51 = "arith.constant"() {value = 4 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b37820)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36f60) {
  %50 = "vector.insert"(%49, %46) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b37910) {
  %49 = "vector.transfer_read"(%14, %48, %arg2, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b38e60)
    ** Replace : 'vector.transfer_read'(0x3b37910)
    ** Erase   : 'vector.transfer_read'(0x3b37910)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36f60) {
  %50 = "vector.insert"(%49, %46) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %49 = "vector.load"(%14, %48, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x34bac20) {
  %48 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b25b30) {
  %47 = "arith.constant"() {value = 3 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b25b30)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36d30) {
  %46 = "vector.insert"(%45, %42) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b36e70) {
  %45 = "vector.transfer_read"(%14, %44, %arg2, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b38f30)
    ** Replace : 'vector.transfer_read'(0x3b36e70)
    ** Erase   : 'vector.transfer_read'(0x3b36e70)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36d30) {
  %46 = "vector.insert"(%45, %42) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %45 = "vector.load"(%14, %44, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b22840) {
  %44 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b24d60) {
  %43 = "arith.constant"() {value = 2 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b24d60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36b00) {
  %42 = "vector.insert"(%41, %38) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b36c40) {
  %41 = "vector.transfer_read"(%14, %40, %arg2, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b39000)
    ** Replace : 'vector.transfer_read'(0x3b36c40)
    ** Erase   : 'vector.transfer_read'(0x3b36c40)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36b00) {
  %42 = "vector.insert"(%41, %38) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %41 = "vector.load"(%14, %40, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b22a30) {
  %40 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2cd90) {
  %39 = "arith.constant"() {value = 1 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b2cd90)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cce0) {
  %38 = "vector.insert"(%37, %34) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b2ce80) {
  %37 = "vector.transfer_read"(%14, %36, %arg2, %0) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index, f32) -> vector<16xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b36c40)
    ** Replace : 'vector.transfer_read'(0x3b2ce80)
    ** Erase   : 'vector.transfer_read'(0x3b2ce80)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cce0) {
  %38 = "vector.insert"(%37, %34) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %37 = "vector.load"(%14, %36, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b1fb00) {
  %36 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x3b1fb00)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %36 = "vector.load"(%14, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b25a40) {
  %35 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b25a40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.splat'(0x339bd60) {
  %34 = "vector.splat"(%0) : (f32) -> vector<8x16xf32>

  ** Erase   : 'vector.splat'(0x339bd60)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cce0) {
  %36 = "vector.insert"(%35, %0) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2069e90) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b1f700) {
  %18 = "vector.transfer_read"(%17, %arg0, %arg1, %1) {in_bounds = [true, true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d0, d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<8x32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::lowering_n_d_unrolled::UnrollTransferReadConversion : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.splat'(0x3b1fb00)
    ** Insert  : 'arith.constant'(0x3b1f9d0)
    ** Insert  : 'affine.apply'(0x3b2ac20)
    ** Insert  : 'vector.transfer_read'(0x3b36e70)
    ** Insert  : 'vector.insert'(0x3395b40)
    ** Insert  : 'arith.constant'(0x3b1f7f0)
    ** Insert  : 'affine.apply'(0x3b2aa30)
    ** Insert  : 'vector.transfer_read'(0x3b37910)
    ** Insert  : 'vector.insert'(0x1e5a150)
    ** Insert  : 'arith.constant'(0x3b1f6a0)
    ** Insert  : 'affine.apply'(0x3b2a840)
    ** Insert  : 'vector.transfer_read'(0x3b383b0)
    ** Insert  : 'vector.insert'(0x33a2540)
    ** Insert  : 'arith.constant'(0x3b24a00)
    ** Insert  : 'affine.apply'(0x3b2a650)
    ** Insert  : 'vector.transfer_read'(0x3b38640)
    ** Insert  : 'vector.insert'(0x3398040)
    ** Insert  : 'arith.constant'(0x2068300)
    ** Insert  : 'affine.apply'(0x339c330)
    ** Insert  : 'vector.transfer_read'(0x1e39900)
    ** Insert  : 'vector.insert'(0x3b3a1b0)
    ** Insert  : 'arith.constant'(0x339f260)
    ** Insert  : 'affine.apply'(0x339c140)
    ** Insert  : 'vector.transfer_read'(0x34d05a0)
    ** Insert  : 'vector.insert'(0x3b3a260)
    ** Insert  : 'arith.constant'(0x3b2e750)
    ** Insert  : 'affine.apply'(0x3b2b000)
    ** Insert  : 'vector.transfer_read'(0x1e2c680)
    ** Insert  : 'vector.insert'(0x3b3a310)
    ** Insert  : 'arith.constant'(0x3b25a40)
    ** Insert  : 'affine.apply'(0x339bd60)
    ** Insert  : 'vector.transfer_read'(0x3b3a3c0)
    ** Insert  : 'vector.insert'(0x3b3a4b0)
    ** Replace : 'vector.transfer_read'(0x3b1f700)
    ** Erase   : 'vector.transfer_read'(0x3b1f700)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %50 = "vector.insert"(%49, %46) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b3a3c0) {
  %49 = "vector.transfer_read"(%17, %48, %arg1, %1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b3a0e0)
    ** Replace : 'vector.transfer_read'(0x3b3a3c0)
    ** Erase   : 'vector.transfer_read'(0x3b3a3c0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %50 = "vector.insert"(%49, %46) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %49 = "vector.load"(%17, %48, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %48 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b25a40) {
  %47 = "arith.constant"() {value = 7 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b25a40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %46 = "vector.insert"(%45, %42) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e2c680) {
  %45 = "vector.transfer_read"(%17, %44, %arg1, %1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b3a560)
    ** Replace : 'vector.transfer_read'(0x1e2c680)
    ** Erase   : 'vector.transfer_read'(0x1e2c680)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %46 = "vector.insert"(%45, %42) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %45 = "vector.load"(%17, %44, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %44 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %43 = "arith.constant"() {value = 6 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b2e750)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %42 = "vector.insert"(%41, %38) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x34d05a0) {
  %41 = "vector.transfer_read"(%17, %40, %arg1, %1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b3a630)
    ** Replace : 'vector.transfer_read'(0x34d05a0)
    ** Erase   : 'vector.transfer_read'(0x34d05a0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %42 = "vector.insert"(%41, %38) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %41 = "vector.load"(%17, %40, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %40 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339f260) {
  %39 = "arith.constant"() {value = 5 : index} : () -> index

  ** Erase   : 'arith.constant'(0x339f260)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %38 = "vector.insert"(%37, %34) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x1e39900) {
  %37 = "vector.transfer_read"(%17, %36, %arg1, %1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b3a700)
    ** Replace : 'vector.transfer_read'(0x1e39900)
    ** Erase   : 'vector.transfer_read'(0x1e39900)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %38 = "vector.insert"(%37, %34) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %37 = "vector.load"(%17, %36, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %36 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2068300) {
  %35 = "arith.constant"() {value = 4 : index} : () -> index

  ** Erase   : 'arith.constant'(0x2068300)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %34 = "vector.insert"(%33, %30) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b38640) {
  %33 = "vector.transfer_read"(%17, %32, %arg1, %1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b3a7d0)
    ** Replace : 'vector.transfer_read'(0x3b38640)
    ** Erase   : 'vector.transfer_read'(0x3b38640)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %34 = "vector.insert"(%33, %30) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %33 = "vector.load"(%17, %32, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %32 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b24a00) {
  %31 = "arith.constant"() {value = 3 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b24a00)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %30 = "vector.insert"(%29, %26) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b383b0) {
  %29 = "vector.transfer_read"(%17, %28, %arg1, %1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b3a8a0)
    ** Replace : 'vector.transfer_read'(0x3b383b0)
    ** Erase   : 'vector.transfer_read'(0x3b383b0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %30 = "vector.insert"(%29, %26) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %29 = "vector.load"(%17, %28, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %28 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b1f6a0) {
  %27 = "arith.constant"() {value = 2 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b1f6a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %26 = "vector.insert"(%25, %22) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b37910) {
  %25 = "vector.transfer_read"(%17, %24, %arg1, %1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b3a970)
    ** Replace : 'vector.transfer_read'(0x3b37910)
    ** Erase   : 'vector.transfer_read'(0x3b37910)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %26 = "vector.insert"(%25, %22) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %25 = "vector.load"(%17, %24, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b1f7f0) {
  %23 = "arith.constant"() {value = 1 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b1f7f0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %22 = "vector.insert"(%21, %18) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transfer_read'(0x3b36e70) {
  %21 = "vector.transfer_read"(%17, %20, %arg1, %1) {in_bounds = [true], operand_segment_sizes = array<i32: 1, 2, 1, 0>, permutation_map = affine_map<(d0, d1) -> (d1)>} : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index, f32) -> vector<32xf32>


  * Pattern TransferReadPermutationLowering : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferOpReduceRank : 'vector.transfer_read -> ()' {
  } -> failure : pattern failed to match

  * Pattern TransferReadToVectorLoadLowering : 'vector.transfer_read -> ()' {
    ** Insert  : 'vector.load'(0x3b37910)
    ** Replace : 'vector.transfer_read'(0x3b36e70)
    ** Erase   : 'vector.transfer_read'(0x3b36e70)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %22 = "vector.insert"(%21, %18) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %21 = "vector.load"(%17, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2ac20) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0)>} : (index) -> index

  ** Erase   : 'affine.apply'(0x3b2ac20)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %20 = "vector.load"(%17, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b1f9d0) {
  %19 = "arith.constant"() {value = 0 : index} : () -> index

  ** Erase   : 'arith.constant'(0x3b1f9d0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.splat'(0x3b1fb00) {
  %18 = "vector.splat"(%1) : (f32) -> vector<8x32xf32>

  ** Erase   : 'vector.splat'(0x3b1fb00)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %20 = "vector.insert"(%19, %0) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %18 = "memref.subview"(%11, %14, %15) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %17 = "memref.subview"(%10, %15) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %15 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %7 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %6 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %5 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %4 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %3 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x34c6de0) {
  %2 = "arith.constant"() {value = 0.000000e+00 : f32} : () -> f32

  ** Erase   : 'arith.constant'(0x34c6de0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%56, %17, %55, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %56 = "vector.extract"(%41) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a3a0) {
  %55 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%54, %17, %53, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %54 = "vector.extract"(%41) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2d4c0) {
  %53 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%52, %17, %51, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %52 = "vector.extract"(%41) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2d3a0) {
  %51 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%50, %17, %49, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %50 = "vector.extract"(%41) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2d1b0) {
  %49 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%48, %17, %47, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %48 = "vector.extract"(%41) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2d600) {
  %47 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%46, %17, %45, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %46 = "vector.extract"(%41) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b264e0) {
  %45 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%44, %17, %43, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %44 = "vector.extract"(%41) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b263c0) {
  %43 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%42, %17, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %42 = "vector.extract"(%41) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%143) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %143 = "vector.outerproduct"(%142, %110, %141) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %142 = "vector.extract"(%111) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %141 = "vector.outerproduct"(%140, %108, %139) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %140 = "vector.extract"(%111) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %139 = "vector.outerproduct"(%138, %106, %137) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %138 = "vector.extract"(%111) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %137 = "vector.outerproduct"(%136, %104, %135) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %136 = "vector.extract"(%111) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %135 = "vector.outerproduct"(%134, %102, %133) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %134 = "vector.extract"(%111) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %133 = "vector.outerproduct"(%132, %100, %131) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %132 = "vector.extract"(%111) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %131 = "vector.outerproduct"(%130, %98, %129) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %130 = "vector.extract"(%111) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %129 = "vector.outerproduct"(%128, %96, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %128 = "vector.extract"(%111) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %127 = "vector.outerproduct"(%126, %94, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %126 = "vector.extract"(%111) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %125 = "vector.outerproduct"(%124, %92, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %124 = "vector.extract"(%111) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %123 = "vector.outerproduct"(%122, %90, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %122 = "vector.extract"(%111) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %121 = "vector.outerproduct"(%120, %88, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %120 = "vector.extract"(%111) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %119 = "vector.outerproduct"(%118, %86, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %118 = "vector.extract"(%111) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %117 = "vector.outerproduct"(%116, %84, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %116 = "vector.extract"(%111) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %115 = "vector.outerproduct"(%114, %82, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %114 = "vector.extract"(%111) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %113 = "vector.outerproduct"(%112, %80, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %112 = "vector.extract"(%111) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %111 = "vector.transpose"(%79) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %110 = "vector.load"(%16, %109, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %109 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %108 = "vector.load"(%16, %107, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %107 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %106 = "vector.load"(%16, %105, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %105 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %104 = "vector.load"(%16, %103, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %103 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %102 = "vector.load"(%16, %101, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %101 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %100 = "vector.load"(%16, %99, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %99 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %98 = "vector.load"(%16, %97, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %97 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %96 = "vector.load"(%16, %95, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %95 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %94 = "vector.load"(%16, %93, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %93 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %92 = "vector.load"(%16, %91, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %91 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %90 = "vector.load"(%16, %89, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %89 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %88 = "vector.load"(%16, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %86 = "vector.load"(%16, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %84 = "vector.load"(%16, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %82 = "vector.load"(%16, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %80 = "vector.load"(%16, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3394240) {
  %79 = "vector.insert"(%78, %76) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %78 = "vector.load"(%15, %77, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2ae10) {
  %77 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b38730) {
  %76 = "vector.insert"(%75, %73) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %75 = "vector.load"(%15, %74, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bf50) {
  %74 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b384a0) {
  %73 = "vector.insert"(%72, %70) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %72 = "vector.load"(%15, %71, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339f0f0) {
  %71 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b37a00) {
  %70 = "vector.insert"(%69, %67) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %69 = "vector.load"(%15, %68, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x34c20f0) {
  %68 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36f60) {
  %67 = "vector.insert"(%66, %64) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %66 = "vector.load"(%15, %65, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x34bac20) {
  %65 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36d30) {
  %64 = "vector.insert"(%63, %61) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %63 = "vector.load"(%15, %62, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b22840) {
  %62 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36b00) {
  %61 = "vector.insert"(%60, %58) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %60 = "vector.load"(%15, %59, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b22a30) {
  %59 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cce0) {
  %58 = "vector.insert"(%57, %1) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %57 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %40 = "vector.insert"(%39, %37) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %39 = "vector.load"(%17, %38, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %38 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %37 = "vector.insert"(%36, %34) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %36 = "vector.load"(%17, %35, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %35 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %34 = "vector.insert"(%33, %31) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %33 = "vector.load"(%17, %32, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %32 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %31 = "vector.insert"(%30, %28) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %30 = "vector.load"(%17, %29, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %29 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %28 = "vector.insert"(%27, %25) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %27 = "vector.load"(%17, %26, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %26 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %25 = "vector.insert"(%24, %22) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %24 = "vector.load"(%17, %23, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %22 = "vector.insert"(%21, %19) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %21 = "vector.load"(%17, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %19 = "vector.insert"(%18, %0) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %18 = "vector.load"(%17, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %17 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2069e90) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyLowerVectorsPass (iree-linalg-strategy-lower-vectors-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %5 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %6 = vector.insert %5, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %7 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
      %8 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %9 = vector.insert %8, %6 [1] : vector<32xf32> into vector<8x32xf32>
      %10 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
      %11 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %12 = vector.insert %11, %9 [2] : vector<32xf32> into vector<8x32xf32>
      %13 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
      %14 = vector.load %subview_2[%13, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %12 [3] : vector<32xf32> into vector<8x32xf32>
      %16 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
      %17 = vector.load %subview_2[%16, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %18 = vector.insert %17, %15 [4] : vector<32xf32> into vector<8x32xf32>
      %19 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
      %20 = vector.load %subview_2[%19, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %18 [5] : vector<32xf32> into vector<8x32xf32>
      %22 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
      %23 = vector.load %subview_2[%22, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %24 = vector.insert %23, %21 [6] : vector<32xf32> into vector<8x32xf32>
      %25 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
      %26 = vector.load %subview_2[%25, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %24 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %44 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %45 = vector.insert %44, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %46 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
        %47 = vector.load %subview[%46, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %45 [1] : vector<16xf32> into vector<8x16xf32>
        %49 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
        %50 = vector.load %subview[%49, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %51 = vector.insert %50, %48 [2] : vector<16xf32> into vector<8x16xf32>
        %52 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
        %53 = vector.load %subview[%52, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %54 = vector.insert %53, %51 [3] : vector<16xf32> into vector<8x16xf32>
        %55 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
        %56 = vector.load %subview[%55, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %57 = vector.insert %56, %54 [4] : vector<16xf32> into vector<8x16xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
        %59 = vector.load %subview[%58, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %60 = vector.insert %59, %57 [5] : vector<16xf32> into vector<8x16xf32>
        %61 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
        %62 = vector.load %subview[%61, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %63 = vector.insert %62, %60 [6] : vector<16xf32> into vector<8x16xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
        %65 = vector.load %subview[%64, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %66 = vector.insert %65, %63 [7] : vector<16xf32> into vector<8x16xf32>
        %67 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %85 = vector.load %subview_1[%84, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %86 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %87 = vector.load %subview_1[%86, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %88 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %89 = vector.load %subview_1[%88, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %90 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %91 = vector.load %subview_1[%90, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %92 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %93 = vector.load %subview_1[%92, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %94 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %95 = vector.load %subview_1[%94, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %96 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %97 = vector.load %subview_1[%96, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %98 = vector.transpose %66, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %99 = vector.extract %98[0] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %67, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %98[1] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %69, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %98[2] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %71, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %98[3] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %73, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %98[4] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %75, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %98[5] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %77, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %98[6] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %79, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %98[7] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %81, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %98[8] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %83, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %117 = vector.extract %98[9] : vector<16x8xf32>
        %118 = vector.outerproduct %117, %85, %116 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %119 = vector.extract %98[10] : vector<16x8xf32>
        %120 = vector.outerproduct %119, %87, %118 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %121 = vector.extract %98[11] : vector<16x8xf32>
        %122 = vector.outerproduct %121, %89, %120 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %123 = vector.extract %98[12] : vector<16x8xf32>
        %124 = vector.outerproduct %123, %91, %122 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %125 = vector.extract %98[13] : vector<16x8xf32>
        %126 = vector.outerproduct %125, %93, %124 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %127 = vector.extract %98[14] : vector<16x8xf32>
        %128 = vector.outerproduct %127, %95, %126 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %129 = vector.extract %98[15] : vector<16x8xf32>
        %130 = vector.outerproduct %129, %97, %128 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %130 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
      %31 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %31, %subview_2[%30, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
      %33 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %33, %subview_2[%32, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
      %35 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %35, %subview_2[%34, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
      %37 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %37, %subview_2[%36, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %38 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
      %39 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %39, %subview_2[%38, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %40 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
      %41 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %41, %subview_2[%40, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %42 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
      %43 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %43, %subview_2[%42, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%56, %17, %55, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %56 = "vector.extract"(%41) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a3a0) {
  %55 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%54, %17, %53, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %54 = "vector.extract"(%41) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2d4c0) {
  %53 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%52, %17, %51, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %52 = "vector.extract"(%41) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2d3a0) {
  %51 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%50, %17, %49, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %50 = "vector.extract"(%41) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2d1b0) {
  %49 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%48, %17, %47, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %48 = "vector.extract"(%41) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2d600) {
  %47 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%46, %17, %45, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %46 = "vector.extract"(%41) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b264e0) {
  %45 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%44, %17, %43, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %44 = "vector.extract"(%41) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b263c0) {
  %43 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%42, %17, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %42 = "vector.extract"(%41) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%143) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %143 = "vector.outerproduct"(%142, %110, %141) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %142 = "vector.extract"(%111) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %141 = "vector.outerproduct"(%140, %108, %139) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %140 = "vector.extract"(%111) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %139 = "vector.outerproduct"(%138, %106, %137) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %138 = "vector.extract"(%111) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %137 = "vector.outerproduct"(%136, %104, %135) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %136 = "vector.extract"(%111) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %135 = "vector.outerproduct"(%134, %102, %133) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %134 = "vector.extract"(%111) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %133 = "vector.outerproduct"(%132, %100, %131) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %132 = "vector.extract"(%111) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %131 = "vector.outerproduct"(%130, %98, %129) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %130 = "vector.extract"(%111) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %129 = "vector.outerproduct"(%128, %96, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %128 = "vector.extract"(%111) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %127 = "vector.outerproduct"(%126, %94, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %126 = "vector.extract"(%111) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %125 = "vector.outerproduct"(%124, %92, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %124 = "vector.extract"(%111) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %123 = "vector.outerproduct"(%122, %90, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %122 = "vector.extract"(%111) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %121 = "vector.outerproduct"(%120, %88, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %120 = "vector.extract"(%111) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %119 = "vector.outerproduct"(%118, %86, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %118 = "vector.extract"(%111) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %117 = "vector.outerproduct"(%116, %84, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %116 = "vector.extract"(%111) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %115 = "vector.outerproduct"(%114, %82, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %114 = "vector.extract"(%111) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %113 = "vector.outerproduct"(%112, %80, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %112 = "vector.extract"(%111) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %111 = "vector.transpose"(%79) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %110 = "vector.load"(%16, %109, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %109 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %108 = "vector.load"(%16, %107, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %107 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %106 = "vector.load"(%16, %105, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %105 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %104 = "vector.load"(%16, %103, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %103 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %102 = "vector.load"(%16, %101, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %101 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %100 = "vector.load"(%16, %99, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %99 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %98 = "vector.load"(%16, %97, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %97 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %96 = "vector.load"(%16, %95, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %95 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %94 = "vector.load"(%16, %93, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %93 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %92 = "vector.load"(%16, %91, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %91 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %90 = "vector.load"(%16, %89, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %89 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %88 = "vector.load"(%16, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %86 = "vector.load"(%16, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %84 = "vector.load"(%16, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %82 = "vector.load"(%16, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %80 = "vector.load"(%16, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3394240) {
  %79 = "vector.insert"(%78, %76) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %78 = "vector.load"(%15, %77, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2ae10) {
  %77 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b38730) {
  %76 = "vector.insert"(%75, %73) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %75 = "vector.load"(%15, %74, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bf50) {
  %74 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b384a0) {
  %73 = "vector.insert"(%72, %70) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %72 = "vector.load"(%15, %71, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339f0f0) {
  %71 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b37a00) {
  %70 = "vector.insert"(%69, %67) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %69 = "vector.load"(%15, %68, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x34c20f0) {
  %68 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36f60) {
  %67 = "vector.insert"(%66, %64) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %66 = "vector.load"(%15, %65, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x34bac20) {
  %65 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36d30) {
  %64 = "vector.insert"(%63, %61) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %63 = "vector.load"(%15, %62, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b22840) {
  %62 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36b00) {
  %61 = "vector.insert"(%60, %58) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %60 = "vector.load"(%15, %59, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b22a30) {
  %59 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cce0) {
  %58 = "vector.insert"(%57, %1) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %57 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %40 = "vector.insert"(%39, %37) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %39 = "vector.load"(%17, %38, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %38 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %37 = "vector.insert"(%36, %34) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %36 = "vector.load"(%17, %35, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %35 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %34 = "vector.insert"(%33, %31) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %33 = "vector.load"(%17, %32, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %32 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %31 = "vector.insert"(%30, %28) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %30 = "vector.load"(%17, %29, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %29 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %28 = "vector.insert"(%27, %25) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %27 = "vector.load"(%17, %26, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %26 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %25 = "vector.insert"(%24, %22) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %24 = "vector.load"(%17, %23, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %22 = "vector.insert"(%21, %19) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %21 = "vector.load"(%17, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %19 = "vector.insert"(%18, %0) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %18 = "vector.load"(%17, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %17 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2069e90) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.transpose %52, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %85 = vector.extract %84[0] : vector<16x8xf32>
        %86 = vector.outerproduct %85, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.extract %84[1] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %55, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %84[2] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %57, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %84[3] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %59, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %84[4] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %61, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %84[5] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %63, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %84[6] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %65, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %84[7] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %67, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %84[8] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %69, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %84[9] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %71, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %84[10] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %73, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %84[11] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %75, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %84[12] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %77, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %84[13] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %79, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %84[14] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %81, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %84[15] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %83, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.transpose %52, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %85 = vector.extract %84[0] : vector<16x8xf32>
        %86 = vector.outerproduct %85, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.extract %84[1] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %55, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %84[2] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %57, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %84[3] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %59, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %84[4] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %61, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %84[5] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %63, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %84[6] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %65, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %84[7] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %67, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %84[8] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %69, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %84[9] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %71, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %84[10] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %73, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %84[11] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %75, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %84[12] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %77, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %84[13] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %79, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %84[14] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %81, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %84[15] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %83, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.transpose %52, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %85 = vector.extract %84[0] : vector<16x8xf32>
        %86 = vector.outerproduct %85, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.extract %84[1] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %55, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %84[2] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %57, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %84[3] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %59, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %84[4] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %61, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %84[5] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %63, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %84[6] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %65, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %84[7] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %67, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %84[8] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %69, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %84[9] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %71, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %84[10] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %73, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %84[11] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %75, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %84[12] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %77, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %84[13] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %79, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %84[14] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %81, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %84[15] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %83, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%49, %17, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %49 = "vector.extract"(%41) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%48, %17, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %48 = "vector.extract"(%41) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%47, %17, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %47 = "vector.extract"(%41) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%46, %17, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %46 = "vector.extract"(%41) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%45, %17, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %45 = "vector.extract"(%41) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%44, %17, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %44 = "vector.extract"(%41) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%43, %17, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %43 = "vector.extract"(%41) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%42, %17, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %42 = "vector.extract"(%41) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%129) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %129 = "vector.outerproduct"(%128, %96, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %128 = "vector.extract"(%97) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %127 = "vector.outerproduct"(%126, %94, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %126 = "vector.extract"(%97) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %125 = "vector.outerproduct"(%124, %92, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %124 = "vector.extract"(%97) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %123 = "vector.outerproduct"(%122, %90, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %122 = "vector.extract"(%97) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %121 = "vector.outerproduct"(%120, %88, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %120 = "vector.extract"(%97) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %119 = "vector.outerproduct"(%118, %86, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %118 = "vector.extract"(%97) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %117 = "vector.outerproduct"(%116, %84, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %116 = "vector.extract"(%97) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %115 = "vector.outerproduct"(%114, %82, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %114 = "vector.extract"(%97) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %113 = "vector.outerproduct"(%112, %80, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %112 = "vector.extract"(%97) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %111 = "vector.outerproduct"(%110, %78, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %110 = "vector.extract"(%97) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %109 = "vector.outerproduct"(%108, %76, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %108 = "vector.extract"(%97) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %107 = "vector.outerproduct"(%106, %74, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %106 = "vector.extract"(%97) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %105 = "vector.outerproduct"(%104, %72, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %104 = "vector.extract"(%97) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %103 = "vector.outerproduct"(%102, %70, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %102 = "vector.extract"(%97) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %101 = "vector.outerproduct"(%100, %68, %99) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %100 = "vector.extract"(%97) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %99 = "vector.outerproduct"(%98, %66, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %98 = "vector.extract"(%97) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %97 = "vector.transpose"(%65) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %96 = "vector.load"(%16, %95, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %95 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %94 = "vector.load"(%16, %93, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %93 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %92 = "vector.load"(%16, %91, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %91 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %90 = "vector.load"(%16, %89, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %89 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %88 = "vector.load"(%16, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %86 = "vector.load"(%16, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %84 = "vector.load"(%16, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %82 = "vector.load"(%16, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %80 = "vector.load"(%16, %79, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %79 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %78 = "vector.load"(%16, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %76 = "vector.load"(%16, %75, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %75 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %74 = "vector.load"(%16, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %72 = "vector.load"(%16, %71, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %71 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %70 = "vector.load"(%16, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %68 = "vector.load"(%16, %67, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %67 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %66 = "vector.load"(%16, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3394240) {
  %65 = "vector.insert"(%64, %63) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %64 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b38730) {
  %63 = "vector.insert"(%62, %61) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %62 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b384a0) {
  %61 = "vector.insert"(%60, %59) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %60 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b37a00) {
  %59 = "vector.insert"(%58, %57) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %58 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36f60) {
  %57 = "vector.insert"(%56, %55) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %56 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36d30) {
  %55 = "vector.insert"(%54, %53) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %54 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36b00) {
  %53 = "vector.insert"(%52, %51) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %52 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cce0) {
  %51 = "vector.insert"(%50, %1) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %50 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %40 = "vector.insert"(%39, %38) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %39 = "vector.load"(%17, %24, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %38 = "vector.insert"(%37, %36) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %37 = "vector.load"(%17, %23, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %36 = "vector.insert"(%35, %34) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %35 = "vector.load"(%17, %22, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %34 = "vector.insert"(%33, %32) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %33 = "vector.load"(%17, %21, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %32 = "vector.insert"(%31, %30) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %31 = "vector.load"(%17, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %30 = "vector.insert"(%29, %28) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %29 = "vector.load"(%17, %19, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %28 = "vector.insert"(%27, %26) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %27 = "vector.load"(%17, %18, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %26 = "vector.insert"(%25, %0) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %25 = "vector.load"(%17, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %17 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2069e90) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.transpose %52, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %85 = vector.extract %84[0] : vector<16x8xf32>
        %86 = vector.outerproduct %85, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.extract %84[1] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %55, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %84[2] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %57, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %84[3] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %59, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %84[4] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %61, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %84[5] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %63, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %84[6] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %65, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %84[7] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %67, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %84[8] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %69, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %84[9] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %71, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %84[10] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %73, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %84[11] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %75, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %84[12] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %77, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %84[13] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %79, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %84[14] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %81, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %84[15] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %83, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.transpose %52, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %85 = vector.extract %84[0] : vector<16x8xf32>
        %86 = vector.outerproduct %85, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.extract %84[1] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %55, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %84[2] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %57, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %84[3] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %59, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %84[4] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %61, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %84[5] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %63, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %84[6] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %65, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %84[7] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %67, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %84[8] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %69, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %84[9] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %71, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %84[10] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %73, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %84[11] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %75, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %84[12] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %77, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %84[13] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %79, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %84[14] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %81, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %84[15] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %83, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgVectorLowering (linalg-vector-lowering) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.transpose %52, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %85 = vector.extract %84[0] : vector<16x8xf32>
        %86 = vector.outerproduct %85, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.extract %84[1] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %55, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %84[2] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %57, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %84[3] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %59, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %84[4] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %61, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %84[5] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %63, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %84[6] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %65, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %84[7] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %67, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %84[8] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %69, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %84[9] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %71, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %84[10] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %73, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %84[11] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %75, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %84[12] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %77, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %84[13] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %79, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %84[14] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %81, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %84[15] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %83, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2069e90) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %17 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %25 = "vector.load"(%17, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %26 = "vector.insert"(%25, %0) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %27 = "vector.load"(%17, %18, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %28 = "vector.insert"(%27, %26) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %29 = "vector.load"(%17, %19, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %30 = "vector.insert"(%29, %28) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %31 = "vector.load"(%17, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %32 = "vector.insert"(%31, %30) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %33 = "vector.load"(%17, %21, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %34 = "vector.insert"(%33, %32) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %35 = "vector.load"(%17, %22, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %36 = "vector.insert"(%35, %34) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %37 = "vector.load"(%17, %23, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %38 = "vector.insert"(%37, %36) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %39 = "vector.load"(%17, %24, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %40 = "vector.insert"(%39, %38) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %50 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cce0) {
  %51 = "vector.insert"(%50, %1) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %52 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36b00) {
  %53 = "vector.insert"(%52, %51) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %54 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36d30) {
  %55 = "vector.insert"(%54, %53) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %56 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36f60) {
  %57 = "vector.insert"(%56, %55) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %58 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b37a00) {
  %59 = "vector.insert"(%58, %57) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %60 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b384a0) {
  %61 = "vector.insert"(%60, %59) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %62 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b38730) {
  %63 = "vector.insert"(%62, %61) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %64 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3394240) {
  %65 = "vector.insert"(%64, %63) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %66 = "vector.load"(%16, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %67 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %68 = "vector.load"(%16, %67, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %70 = "vector.load"(%16, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %71 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %72 = "vector.load"(%16, %71, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %74 = "vector.load"(%16, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %75 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %76 = "vector.load"(%16, %75, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %78 = "vector.load"(%16, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %79 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %80 = "vector.load"(%16, %79, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %82 = "vector.load"(%16, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %84 = "vector.load"(%16, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %86 = "vector.load"(%16, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %88 = "vector.load"(%16, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %89 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %90 = "vector.load"(%16, %89, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %91 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %92 = "vector.load"(%16, %91, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %93 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %94 = "vector.load"(%16, %93, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %95 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %96 = "vector.load"(%16, %95, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %97 = "vector.transpose"(%65) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::FoldTransposedScalarBroadcast : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldTransposeSplat : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %98 = "vector.extract"(%97) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %99 = "vector.outerproduct"(%98, %66, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %100 = "vector.extract"(%97) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %101 = "vector.outerproduct"(%100, %68, %99) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %102 = "vector.extract"(%97) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %103 = "vector.outerproduct"(%102, %70, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %104 = "vector.extract"(%97) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %105 = "vector.outerproduct"(%104, %72, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %106 = "vector.extract"(%97) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %107 = "vector.outerproduct"(%106, %74, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %108 = "vector.extract"(%97) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %109 = "vector.outerproduct"(%108, %76, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %110 = "vector.extract"(%97) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %111 = "vector.outerproduct"(%110, %78, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %112 = "vector.extract"(%97) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %113 = "vector.outerproduct"(%112, %80, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %114 = "vector.extract"(%97) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %115 = "vector.outerproduct"(%114, %82, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %116 = "vector.extract"(%97) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %117 = "vector.outerproduct"(%116, %84, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %118 = "vector.extract"(%97) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %119 = "vector.outerproduct"(%118, %86, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %120 = "vector.extract"(%97) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %121 = "vector.outerproduct"(%120, %88, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %122 = "vector.extract"(%97) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %123 = "vector.outerproduct"(%122, %90, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %124 = "vector.extract"(%97) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %125 = "vector.outerproduct"(%124, %92, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %126 = "vector.extract"(%97) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %127 = "vector.outerproduct"(%126, %94, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %128 = "vector.extract"(%97) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %129 = "vector.outerproduct"(%128, %96, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%129) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %42 = "vector.extract"(%41) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%42, %17, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %43 = "vector.extract"(%41) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%43, %17, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %44 = "vector.extract"(%41) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%44, %17, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %45 = "vector.extract"(%41) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%45, %17, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %46 = "vector.extract"(%41) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%46, %17, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %47 = "vector.extract"(%41) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%47, %17, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %48 = "vector.extract"(%41) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%48, %17, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %49 = "vector.extract"(%41) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%49, %17, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.transpose %52, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %85 = vector.extract %84[0] : vector<16x8xf32>
        %86 = vector.outerproduct %85, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.extract %84[1] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %55, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %84[2] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %57, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %84[3] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %59, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %84[4] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %61, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %84[5] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %63, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %84[6] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %65, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %84[7] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %67, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %84[8] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %69, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %84[9] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %71, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %84[10] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %73, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %84[11] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %75, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %84[12] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %77, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %84[13] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %79, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %84[14] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %81, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %84[15] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %83, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.transpose %52, [1, 0] : vector<8x16xf32> to vector<16x8xf32>
        %85 = vector.extract %84[0] : vector<16x8xf32>
        %86 = vector.outerproduct %85, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %87 = vector.extract %84[1] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %55, %86 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %84[2] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %57, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %84[3] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %59, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %84[4] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %61, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %84[5] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %63, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %84[6] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %65, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %84[7] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %67, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %84[8] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %69, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %84[9] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %71, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %84[10] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %73, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %84[11] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %75, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %84[12] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %77, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %84[13] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %79, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %84[14] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %81, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %84[15] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %83, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%49, %17, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %49 = "vector.extract"(%41) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%48, %17, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %48 = "vector.extract"(%41) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%47, %17, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %47 = "vector.extract"(%41) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%46, %17, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %46 = "vector.extract"(%41) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%45, %17, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %45 = "vector.extract"(%41) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%44, %17, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %44 = "vector.extract"(%41) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%43, %17, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %43 = "vector.extract"(%41) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%42, %17, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %42 = "vector.extract"(%41) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%129) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %129 = "vector.outerproduct"(%128, %96, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %128 = "vector.extract"(%97) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %127 = "vector.outerproduct"(%126, %94, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %126 = "vector.extract"(%97) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %125 = "vector.outerproduct"(%124, %92, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %124 = "vector.extract"(%97) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %123 = "vector.outerproduct"(%122, %90, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %122 = "vector.extract"(%97) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %121 = "vector.outerproduct"(%120, %88, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %120 = "vector.extract"(%97) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %119 = "vector.outerproduct"(%118, %86, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %118 = "vector.extract"(%97) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %117 = "vector.outerproduct"(%116, %84, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %116 = "vector.extract"(%97) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %115 = "vector.outerproduct"(%114, %82, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %114 = "vector.extract"(%97) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %113 = "vector.outerproduct"(%112, %80, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %112 = "vector.extract"(%97) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %111 = "vector.outerproduct"(%110, %78, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %110 = "vector.extract"(%97) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %109 = "vector.outerproduct"(%108, %76, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %108 = "vector.extract"(%97) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %107 = "vector.outerproduct"(%106, %74, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %106 = "vector.extract"(%97) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %105 = "vector.outerproduct"(%104, %72, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %104 = "vector.extract"(%97) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %103 = "vector.outerproduct"(%102, %70, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %102 = "vector.extract"(%97) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %101 = "vector.outerproduct"(%100, %68, %99) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %100 = "vector.extract"(%97) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %99 = "vector.outerproduct"(%98, %66, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %98 = "vector.extract"(%97) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.transpose'(0x2e8bf80) {
  %97 = "vector.transpose"(%65) {transp = [1, 0]} : (vector<8x16xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::TransposeFolder : 'vector.transpose -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransposeOpLowering : 'vector.transpose -> ()' {
    ** Failure : Options specifies lowering to shuffle
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TransposeOp2DToShuffleLowering : 'vector.transpose -> ()' {
    ** Insert  : 'vector.shape_cast'(0x34c20f0)
    ** Insert  : 'vector.shuffle'(0x3b2d4c0)
    ** Insert  : 'vector.shape_cast'(0x34bac20)
    ** Replace : 'vector.transpose'(0x2e8bf80)
    ** Erase   : 'vector.transpose'(0x2e8bf80)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %100 = "vector.extract"(%99) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %102 = "vector.extract"(%99) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %104 = "vector.extract"(%99) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %106 = "vector.extract"(%99) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %108 = "vector.extract"(%99) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %110 = "vector.extract"(%99) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %112 = "vector.extract"(%99) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %114 = "vector.extract"(%99) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %116 = "vector.extract"(%99) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %118 = "vector.extract"(%99) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %120 = "vector.extract"(%99) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %122 = "vector.extract"(%99) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %124 = "vector.extract"(%99) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %126 = "vector.extract"(%99) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %128 = "vector.extract"(%99) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %130 = "vector.extract"(%99) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x34bac20) {
  %99 = "vector.shape_cast"(%98) : (vector<128xf32>) -> vector<16x8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x3b2d4c0) {
  %98 = "vector.shuffle"(%97, %97) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x34c20f0) {
  %97 = "vector.shape_cast"(%65) : (vector<8x16xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %96 = "vector.load"(%16, %95, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %95 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %94 = "vector.load"(%16, %93, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %93 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %92 = "vector.load"(%16, %91, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %91 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %90 = "vector.load"(%16, %89, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %89 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %88 = "vector.load"(%16, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %86 = "vector.load"(%16, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %84 = "vector.load"(%16, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %82 = "vector.load"(%16, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %80 = "vector.load"(%16, %79, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %79 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %78 = "vector.load"(%16, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %76 = "vector.load"(%16, %75, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %75 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %74 = "vector.load"(%16, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %72 = "vector.load"(%16, %71, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %71 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %70 = "vector.load"(%16, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %68 = "vector.load"(%16, %67, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %67 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %66 = "vector.load"(%16, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3394240) {
  %65 = "vector.insert"(%64, %63) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %64 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b38730) {
  %63 = "vector.insert"(%62, %61) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %62 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b384a0) {
  %61 = "vector.insert"(%60, %59) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %60 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b37a00) {
  %59 = "vector.insert"(%58, %57) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %58 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36f60) {
  %57 = "vector.insert"(%56, %55) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %56 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36d30) {
  %55 = "vector.insert"(%54, %53) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %54 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36b00) {
  %53 = "vector.insert"(%52, %51) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %52 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cce0) {
  %51 = "vector.insert"(%50, %1) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %50 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %40 = "vector.insert"(%39, %38) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %39 = "vector.load"(%17, %24, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %38 = "vector.insert"(%37, %36) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %37 = "vector.load"(%17, %23, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %36 = "vector.insert"(%35, %34) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %35 = "vector.load"(%17, %22, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %34 = "vector.insert"(%33, %32) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %33 = "vector.load"(%17, %21, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %32 = "vector.insert"(%31, %30) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %31 = "vector.load"(%17, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %30 = "vector.insert"(%29, %28) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %29 = "vector.load"(%17, %19, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %28 = "vector.insert"(%27, %26) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %27 = "vector.load"(%17, %18, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %26 = "vector.insert"(%25, %0) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %25 = "vector.load"(%17, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %17 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2069e90) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%49, %17, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %49 = "vector.extract"(%41) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%48, %17, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %48 = "vector.extract"(%41) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%47, %17, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %47 = "vector.extract"(%41) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%46, %17, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %46 = "vector.extract"(%41) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%45, %17, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %45 = "vector.extract"(%41) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%44, %17, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %44 = "vector.extract"(%41) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%43, %17, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %43 = "vector.extract"(%41) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%42, %17, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %42 = "vector.extract"(%41) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%131) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %131 = "vector.outerproduct"(%130, %96, %129) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %130 = "vector.extract"(%99) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %129 = "vector.outerproduct"(%128, %94, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %128 = "vector.extract"(%99) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %127 = "vector.outerproduct"(%126, %92, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %126 = "vector.extract"(%99) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %125 = "vector.outerproduct"(%124, %90, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %124 = "vector.extract"(%99) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %123 = "vector.outerproduct"(%122, %88, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %122 = "vector.extract"(%99) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %121 = "vector.outerproduct"(%120, %86, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %120 = "vector.extract"(%99) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %119 = "vector.outerproduct"(%118, %84, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %118 = "vector.extract"(%99) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %117 = "vector.outerproduct"(%116, %82, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %116 = "vector.extract"(%99) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %115 = "vector.outerproduct"(%114, %80, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %114 = "vector.extract"(%99) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %113 = "vector.outerproduct"(%112, %78, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %112 = "vector.extract"(%99) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %111 = "vector.outerproduct"(%110, %76, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %110 = "vector.extract"(%99) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %109 = "vector.outerproduct"(%108, %74, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %108 = "vector.extract"(%99) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %107 = "vector.outerproduct"(%106, %72, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %106 = "vector.extract"(%99) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %105 = "vector.outerproduct"(%104, %70, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %104 = "vector.extract"(%99) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %103 = "vector.outerproduct"(%102, %68, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %102 = "vector.extract"(%99) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %101 = "vector.outerproduct"(%100, %66, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %100 = "vector.extract"(%99) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x34bac20) {
  %99 = "vector.shape_cast"(%98) : (vector<128xf32>) -> vector<16x8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x3b2d4c0) {
  %98 = "vector.shuffle"(%97, %97) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x34c20f0) {
  %97 = "vector.shape_cast"(%65) : (vector<8x16xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %96 = "vector.load"(%16, %95, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %95 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %94 = "vector.load"(%16, %93, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %93 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %92 = "vector.load"(%16, %91, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %91 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %90 = "vector.load"(%16, %89, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %89 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %88 = "vector.load"(%16, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %86 = "vector.load"(%16, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %84 = "vector.load"(%16, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %82 = "vector.load"(%16, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %80 = "vector.load"(%16, %79, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %79 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %78 = "vector.load"(%16, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %76 = "vector.load"(%16, %75, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %75 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %74 = "vector.load"(%16, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %72 = "vector.load"(%16, %71, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %71 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %70 = "vector.load"(%16, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %68 = "vector.load"(%16, %67, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %67 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %66 = "vector.load"(%16, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3394240) {
  %65 = "vector.insert"(%64, %63) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %64 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b38730) {
  %63 = "vector.insert"(%62, %61) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %62 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b384a0) {
  %61 = "vector.insert"(%60, %59) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %60 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b37a00) {
  %59 = "vector.insert"(%58, %57) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %58 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36f60) {
  %57 = "vector.insert"(%56, %55) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %56 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36d30) {
  %55 = "vector.insert"(%54, %53) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %54 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36b00) {
  %53 = "vector.insert"(%52, %51) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %52 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cce0) {
  %51 = "vector.insert"(%50, %1) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %50 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %40 = "vector.insert"(%39, %38) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %39 = "vector.load"(%17, %24, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %38 = "vector.insert"(%37, %36) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %37 = "vector.load"(%17, %23, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %36 = "vector.insert"(%35, %34) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %35 = "vector.load"(%17, %22, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %34 = "vector.insert"(%33, %32) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %33 = "vector.load"(%17, %21, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %32 = "vector.insert"(%31, %30) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %31 = "vector.load"(%17, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %30 = "vector.insert"(%29, %28) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %29 = "vector.load"(%17, %19, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %28 = "vector.insert"(%27, %26) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %27 = "vector.load"(%17, %18, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %26 = "vector.insert"(%25, %0) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %25 = "vector.load"(%17, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %17 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2069e90) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyLowerVectorsPass (iree-linalg-strategy-lower-vectors-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.shape_cast %52 : vector<8x16xf32> to vector<128xf32>
        %85 = vector.shuffle %84, %84 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %86 = vector.shape_cast %85 : vector<128xf32> to vector<16x8xf32>
        %87 = vector.extract %86[0] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %86[1] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %55, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %86[2] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %57, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %86[3] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %59, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %86[4] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %61, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %86[5] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %63, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %86[6] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %65, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %86[7] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %67, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %86[8] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %69, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %86[9] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %71, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %86[10] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %73, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %86[11] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %75, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %86[12] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %77, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %86[13] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %79, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %86[14] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %81, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %117 = vector.extract %86[15] : vector<16x8xf32>
        %118 = vector.outerproduct %117, %83, %116 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %118 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%49, %17, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %49 = "vector.extract"(%41) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%48, %17, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %48 = "vector.extract"(%41) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%47, %17, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %47 = "vector.extract"(%41) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%46, %17, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %46 = "vector.extract"(%41) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%45, %17, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %45 = "vector.extract"(%41) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%44, %17, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %44 = "vector.extract"(%41) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%43, %17, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %43 = "vector.extract"(%41) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%42, %17, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %42 = "vector.extract"(%41) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%131) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %131 = "vector.outerproduct"(%130, %96, %129) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %130 = "vector.extract"(%99) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %129 = "vector.outerproduct"(%128, %94, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %128 = "vector.extract"(%99) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %127 = "vector.outerproduct"(%126, %92, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %126 = "vector.extract"(%99) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %125 = "vector.outerproduct"(%124, %90, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %124 = "vector.extract"(%99) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %123 = "vector.outerproduct"(%122, %88, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %122 = "vector.extract"(%99) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %121 = "vector.outerproduct"(%120, %86, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %120 = "vector.extract"(%99) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %119 = "vector.outerproduct"(%118, %84, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %118 = "vector.extract"(%99) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %117 = "vector.outerproduct"(%116, %82, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %116 = "vector.extract"(%99) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %115 = "vector.outerproduct"(%114, %80, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %114 = "vector.extract"(%99) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %113 = "vector.outerproduct"(%112, %78, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %112 = "vector.extract"(%99) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %111 = "vector.outerproduct"(%110, %76, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %110 = "vector.extract"(%99) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %109 = "vector.outerproduct"(%108, %74, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %108 = "vector.extract"(%99) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %107 = "vector.outerproduct"(%106, %72, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %106 = "vector.extract"(%99) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %105 = "vector.outerproduct"(%104, %70, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %104 = "vector.extract"(%99) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %103 = "vector.outerproduct"(%102, %68, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %102 = "vector.extract"(%99) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %101 = "vector.outerproduct"(%100, %66, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %100 = "vector.extract"(%99) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x34bac20) {
  %99 = "vector.shape_cast"(%98) : (vector<128xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x3b2d4c0) {
  %98 = "vector.shuffle"(%97, %97) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x34c20f0) {
  %97 = "vector.shape_cast"(%65) : (vector<8x16xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %96 = "vector.load"(%16, %95, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %95 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %94 = "vector.load"(%16, %93, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %93 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %92 = "vector.load"(%16, %91, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %91 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %90 = "vector.load"(%16, %89, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %89 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %88 = "vector.load"(%16, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %86 = "vector.load"(%16, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %84 = "vector.load"(%16, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %82 = "vector.load"(%16, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %80 = "vector.load"(%16, %79, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %79 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %78 = "vector.load"(%16, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %76 = "vector.load"(%16, %75, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %75 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %74 = "vector.load"(%16, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %72 = "vector.load"(%16, %71, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %71 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %70 = "vector.load"(%16, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %68 = "vector.load"(%16, %67, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %67 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %66 = "vector.load"(%16, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3394240) {
  %65 = "vector.insert"(%64, %63) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %64 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b38730) {
  %63 = "vector.insert"(%62, %61) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %62 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b384a0) {
  %61 = "vector.insert"(%60, %59) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %60 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b37a00) {
  %59 = "vector.insert"(%58, %57) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %58 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36f60) {
  %57 = "vector.insert"(%56, %55) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %56 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36d30) {
  %55 = "vector.insert"(%54, %53) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %54 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36b00) {
  %53 = "vector.insert"(%52, %51) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %52 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cce0) {
  %51 = "vector.insert"(%50, %1) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %50 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %40 = "vector.insert"(%39, %38) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %39 = "vector.load"(%17, %24, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %38 = "vector.insert"(%37, %36) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %37 = "vector.load"(%17, %23, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %36 = "vector.insert"(%35, %34) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %35 = "vector.load"(%17, %22, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %34 = "vector.insert"(%33, %32) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %33 = "vector.load"(%17, %21, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %32 = "vector.insert"(%31, %30) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %31 = "vector.load"(%17, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %30 = "vector.insert"(%29, %28) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %29 = "vector.load"(%17, %19, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %28 = "vector.insert"(%27, %26) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %27 = "vector.load"(%17, %18, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %26 = "vector.insert"(%25, %0) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %25 = "vector.load"(%17, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %17 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2069e90) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.shape_cast %52 : vector<8x16xf32> to vector<128xf32>
        %85 = vector.shuffle %84, %84 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %86 = vector.shape_cast %85 : vector<128xf32> to vector<16x8xf32>
        %87 = vector.extract %86[0] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %86[1] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %55, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %86[2] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %57, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %86[3] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %59, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %86[4] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %61, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %86[5] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %63, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %86[6] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %65, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %86[7] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %67, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %86[8] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %69, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %86[9] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %71, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %86[10] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %73, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %86[11] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %75, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %86[12] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %77, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %86[13] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %79, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %86[14] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %81, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %117 = vector.extract %86[15] : vector<16x8xf32>
        %118 = vector.outerproduct %117, %83, %116 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %118 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.shape_cast %52 : vector<8x16xf32> to vector<128xf32>
        %85 = vector.shuffle %84, %84 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %86 = vector.shape_cast %85 : vector<128xf32> to vector<16x8xf32>
        %87 = vector.extract %86[0] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %86[1] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %55, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %86[2] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %57, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %86[3] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %59, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %86[4] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %61, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %86[5] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %63, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %86[6] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %65, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %86[7] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %67, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %86[8] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %69, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %86[9] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %71, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %86[10] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %73, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %86[11] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %75, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %86[12] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %77, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %86[13] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %79, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %86[14] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %81, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %117 = vector.extract %86[15] : vector<16x8xf32>
        %118 = vector.outerproduct %117, %83, %116 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %118 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.shape_cast %52 : vector<8x16xf32> to vector<128xf32>
        %85 = vector.shuffle %84, %84 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %86 = vector.shape_cast %85 : vector<128xf32> to vector<16x8xf32>
        %87 = vector.extract %86[0] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %86[1] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %55, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %86[2] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %57, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %86[3] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %59, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %86[4] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %61, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %86[5] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %63, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %86[6] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %65, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %86[7] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %67, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %86[8] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %69, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %86[9] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %71, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %86[10] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %73, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %86[11] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %75, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %86[12] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %77, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %86[13] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %79, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %86[14] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %81, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %117 = vector.extract %86[15] : vector<16x8xf32>
        %118 = vector.outerproduct %117, %83, %116 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %118 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%49, %17, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %49 = "vector.extract"(%41) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%48, %17, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %48 = "vector.extract"(%41) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%47, %17, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %47 = "vector.extract"(%41) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%46, %17, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %46 = "vector.extract"(%41) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%45, %17, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %45 = "vector.extract"(%41) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%44, %17, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %44 = "vector.extract"(%41) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%43, %17, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %43 = "vector.extract"(%41) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%42, %17, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %42 = "vector.extract"(%41) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%131) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %131 = "vector.outerproduct"(%130, %96, %129) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %130 = "vector.extract"(%99) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %129 = "vector.outerproduct"(%128, %94, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %128 = "vector.extract"(%99) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %127 = "vector.outerproduct"(%126, %92, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %126 = "vector.extract"(%99) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %125 = "vector.outerproduct"(%124, %90, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %124 = "vector.extract"(%99) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %123 = "vector.outerproduct"(%122, %88, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %122 = "vector.extract"(%99) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %121 = "vector.outerproduct"(%120, %86, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %120 = "vector.extract"(%99) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %119 = "vector.outerproduct"(%118, %84, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %118 = "vector.extract"(%99) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %117 = "vector.outerproduct"(%116, %82, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %116 = "vector.extract"(%99) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %115 = "vector.outerproduct"(%114, %80, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %114 = "vector.extract"(%99) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %113 = "vector.outerproduct"(%112, %78, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %112 = "vector.extract"(%99) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %111 = "vector.outerproduct"(%110, %76, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %110 = "vector.extract"(%99) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %109 = "vector.outerproduct"(%108, %74, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %108 = "vector.extract"(%99) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %107 = "vector.outerproduct"(%106, %72, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %106 = "vector.extract"(%99) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %105 = "vector.outerproduct"(%104, %70, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %104 = "vector.extract"(%99) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %103 = "vector.outerproduct"(%102, %68, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %102 = "vector.extract"(%99) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %101 = "vector.outerproduct"(%100, %66, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %100 = "vector.extract"(%99) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x34bac20) {
  %99 = "vector.shape_cast"(%98) : (vector<128xf32>) -> vector<16x8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x3b2d4c0) {
  %98 = "vector.shuffle"(%97, %97) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x34c20f0) {
  %97 = "vector.shape_cast"(%65) : (vector<8x16xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %96 = "vector.load"(%16, %95, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %95 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %94 = "vector.load"(%16, %93, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %93 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %92 = "vector.load"(%16, %91, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %91 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %90 = "vector.load"(%16, %89, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %89 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %88 = "vector.load"(%16, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %86 = "vector.load"(%16, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %84 = "vector.load"(%16, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %82 = "vector.load"(%16, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %80 = "vector.load"(%16, %79, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %79 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %78 = "vector.load"(%16, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %76 = "vector.load"(%16, %75, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %75 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %74 = "vector.load"(%16, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %72 = "vector.load"(%16, %71, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %71 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %70 = "vector.load"(%16, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %68 = "vector.load"(%16, %67, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %67 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %66 = "vector.load"(%16, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3394240) {
  %65 = "vector.insert"(%64, %63) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %64 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b38730) {
  %63 = "vector.insert"(%62, %61) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %62 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b384a0) {
  %61 = "vector.insert"(%60, %59) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %60 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b37a00) {
  %59 = "vector.insert"(%58, %57) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %58 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36f60) {
  %57 = "vector.insert"(%56, %55) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %56 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36d30) {
  %55 = "vector.insert"(%54, %53) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %54 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36b00) {
  %53 = "vector.insert"(%52, %51) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %52 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cce0) {
  %51 = "vector.insert"(%50, %1) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %50 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %40 = "vector.insert"(%39, %38) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %39 = "vector.load"(%17, %24, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %38 = "vector.insert"(%37, %36) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %37 = "vector.load"(%17, %23, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %36 = "vector.insert"(%35, %34) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %35 = "vector.load"(%17, %22, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %34 = "vector.insert"(%33, %32) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %33 = "vector.load"(%17, %21, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %32 = "vector.insert"(%31, %30) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %31 = "vector.load"(%17, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %30 = "vector.insert"(%29, %28) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %29 = "vector.load"(%17, %19, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %28 = "vector.insert"(%27, %26) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %27 = "vector.load"(%17, %18, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %26 = "vector.insert"(%25, %0) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %25 = "vector.load"(%17, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %17 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2069e90) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.shape_cast %52 : vector<8x16xf32> to vector<128xf32>
        %85 = vector.shuffle %84, %84 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %86 = vector.shape_cast %85 : vector<128xf32> to vector<16x8xf32>
        %87 = vector.extract %86[0] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %86[1] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %55, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %86[2] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %57, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %86[3] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %59, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %86[4] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %61, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %86[5] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %63, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %86[6] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %65, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %86[7] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %67, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %86[8] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %69, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %86[9] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %71, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %86[10] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %73, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %86[11] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %75, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %86[12] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %77, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %86[13] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %79, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %86[14] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %81, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %117 = vector.extract %86[15] : vector<16x8xf32>
        %118 = vector.outerproduct %117, %83, %116 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %118 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.shape_cast %52 : vector<8x16xf32> to vector<128xf32>
        %85 = vector.shuffle %84, %84 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %86 = vector.shape_cast %85 : vector<128xf32> to vector<16x8xf32>
        %87 = vector.extract %86[0] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %86[1] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %55, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %86[2] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %57, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %86[3] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %59, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %86[4] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %61, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %86[5] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %63, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %86[6] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %65, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %86[7] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %67, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %86[8] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %69, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %86[9] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %71, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %86[10] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %73, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %86[11] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %75, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %86[12] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %77, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %86[13] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %79, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %86[14] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %81, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %117 = vector.extract %86[15] : vector<16x8xf32>
        %118 = vector.outerproduct %117, %83, %116 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %118 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgVectorLowering (linalg-vector-lowering) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.shape_cast %52 : vector<8x16xf32> to vector<128xf32>
        %85 = vector.shuffle %84, %84 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %86 = vector.shape_cast %85 : vector<128xf32> to vector<16x8xf32>
        %87 = vector.extract %86[0] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %86[1] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %55, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %86[2] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %57, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %86[3] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %59, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %86[4] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %61, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %86[5] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %63, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %86[6] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %65, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %86[7] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %67, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %86[8] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %69, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %86[9] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %71, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %86[10] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %73, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %86[11] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %75, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %86[12] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %77, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %86[13] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %79, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %86[14] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %81, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %117 = vector.extract %86[15] : vector<16x8xf32>
        %118 = vector.outerproduct %117, %83, %116 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %118 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2069e90) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %17 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %25 = "vector.load"(%17, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %26 = "vector.insert"(%25, %0) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %27 = "vector.load"(%17, %18, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %28 = "vector.insert"(%27, %26) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %29 = "vector.load"(%17, %19, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %30 = "vector.insert"(%29, %28) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %31 = "vector.load"(%17, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %32 = "vector.insert"(%31, %30) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %33 = "vector.load"(%17, %21, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %34 = "vector.insert"(%33, %32) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %35 = "vector.load"(%17, %22, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %36 = "vector.insert"(%35, %34) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %37 = "vector.load"(%17, %23, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %38 = "vector.insert"(%37, %36) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %39 = "vector.load"(%17, %24, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %40 = "vector.insert"(%39, %38) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %50 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cce0) {
  %51 = "vector.insert"(%50, %1) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %52 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36b00) {
  %53 = "vector.insert"(%52, %51) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %54 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36d30) {
  %55 = "vector.insert"(%54, %53) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %56 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36f60) {
  %57 = "vector.insert"(%56, %55) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %58 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b37a00) {
  %59 = "vector.insert"(%58, %57) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %60 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b384a0) {
  %61 = "vector.insert"(%60, %59) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %62 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b38730) {
  %63 = "vector.insert"(%62, %61) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %64 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3394240) {
  %65 = "vector.insert"(%64, %63) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %66 = "vector.load"(%16, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %67 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %68 = "vector.load"(%16, %67, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %70 = "vector.load"(%16, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %71 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %72 = "vector.load"(%16, %71, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %74 = "vector.load"(%16, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %75 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %76 = "vector.load"(%16, %75, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %78 = "vector.load"(%16, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %79 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %80 = "vector.load"(%16, %79, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %82 = "vector.load"(%16, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %84 = "vector.load"(%16, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %86 = "vector.load"(%16, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %88 = "vector.load"(%16, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %89 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %90 = "vector.load"(%16, %89, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %91 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %92 = "vector.load"(%16, %91, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %93 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %94 = "vector.load"(%16, %93, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %95 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %96 = "vector.load"(%16, %95, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x34c20f0) {
  %97 = "vector.shape_cast"(%65) : (vector<8x16xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::ShapeCastConstantFolder : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ShapeCastBroadcastFolder : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x3b2d4c0) {
  %98 = "vector.shuffle"(%97, %97) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::ShuffleSplat : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::Canonicalize0DShuffleOp : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x34bac20) {
  %99 = "vector.shape_cast"(%98) : (vector<128xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::ShapeCastConstantFolder : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ShapeCastBroadcastFolder : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %100 = "vector.extract"(%99) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %101 = "vector.outerproduct"(%100, %66, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %102 = "vector.extract"(%99) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %103 = "vector.outerproduct"(%102, %68, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %104 = "vector.extract"(%99) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %105 = "vector.outerproduct"(%104, %70, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %106 = "vector.extract"(%99) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %107 = "vector.outerproduct"(%106, %72, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %108 = "vector.extract"(%99) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %109 = "vector.outerproduct"(%108, %74, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %110 = "vector.extract"(%99) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %111 = "vector.outerproduct"(%110, %76, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %112 = "vector.extract"(%99) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %113 = "vector.outerproduct"(%112, %78, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %114 = "vector.extract"(%99) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %115 = "vector.outerproduct"(%114, %80, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %116 = "vector.extract"(%99) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %117 = "vector.outerproduct"(%116, %82, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %118 = "vector.extract"(%99) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %119 = "vector.outerproduct"(%118, %84, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %120 = "vector.extract"(%99) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %121 = "vector.outerproduct"(%120, %86, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %122 = "vector.extract"(%99) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %123 = "vector.outerproduct"(%122, %88, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %124 = "vector.extract"(%99) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %125 = "vector.outerproduct"(%124, %90, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %126 = "vector.extract"(%99) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %127 = "vector.outerproduct"(%126, %92, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %128 = "vector.extract"(%99) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %129 = "vector.outerproduct"(%128, %94, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %130 = "vector.extract"(%99) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %131 = "vector.outerproduct"(%130, %96, %129) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%131) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %42 = "vector.extract"(%41) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%42, %17, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %43 = "vector.extract"(%41) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%43, %17, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %44 = "vector.extract"(%41) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%44, %17, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %45 = "vector.extract"(%41) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%45, %17, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %46 = "vector.extract"(%41) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%46, %17, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %47 = "vector.extract"(%41) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%47, %17, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %48 = "vector.extract"(%41) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%48, %17, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %49 = "vector.extract"(%41) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%49, %17, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.shape_cast %52 : vector<8x16xf32> to vector<128xf32>
        %85 = vector.shuffle %84, %84 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %86 = vector.shape_cast %85 : vector<128xf32> to vector<16x8xf32>
        %87 = vector.extract %86[0] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %86[1] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %55, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %86[2] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %57, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %86[3] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %59, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %86[4] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %61, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %86[5] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %63, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %86[6] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %65, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %86[7] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %67, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %86[8] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %69, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %86[9] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %71, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %86[10] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %73, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %86[11] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %75, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %86[12] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %77, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %86[13] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %79, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %86[14] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %81, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %117 = vector.extract %86[15] : vector<16x8xf32>
        %118 = vector.outerproduct %117, %83, %116 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %118 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x16xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.insert %37, %cst_0 [0] : vector<16xf32> into vector<8x16xf32>
        %39 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.insert %39, %38 [1] : vector<16xf32> into vector<8x16xf32>
        %41 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.insert %41, %40 [2] : vector<16xf32> into vector<8x16xf32>
        %43 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.insert %43, %42 [3] : vector<16xf32> into vector<8x16xf32>
        %45 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %46 = vector.insert %45, %44 [4] : vector<16xf32> into vector<8x16xf32>
        %47 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %48 = vector.insert %47, %46 [5] : vector<16xf32> into vector<8x16xf32>
        %49 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %50 = vector.insert %49, %48 [6] : vector<16xf32> into vector<8x16xf32>
        %51 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %52 = vector.insert %51, %50 [7] : vector<16xf32> into vector<8x16xf32>
        %53 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %77 = vector.load %subview_1[%76, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %78 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %79 = vector.load %subview_1[%78, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %80 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %81 = vector.load %subview_1[%80, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %82 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %83 = vector.load %subview_1[%82, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %84 = vector.shape_cast %52 : vector<8x16xf32> to vector<128xf32>
        %85 = vector.shuffle %84, %84 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %86 = vector.shape_cast %85 : vector<128xf32> to vector<16x8xf32>
        %87 = vector.extract %86[0] : vector<16x8xf32>
        %88 = vector.outerproduct %87, %53, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %89 = vector.extract %86[1] : vector<16x8xf32>
        %90 = vector.outerproduct %89, %55, %88 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %91 = vector.extract %86[2] : vector<16x8xf32>
        %92 = vector.outerproduct %91, %57, %90 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %93 = vector.extract %86[3] : vector<16x8xf32>
        %94 = vector.outerproduct %93, %59, %92 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %95 = vector.extract %86[4] : vector<16x8xf32>
        %96 = vector.outerproduct %95, %61, %94 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %97 = vector.extract %86[5] : vector<16x8xf32>
        %98 = vector.outerproduct %97, %63, %96 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %99 = vector.extract %86[6] : vector<16x8xf32>
        %100 = vector.outerproduct %99, %65, %98 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %101 = vector.extract %86[7] : vector<16x8xf32>
        %102 = vector.outerproduct %101, %67, %100 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.extract %86[8] : vector<16x8xf32>
        %104 = vector.outerproduct %103, %69, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.extract %86[9] : vector<16x8xf32>
        %106 = vector.outerproduct %105, %71, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.extract %86[10] : vector<16x8xf32>
        %108 = vector.outerproduct %107, %73, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.extract %86[11] : vector<16x8xf32>
        %110 = vector.outerproduct %109, %75, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.extract %86[12] : vector<16x8xf32>
        %112 = vector.outerproduct %111, %77, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.extract %86[13] : vector<16x8xf32>
        %114 = vector.outerproduct %113, %79, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.extract %86[14] : vector<16x8xf32>
        %116 = vector.outerproduct %115, %81, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %117 = vector.extract %86[15] : vector<16x8xf32>
        %118 = vector.outerproduct %117, %83, %116 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %118 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%49, %17, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %49 = "vector.extract"(%41) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%48, %17, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %48 = "vector.extract"(%41) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%47, %17, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %47 = "vector.extract"(%41) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%46, %17, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %46 = "vector.extract"(%41) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%45, %17, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %45 = "vector.extract"(%41) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%44, %17, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %44 = "vector.extract"(%41) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%43, %17, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %43 = "vector.extract"(%41) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%42, %17, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %42 = "vector.extract"(%41) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%131) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %131 = "vector.outerproduct"(%130, %96, %129) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %130 = "vector.extract"(%99) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %129 = "vector.outerproduct"(%128, %94, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %128 = "vector.extract"(%99) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %127 = "vector.outerproduct"(%126, %92, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %126 = "vector.extract"(%99) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %125 = "vector.outerproduct"(%124, %90, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %124 = "vector.extract"(%99) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %123 = "vector.outerproduct"(%122, %88, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %122 = "vector.extract"(%99) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %121 = "vector.outerproduct"(%120, %86, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %120 = "vector.extract"(%99) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %119 = "vector.outerproduct"(%118, %84, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %118 = "vector.extract"(%99) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %117 = "vector.outerproduct"(%116, %82, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %116 = "vector.extract"(%99) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %115 = "vector.outerproduct"(%114, %80, %113) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %114 = "vector.extract"(%99) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %113 = "vector.outerproduct"(%112, %78, %111) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %112 = "vector.extract"(%99) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %111 = "vector.outerproduct"(%110, %76, %109) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %110 = "vector.extract"(%99) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %109 = "vector.outerproduct"(%108, %74, %107) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %108 = "vector.extract"(%99) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %107 = "vector.outerproduct"(%106, %72, %105) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %106 = "vector.extract"(%99) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %105 = "vector.outerproduct"(%104, %70, %103) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %104 = "vector.extract"(%99) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %103 = "vector.outerproduct"(%102, %68, %101) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %102 = "vector.extract"(%99) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %101 = "vector.outerproduct"(%100, %66, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %100 = "vector.extract"(%99) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x34bac20) {
  %99 = "vector.shape_cast"(%98) : (vector<128xf32>) -> vector<16x8xf32>


  * Pattern (anonymous namespace)::ShapeCastOp2DDownCastRewritePattern : 'vector.shape_cast -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ShapeCastOp2DUpCastRewritePattern : 'vector.shape_cast -> ()' {
    ** Insert  : 'arith.constant'(0x3b23490)
    ** Insert  : 'vector.extract_strided_slice'(0x3b2d3a0)
    ** Insert  : 'vector.insert'(0x3b1fb00)
    ** Insert  : 'vector.extract_strided_slice'(0x2e8bf80)
    ** Insert  : 'vector.insert'(0x3b1f3e0)
    ** Insert  : 'vector.extract_strided_slice'(0x3b22840)
    ** Insert  : 'vector.insert'(0x208c2b0)
    ** Insert  : 'vector.extract_strided_slice'(0x3b22a30)
    ** Insert  : 'vector.insert'(0x208c360)
    ** Insert  : 'vector.extract_strided_slice'(0x3b2ac20)
    ** Insert  : 'vector.insert'(0x208c410)
    ** Insert  : 'vector.extract_strided_slice'(0x2068110)
    ** Insert  : 'vector.insert'(0x3b2cf50)
    ** Insert  : 'vector.extract_strided_slice'(0x3b2c3f0)
    ** Insert  : 'vector.insert'(0x3b2d000)
    ** Insert  : 'vector.extract_strided_slice'(0x3b2d0b0)
    ** Insert  : 'vector.insert'(0x3b2d140)
    ** Insert  : 'vector.extract_strided_slice'(0x3b3c730)
    ** Insert  : 'vector.insert'(0x3b3c7c0)
    ** Insert  : 'vector.extract_strided_slice'(0x3b3c870)
    ** Insert  : 'vector.insert'(0x3b3c900)
    ** Insert  : 'vector.extract_strided_slice'(0x3b3c9b0)
    ** Insert  : 'vector.insert'(0x3b3ca40)
    ** Insert  : 'vector.extract_strided_slice'(0x3b3caf0)
    ** Insert  : 'vector.insert'(0x3b3cb80)
    ** Insert  : 'vector.extract_strided_slice'(0x3b3f170)
    ** Insert  : 'vector.insert'(0x3b3f200)
    ** Insert  : 'vector.extract_strided_slice'(0x3b3f2b0)
    ** Insert  : 'vector.insert'(0x3b3f340)
    ** Insert  : 'vector.extract_strided_slice'(0x3b3f3f0)
    ** Insert  : 'vector.insert'(0x3b3f480)
    ** Insert  : 'vector.extract_strided_slice'(0x3b3f530)
    ** Insert  : 'vector.insert'(0x3b3f5c0)
    ** Replace : 'vector.shape_cast'(0x34bac20)
    ** Erase   : 'vector.shape_cast'(0x34bac20)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %162 = "vector.extract"(%131) {position = [15]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x3b2af70)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %162 = "vector.outerproduct"(%130, %96, %161) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %160 = "vector.extract"(%131) {position = [14]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x3b2ad80)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %160 = "vector.outerproduct"(%128, %94, %159) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %158 = "vector.extract"(%131) {position = [13]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x3b2ab90)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %158 = "vector.outerproduct"(%126, %92, %157) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %156 = "vector.extract"(%131) {position = [12]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x3b2a9a0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %156 = "vector.outerproduct"(%124, %90, %155) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %154 = "vector.extract"(%131) {position = [11]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x3b2a7b0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %154 = "vector.outerproduct"(%122, %88, %153) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %152 = "vector.extract"(%131) {position = [10]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x3b2a5c0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %152 = "vector.outerproduct"(%120, %86, %151) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %150 = "vector.extract"(%131) {position = [9]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x339c2a0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %150 = "vector.outerproduct"(%118, %84, %149) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c0b0) {
  %148 = "vector.extract"(%131) {position = [8]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x339c0b0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %148 = "vector.outerproduct"(%116, %82, %147) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bec0) {
  %146 = "vector.extract"(%131) {position = [7]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x339bec0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %146 = "vector.outerproduct"(%114, %80, %145) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339bcd0) {
  %144 = "vector.extract"(%131) {position = [6]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x339bcd0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %144 = "vector.outerproduct"(%112, %78, %143) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b22b90) {
  %142 = "vector.extract"(%131) {position = [5]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x3b22b90)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %142 = "vector.outerproduct"(%110, %76, %141) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b229a0) {
  %140 = "vector.extract"(%131) {position = [4]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x3b229a0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %140 = "vector.outerproduct"(%108, %74, %139) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b227b0) {
  %138 = "vector.extract"(%131) {position = [3]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x3b227b0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %138 = "vector.outerproduct"(%106, %72, %137) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x2078870) {
  %136 = "vector.extract"(%131) {position = [2]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x2078870)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %136 = "vector.outerproduct"(%104, %70, %135) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34c51a0) {
  %134 = "vector.extract"(%131) {position = [1]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x34c51a0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %134 = "vector.outerproduct"(%102, %68, %133) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x33980f0) {
  %132 = "vector.extract"(%131) {position = [0]} : (vector<16x8xf32>) -> vector<8xf32>

  ** Erase   : 'vector.extract'(0x33980f0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %132 = "vector.outerproduct"(%100, %66, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3f5c0) {
  %131 = "vector.insert"(%130, %129) {position = [15]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x3b3f5c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f530) {
  %130 = "vector.extract_strided_slice"(%98) {offsets = [120], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3f480) {
  %129 = "vector.insert"(%128, %127) {position = [14]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x3b3f480)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f3f0) {
  %128 = "vector.extract_strided_slice"(%98) {offsets = [112], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3f340) {
  %127 = "vector.insert"(%126, %125) {position = [13]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x3b3f340)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f2b0) {
  %126 = "vector.extract_strided_slice"(%98) {offsets = [104], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3f200) {
  %125 = "vector.insert"(%124, %123) {position = [12]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x3b3f200)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f170) {
  %124 = "vector.extract_strided_slice"(%98) {offsets = [96], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3cb80) {
  %123 = "vector.insert"(%122, %121) {position = [11]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x3b3cb80)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3caf0) {
  %122 = "vector.extract_strided_slice"(%98) {offsets = [88], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3ca40) {
  %121 = "vector.insert"(%120, %119) {position = [10]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x3b3ca40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c9b0) {
  %120 = "vector.extract_strided_slice"(%98) {offsets = [80], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3c900) {
  %119 = "vector.insert"(%118, %117) {position = [9]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x3b3c900)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c870) {
  %118 = "vector.extract_strided_slice"(%98) {offsets = [72], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3c7c0) {
  %117 = "vector.insert"(%116, %115) {position = [8]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x3b3c7c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c730) {
  %116 = "vector.extract_strided_slice"(%98) {offsets = [64], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2d140) {
  %115 = "vector.insert"(%114, %113) {position = [7]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x3b2d140)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2d0b0) {
  %114 = "vector.extract_strided_slice"(%98) {offsets = [56], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2d000) {
  %113 = "vector.insert"(%112, %111) {position = [6]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x3b2d000)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2c3f0) {
  %112 = "vector.extract_strided_slice"(%98) {offsets = [48], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cf50) {
  %111 = "vector.insert"(%110, %109) {position = [5]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x3b2cf50)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2068110) {
  %110 = "vector.extract_strided_slice"(%98) {offsets = [40], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x208c410) {
  %109 = "vector.insert"(%108, %107) {position = [4]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x208c410)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2ac20) {
  %108 = "vector.extract_strided_slice"(%98) {offsets = [32], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x208c360) {
  %107 = "vector.insert"(%106, %105) {position = [3]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x208c360)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b22a30) {
  %106 = "vector.extract_strided_slice"(%98) {offsets = [24], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x208c2b0) {
  %105 = "vector.insert"(%104, %103) {position = [2]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x208c2b0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b22840) {
  %104 = "vector.extract_strided_slice"(%98) {offsets = [16], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b1f3e0) {
  %103 = "vector.insert"(%102, %101) {position = [1]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x3b1f3e0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2e8bf80) {
  %102 = "vector.extract_strided_slice"(%98) {offsets = [8], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b1fb00) {
  %101 = "vector.insert"(%100, %99) {position = [0]} : (vector<8xf32>, vector<16x8xf32>) -> vector<16x8xf32>

  ** Erase   : 'vector.insert'(0x3b1fb00)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2d3a0) {
  %100 = "vector.extract_strided_slice"(%98) {offsets = [0], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b23490) {
  %99 = "arith.constant"() {value = dense<0.000000e+00> : vector<16x8xf32>} : () -> vector<16x8xf32>

  ** Erase   : 'arith.constant'(0x3b23490)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x3b2d4c0) {
  %98 = "vector.shuffle"(%97, %97) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shape_cast'(0x34c20f0) {
  %97 = "vector.shape_cast"(%65) : (vector<8x16xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::ShapeCastOp2DDownCastRewritePattern : 'vector.shape_cast -> ()' {
    ** Insert  : 'arith.constant'(0x3b23490)
    ** Insert  : 'vector.extract'(0x3b2a5c0)
    ** Insert  : 'vector.insert_strided_slice'(0x3b3c900)
    ** Insert  : 'vector.extract'(0x3b2a7b0)
    ** Insert  : 'vector.insert_strided_slice'(0x3b3ca40)
    ** Insert  : 'vector.extract'(0x3b2a9a0)
    ** Insert  : 'vector.insert_strided_slice'(0x3b3cb80)
    ** Insert  : 'vector.extract'(0x3b2ab90)
    ** Insert  : 'vector.insert_strided_slice'(0x3b3f200)
    ** Insert  : 'vector.extract'(0x3b2ad80)
    ** Insert  : 'vector.insert_strided_slice'(0x3b3f340)
    ** Insert  : 'vector.extract'(0x3b2af70)
    ** Insert  : 'vector.insert_strided_slice'(0x3b3f480)
    ** Insert  : 'vector.extract'(0x34bac20)
    ** Insert  : 'vector.insert_strided_slice'(0x3b3f5c0)
    ** Insert  : 'vector.extract'(0x339c2a0)
    ** Insert  : 'vector.insert_strided_slice'(0x3b3c7c0)
    ** Replace : 'vector.shape_cast'(0x34c20f0)
    ** Erase   : 'vector.shape_cast'(0x34c20f0)
  } -> success : pattern applied successfully
} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x3b2d4c0) {
  %114 = "vector.shuffle"(%113, %113) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3c7c0) {
  %113 = "vector.insert_strided_slice"(%112, %111) {offsets = [112], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x339c2a0) {
  %112 = "vector.extract"(%65) {position = [7]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x339c2a0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3c7c0) {
  %112 = "vector.insert_strided_slice"(%64, %111) {offsets = [112], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f5c0) {
  %111 = "vector.insert_strided_slice"(%110, %109) {offsets = [96], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x34bac20) {
  %110 = "vector.extract"(%65) {position = [6]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x34bac20)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f5c0) {
  %110 = "vector.insert_strided_slice"(%62, %109) {offsets = [96], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f480) {
  %109 = "vector.insert_strided_slice"(%108, %107) {offsets = [80], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2af70) {
  %108 = "vector.extract"(%65) {position = [5]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x3b2af70)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f480) {
  %108 = "vector.insert_strided_slice"(%60, %107) {offsets = [80], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f340) {
  %107 = "vector.insert_strided_slice"(%106, %105) {offsets = [64], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ad80) {
  %106 = "vector.extract"(%65) {position = [4]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x3b2ad80)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f340) {
  %106 = "vector.insert_strided_slice"(%58, %105) {offsets = [64], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f200) {
  %105 = "vector.insert_strided_slice"(%104, %103) {offsets = [48], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2ab90) {
  %104 = "vector.extract"(%65) {position = [3]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x3b2ab90)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f200) {
  %104 = "vector.insert_strided_slice"(%56, %103) {offsets = [48], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3cb80) {
  %103 = "vector.insert_strided_slice"(%102, %101) {offsets = [32], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a9a0) {
  %102 = "vector.extract"(%65) {position = [2]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x3b2a9a0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3cb80) {
  %102 = "vector.insert_strided_slice"(%54, %101) {offsets = [32], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3ca40) {
  %101 = "vector.insert_strided_slice"(%100, %99) {offsets = [16], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a7b0) {
  %100 = "vector.extract"(%65) {position = [1]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x3b2a7b0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3ca40) {
  %100 = "vector.insert_strided_slice"(%52, %99) {offsets = [16], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3c900) {
  %99 = "vector.insert_strided_slice"(%98, %97) {offsets = [0], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a5c0) {
  %98 = "vector.extract"(%65) {position = [0]} : (vector<8x16xf32>) -> vector<16xf32>

  ** Erase   : 'vector.extract'(0x3b2a5c0)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3c900) {
  %98 = "vector.insert_strided_slice"(%50, %97) {offsets = [0], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b23490) {
  %97 = "arith.constant"() {value = dense<0.000000e+00> : vector<128xf32>} : () -> vector<128xf32>

  ** Erase   : 'arith.constant'(0x3b23490)
} -> success : operation was folded
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3c900) {
  %98 = "vector.insert_strided_slice"(%51, %0) {offsets = [0], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2cd90) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<128xf32>} : () -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %97 = "vector.load"(%17, %96, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %96 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %95 = "vector.load"(%17, %94, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %94 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %93 = "vector.load"(%17, %92, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %92 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %91 = "vector.load"(%17, %90, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %90 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %89 = "vector.load"(%17, %88, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %88 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %87 = "vector.load"(%17, %86, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %86 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %85 = "vector.load"(%17, %84, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %84 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %83 = "vector.load"(%17, %82, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %82 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %81 = "vector.load"(%17, %80, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %80 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %79 = "vector.load"(%17, %78, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %78 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %77 = "vector.load"(%17, %76, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %76 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %75 = "vector.load"(%17, %74, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %74 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %73 = "vector.load"(%17, %72, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %72 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %71 = "vector.load"(%17, %70, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %70 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %69 = "vector.load"(%17, %68, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %68 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %67 = "vector.load"(%17, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3394240) {
  %66 = "vector.insert"(%65, %64) {position = [7]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x3394240)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %65 = "vector.load"(%16, %25, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b38730) {
  %64 = "vector.insert"(%63, %62) {position = [6]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x3b38730)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %63 = "vector.load"(%16, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b384a0) {
  %62 = "vector.insert"(%61, %60) {position = [5]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x3b384a0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %61 = "vector.load"(%16, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b37a00) {
  %60 = "vector.insert"(%59, %58) {position = [4]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x3b37a00)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %59 = "vector.load"(%16, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36f60) {
  %58 = "vector.insert"(%57, %56) {position = [3]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x3b36f60)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %57 = "vector.load"(%16, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36d30) {
  %56 = "vector.insert"(%55, %54) {position = [2]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x3b36d30)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %55 = "vector.load"(%16, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b36b00) {
  %54 = "vector.insert"(%53, %52) {position = [1]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x3b36b00)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %53 = "vector.load"(%16, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b2cce0) {
  %52 = "vector.insert"(%51, %2) {position = [0]} : (vector<16xf32>, vector<8x16xf32>) -> vector<8x16xf32>

  ** Erase   : 'vector.insert'(0x3b2cce0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %51 = "vector.load"(%16, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %41 = "vector.insert"(%40, %39) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %40 = "vector.load"(%18, %25, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %39 = "vector.insert"(%38, %37) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %38 = "vector.load"(%18, %24, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %37 = "vector.insert"(%36, %35) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %36 = "vector.load"(%18, %23, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %35 = "vector.insert"(%34, %33) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %34 = "vector.load"(%18, %22, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %33 = "vector.insert"(%32, %31) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %32 = "vector.load"(%18, %21, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %31 = "vector.insert"(%30, %29) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %30 = "vector.load"(%18, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %29 = "vector.insert"(%28, %27) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %28 = "vector.load"(%18, %19, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %27 = "vector.insert"(%26, %1) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %26 = "vector.load"(%18, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %25 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %18 = "memref.subview"(%11, %14, %15) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %17 = "memref.subview"(%10, %15) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %15 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %14 = "affine.apply"(%13) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %13 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %12 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%11) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %11 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %10 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %9 = "hal.interface.binding.subspan"(%8) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %8 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %7 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %6 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %5 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %4 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %3 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x2069e90) {
  %2 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x16xf32>} : () -> vector<8x16xf32>

  ** Erase   : 'arith.constant'(0x2069e90)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'func.return -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%49, %17, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %49 = "vector.extract"(%41) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%48, %17, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %48 = "vector.extract"(%41) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%47, %17, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %47 = "vector.extract"(%41) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%46, %17, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %46 = "vector.extract"(%41) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%45, %17, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %45 = "vector.extract"(%41) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%44, %17, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %44 = "vector.extract"(%41) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%43, %17, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %43 = "vector.extract"(%41) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%42, %17, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()


  * Pattern VectorStoreToMemrefStoreLowering : 'vector.store -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.store -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %42 = "vector.extract"(%41) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%129) : (vector<8x32xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.yield -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %129 = "vector.outerproduct"(%113, %88, %128) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %128 = "vector.outerproduct"(%112, %86, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %127 = "vector.outerproduct"(%111, %84, %126) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %126 = "vector.outerproduct"(%110, %82, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %125 = "vector.outerproduct"(%109, %80, %124) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %124 = "vector.outerproduct"(%108, %78, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %123 = "vector.outerproduct"(%107, %76, %122) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %122 = "vector.outerproduct"(%106, %74, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %121 = "vector.outerproduct"(%105, %72, %120) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %120 = "vector.outerproduct"(%104, %70, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %119 = "vector.outerproduct"(%103, %68, %118) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %118 = "vector.outerproduct"(%102, %66, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %117 = "vector.outerproduct"(%101, %64, %116) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %116 = "vector.outerproduct"(%100, %62, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %115 = "vector.outerproduct"(%99, %60, %114) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %114 = "vector.outerproduct"(%98, %58, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.outerproduct -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f530) {
  %113 = "vector.extract_strided_slice"(%97) {offsets = [120], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f3f0) {
  %112 = "vector.extract_strided_slice"(%97) {offsets = [112], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f2b0) {
  %111 = "vector.extract_strided_slice"(%97) {offsets = [104], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f170) {
  %110 = "vector.extract_strided_slice"(%97) {offsets = [96], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3caf0) {
  %109 = "vector.extract_strided_slice"(%97) {offsets = [88], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c9b0) {
  %108 = "vector.extract_strided_slice"(%97) {offsets = [80], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c870) {
  %107 = "vector.extract_strided_slice"(%97) {offsets = [72], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c730) {
  %106 = "vector.extract_strided_slice"(%97) {offsets = [64], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2d0b0) {
  %105 = "vector.extract_strided_slice"(%97) {offsets = [56], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2c3f0) {
  %104 = "vector.extract_strided_slice"(%97) {offsets = [48], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2068110) {
  %103 = "vector.extract_strided_slice"(%97) {offsets = [40], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2ac20) {
  %102 = "vector.extract_strided_slice"(%97) {offsets = [32], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b22a30) {
  %101 = "vector.extract_strided_slice"(%97) {offsets = [24], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b22840) {
  %100 = "vector.extract_strided_slice"(%97) {offsets = [16], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2e8bf80) {
  %99 = "vector.extract_strided_slice"(%97) {offsets = [8], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2d3a0) {
  %98 = "vector.extract_strided_slice"(%97) {offsets = [0], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x3b2d4c0) {
  %97 = "vector.shuffle"(%96, %96) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3c7c0) {
  %96 = "vector.insert_strided_slice"(%57, %95) {offsets = [112], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f5c0) {
  %95 = "vector.insert_strided_slice"(%56, %94) {offsets = [96], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f480) {
  %94 = "vector.insert_strided_slice"(%55, %93) {offsets = [80], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f340) {
  %93 = "vector.insert_strided_slice"(%54, %92) {offsets = [64], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f200) {
  %92 = "vector.insert_strided_slice"(%53, %91) {offsets = [48], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3cb80) {
  %91 = "vector.insert_strided_slice"(%52, %90) {offsets = [32], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3ca40) {
  %90 = "vector.insert_strided_slice"(%51, %89) {offsets = [16], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3c900) {
  %89 = "vector.insert_strided_slice"(%50, %0) {offsets = [0], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %88 = "vector.load"(%16, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %86 = "vector.load"(%16, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %84 = "vector.load"(%16, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %82 = "vector.load"(%16, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %80 = "vector.load"(%16, %79, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %79 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %78 = "vector.load"(%16, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %76 = "vector.load"(%16, %75, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %75 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %74 = "vector.load"(%16, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %72 = "vector.load"(%16, %71, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %71 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %70 = "vector.load"(%16, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %68 = "vector.load"(%16, %67, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %67 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %66 = "vector.load"(%16, %65, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %65 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %64 = "vector.load"(%16, %63, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %63 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %62 = "vector.load"(%16, %61, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %61 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %60 = "vector.load"(%16, %59, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %59 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %58 = "vector.load"(%16, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %57 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %56 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %55 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %54 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %53 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %52 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %51 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %50 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %40 = "vector.insert"(%39, %38) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %39 = "vector.load"(%17, %24, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %38 = "vector.insert"(%37, %36) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %37 = "vector.load"(%17, %23, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %36 = "vector.insert"(%35, %34) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %35 = "vector.load"(%17, %22, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %34 = "vector.insert"(%33, %32) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %33 = "vector.load"(%17, %21, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %32 = "vector.insert"(%31, %30) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %31 = "vector.load"(%17, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %30 = "vector.insert"(%29, %28) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %29 = "vector.load"(%17, %19, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %28 = "vector.insert"(%27, %26) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %27 = "vector.load"(%17, %18, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %26 = "vector.insert"(%25, %1) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %25 = "vector.load"(%17, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>


  * Pattern VectorLoadToMemrefLoadLowering : 'vector.load -> ()' {
  } -> failure : pattern failed to match

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'vector.load -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %17 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.workgroup.id -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'memref.assume_alignment -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'hal.interface.binding.subspan -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2cd90) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<128xf32>} : () -> vector<128xf32>


  * Pattern mlir::vector::VectorTransferFullPartialRewriter : 'arith.constant -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After LinalgStrategyLowerVectorsPass (iree-linalg-strategy-lower-vectors-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst_0 [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %39 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %41 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %43 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %45 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %46 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %47 = vector.load %subview_1[%46, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %48 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %49 = vector.load %subview_1[%48, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %50 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %51 = vector.load %subview_1[%50, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %52 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %53 = vector.load %subview_1[%52, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = vector.insert_strided_slice %37, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %77 = vector.insert_strided_slice %38, %76 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %78 = vector.insert_strided_slice %39, %77 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %79 = vector.insert_strided_slice %40, %78 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %80 = vector.insert_strided_slice %41, %79 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %81 = vector.insert_strided_slice %42, %80 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %82 = vector.insert_strided_slice %43, %81 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %83 = vector.insert_strided_slice %44, %82 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %84 = vector.shuffle %83, %83 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %85 = vector.extract_strided_slice %84 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.extract_strided_slice %84 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %87 = vector.extract_strided_slice %84 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %88 = vector.extract_strided_slice %84 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %89 = vector.extract_strided_slice %84 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %90 = vector.extract_strided_slice %84 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %91 = vector.extract_strided_slice %84 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %92 = vector.extract_strided_slice %84 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %93 = vector.extract_strided_slice %84 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %94 = vector.extract_strided_slice %84 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %95 = vector.extract_strided_slice %84 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %96 = vector.extract_strided_slice %84 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %97 = vector.extract_strided_slice %84 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %98 = vector.extract_strided_slice %84 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %99 = vector.extract_strided_slice %84 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %100 = vector.extract_strided_slice %84 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %101 = vector.outerproduct %85, %45, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.outerproduct %86, %47, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.outerproduct %87, %49, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %104 = vector.outerproduct %88, %51, %103 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.outerproduct %89, %53, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %106 = vector.outerproduct %90, %55, %105 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.outerproduct %91, %57, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %108 = vector.outerproduct %92, %59, %107 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.outerproduct %93, %61, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %110 = vector.outerproduct %94, %63, %109 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.outerproduct %95, %65, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %112 = vector.outerproduct %96, %67, %111 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.outerproduct %97, %69, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %114 = vector.outerproduct %98, %71, %113 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.outerproduct %99, %73, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %116 = vector.outerproduct %100, %75, %115 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%49, %17, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %49 = "vector.extract"(%41) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%48, %17, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %48 = "vector.extract"(%41) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%47, %17, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %47 = "vector.extract"(%41) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%46, %17, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %46 = "vector.extract"(%41) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%45, %17, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %45 = "vector.extract"(%41) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%44, %17, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %44 = "vector.extract"(%41) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%43, %17, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %43 = "vector.extract"(%41) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%42, %17, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %42 = "vector.extract"(%41) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%129) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %129 = "vector.outerproduct"(%113, %88, %128) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %128 = "vector.outerproduct"(%112, %86, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %127 = "vector.outerproduct"(%111, %84, %126) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %126 = "vector.outerproduct"(%110, %82, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %125 = "vector.outerproduct"(%109, %80, %124) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %124 = "vector.outerproduct"(%108, %78, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %123 = "vector.outerproduct"(%107, %76, %122) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %122 = "vector.outerproduct"(%106, %74, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %121 = "vector.outerproduct"(%105, %72, %120) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %120 = "vector.outerproduct"(%104, %70, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %119 = "vector.outerproduct"(%103, %68, %118) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %118 = "vector.outerproduct"(%102, %66, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %117 = "vector.outerproduct"(%101, %64, %116) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %116 = "vector.outerproduct"(%100, %62, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %115 = "vector.outerproduct"(%99, %60, %114) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %114 = "vector.outerproduct"(%98, %58, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f530) {
  %113 = "vector.extract_strided_slice"(%97) {offsets = [120], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f3f0) {
  %112 = "vector.extract_strided_slice"(%97) {offsets = [112], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f2b0) {
  %111 = "vector.extract_strided_slice"(%97) {offsets = [104], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f170) {
  %110 = "vector.extract_strided_slice"(%97) {offsets = [96], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3caf0) {
  %109 = "vector.extract_strided_slice"(%97) {offsets = [88], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c9b0) {
  %108 = "vector.extract_strided_slice"(%97) {offsets = [80], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c870) {
  %107 = "vector.extract_strided_slice"(%97) {offsets = [72], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c730) {
  %106 = "vector.extract_strided_slice"(%97) {offsets = [64], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2d0b0) {
  %105 = "vector.extract_strided_slice"(%97) {offsets = [56], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2c3f0) {
  %104 = "vector.extract_strided_slice"(%97) {offsets = [48], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2068110) {
  %103 = "vector.extract_strided_slice"(%97) {offsets = [40], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2ac20) {
  %102 = "vector.extract_strided_slice"(%97) {offsets = [32], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b22a30) {
  %101 = "vector.extract_strided_slice"(%97) {offsets = [24], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b22840) {
  %100 = "vector.extract_strided_slice"(%97) {offsets = [16], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2e8bf80) {
  %99 = "vector.extract_strided_slice"(%97) {offsets = [8], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2d3a0) {
  %98 = "vector.extract_strided_slice"(%97) {offsets = [0], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x3b2d4c0) {
  %97 = "vector.shuffle"(%96, %96) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3c7c0) {
  %96 = "vector.insert_strided_slice"(%57, %95) {offsets = [112], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f5c0) {
  %95 = "vector.insert_strided_slice"(%56, %94) {offsets = [96], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f480) {
  %94 = "vector.insert_strided_slice"(%55, %93) {offsets = [80], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f340) {
  %93 = "vector.insert_strided_slice"(%54, %92) {offsets = [64], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f200) {
  %92 = "vector.insert_strided_slice"(%53, %91) {offsets = [48], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3cb80) {
  %91 = "vector.insert_strided_slice"(%52, %90) {offsets = [32], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3ca40) {
  %90 = "vector.insert_strided_slice"(%51, %89) {offsets = [16], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3c900) {
  %89 = "vector.insert_strided_slice"(%50, %0) {offsets = [0], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %88 = "vector.load"(%16, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %86 = "vector.load"(%16, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %84 = "vector.load"(%16, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %82 = "vector.load"(%16, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %80 = "vector.load"(%16, %79, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %79 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %78 = "vector.load"(%16, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %76 = "vector.load"(%16, %75, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %75 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %74 = "vector.load"(%16, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %72 = "vector.load"(%16, %71, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %71 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %70 = "vector.load"(%16, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %68 = "vector.load"(%16, %67, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %67 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %66 = "vector.load"(%16, %65, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %65 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %64 = "vector.load"(%16, %63, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %63 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %62 = "vector.load"(%16, %61, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %61 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %60 = "vector.load"(%16, %59, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %59 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %58 = "vector.load"(%16, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %57 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %56 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %55 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %54 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %53 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %52 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %51 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %50 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %40 = "vector.insert"(%39, %38) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %39 = "vector.load"(%17, %24, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %38 = "vector.insert"(%37, %36) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %37 = "vector.load"(%17, %23, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %36 = "vector.insert"(%35, %34) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %35 = "vector.load"(%17, %22, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %34 = "vector.insert"(%33, %32) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %33 = "vector.load"(%17, %21, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %32 = "vector.insert"(%31, %30) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %31 = "vector.load"(%17, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %30 = "vector.insert"(%29, %28) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %29 = "vector.load"(%17, %19, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %28 = "vector.insert"(%27, %26) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %27 = "vector.load"(%17, %18, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %26 = "vector.insert"(%25, %1) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %25 = "vector.load"(%17, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %17 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2cd90) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<128xf32>} : () -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst_0 [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %39 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %41 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %43 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %45 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %46 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %47 = vector.load %subview_1[%46, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %48 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %49 = vector.load %subview_1[%48, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %50 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %51 = vector.load %subview_1[%50, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %52 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %53 = vector.load %subview_1[%52, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = vector.insert_strided_slice %37, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %77 = vector.insert_strided_slice %38, %76 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %78 = vector.insert_strided_slice %39, %77 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %79 = vector.insert_strided_slice %40, %78 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %80 = vector.insert_strided_slice %41, %79 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %81 = vector.insert_strided_slice %42, %80 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %82 = vector.insert_strided_slice %43, %81 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %83 = vector.insert_strided_slice %44, %82 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %84 = vector.shuffle %83, %83 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %85 = vector.extract_strided_slice %84 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.extract_strided_slice %84 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %87 = vector.extract_strided_slice %84 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %88 = vector.extract_strided_slice %84 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %89 = vector.extract_strided_slice %84 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %90 = vector.extract_strided_slice %84 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %91 = vector.extract_strided_slice %84 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %92 = vector.extract_strided_slice %84 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %93 = vector.extract_strided_slice %84 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %94 = vector.extract_strided_slice %84 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %95 = vector.extract_strided_slice %84 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %96 = vector.extract_strided_slice %84 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %97 = vector.extract_strided_slice %84 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %98 = vector.extract_strided_slice %84 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %99 = vector.extract_strided_slice %84 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %100 = vector.extract_strided_slice %84 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %101 = vector.outerproduct %85, %45, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.outerproduct %86, %47, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.outerproduct %87, %49, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %104 = vector.outerproduct %88, %51, %103 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.outerproduct %89, %53, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %106 = vector.outerproduct %90, %55, %105 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.outerproduct %91, %57, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %108 = vector.outerproduct %92, %59, %107 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.outerproduct %93, %61, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %110 = vector.outerproduct %94, %63, %109 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.outerproduct %95, %65, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %112 = vector.outerproduct %96, %67, %111 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.outerproduct %97, %69, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %114 = vector.outerproduct %98, %71, %113 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.outerproduct %99, %73, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %116 = vector.outerproduct %100, %75, %115 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst_0 [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %39 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %41 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %43 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %45 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %46 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %47 = vector.load %subview_1[%46, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %48 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %49 = vector.load %subview_1[%48, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %50 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %51 = vector.load %subview_1[%50, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %52 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %53 = vector.load %subview_1[%52, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = vector.insert_strided_slice %37, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %77 = vector.insert_strided_slice %38, %76 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %78 = vector.insert_strided_slice %39, %77 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %79 = vector.insert_strided_slice %40, %78 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %80 = vector.insert_strided_slice %41, %79 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %81 = vector.insert_strided_slice %42, %80 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %82 = vector.insert_strided_slice %43, %81 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %83 = vector.insert_strided_slice %44, %82 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %84 = vector.shuffle %83, %83 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %85 = vector.extract_strided_slice %84 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.extract_strided_slice %84 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %87 = vector.extract_strided_slice %84 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %88 = vector.extract_strided_slice %84 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %89 = vector.extract_strided_slice %84 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %90 = vector.extract_strided_slice %84 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %91 = vector.extract_strided_slice %84 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %92 = vector.extract_strided_slice %84 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %93 = vector.extract_strided_slice %84 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %94 = vector.extract_strided_slice %84 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %95 = vector.extract_strided_slice %84 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %96 = vector.extract_strided_slice %84 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %97 = vector.extract_strided_slice %84 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %98 = vector.extract_strided_slice %84 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %99 = vector.extract_strided_slice %84 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %100 = vector.extract_strided_slice %84 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %101 = vector.outerproduct %85, %45, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.outerproduct %86, %47, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.outerproduct %87, %49, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %104 = vector.outerproduct %88, %51, %103 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.outerproduct %89, %53, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %106 = vector.outerproduct %90, %55, %105 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.outerproduct %91, %57, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %108 = vector.outerproduct %92, %59, %107 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.outerproduct %93, %61, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %110 = vector.outerproduct %94, %63, %109 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.outerproduct %95, %65, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %112 = vector.outerproduct %96, %67, %111 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.outerproduct %97, %69, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %114 = vector.outerproduct %98, %71, %113 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.outerproduct %99, %73, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %116 = vector.outerproduct %100, %75, %115 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyRemoveMarkersPass (iree-linalg-strategy-remove-markers-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst_0 [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %39 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %41 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %43 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %45 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %46 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %47 = vector.load %subview_1[%46, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %48 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %49 = vector.load %subview_1[%48, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %50 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %51 = vector.load %subview_1[%50, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %52 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %53 = vector.load %subview_1[%52, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = vector.insert_strided_slice %37, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %77 = vector.insert_strided_slice %38, %76 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %78 = vector.insert_strided_slice %39, %77 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %79 = vector.insert_strided_slice %40, %78 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %80 = vector.insert_strided_slice %41, %79 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %81 = vector.insert_strided_slice %42, %80 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %82 = vector.insert_strided_slice %43, %81 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %83 = vector.insert_strided_slice %44, %82 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %84 = vector.shuffle %83, %83 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %85 = vector.extract_strided_slice %84 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.extract_strided_slice %84 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %87 = vector.extract_strided_slice %84 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %88 = vector.extract_strided_slice %84 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %89 = vector.extract_strided_slice %84 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %90 = vector.extract_strided_slice %84 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %91 = vector.extract_strided_slice %84 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %92 = vector.extract_strided_slice %84 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %93 = vector.extract_strided_slice %84 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %94 = vector.extract_strided_slice %84 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %95 = vector.extract_strided_slice %84 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %96 = vector.extract_strided_slice %84 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %97 = vector.extract_strided_slice %84 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %98 = vector.extract_strided_slice %84 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %99 = vector.extract_strided_slice %84 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %100 = vector.extract_strided_slice %84 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %101 = vector.outerproduct %85, %45, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.outerproduct %86, %47, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.outerproduct %87, %49, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %104 = vector.outerproduct %88, %51, %103 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.outerproduct %89, %53, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %106 = vector.outerproduct %90, %55, %105 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.outerproduct %91, %57, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %108 = vector.outerproduct %92, %59, %107 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.outerproduct %93, %61, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %110 = vector.outerproduct %94, %63, %109 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.outerproduct %95, %65, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %112 = vector.outerproduct %96, %67, %111 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.outerproduct %97, %69, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %114 = vector.outerproduct %98, %71, %113 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.outerproduct %99, %73, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %116 = vector.outerproduct %100, %75, %115 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%49, %17, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %49 = "vector.extract"(%41) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%48, %17, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %48 = "vector.extract"(%41) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%47, %17, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %47 = "vector.extract"(%41) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%46, %17, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %46 = "vector.extract"(%41) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%45, %17, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %45 = "vector.extract"(%41) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%44, %17, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %44 = "vector.extract"(%41) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%43, %17, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %43 = "vector.extract"(%41) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%42, %17, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %42 = "vector.extract"(%41) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%129) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %129 = "vector.outerproduct"(%113, %88, %128) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %128 = "vector.outerproduct"(%112, %86, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %127 = "vector.outerproduct"(%111, %84, %126) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %126 = "vector.outerproduct"(%110, %82, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %125 = "vector.outerproduct"(%109, %80, %124) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %124 = "vector.outerproduct"(%108, %78, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %123 = "vector.outerproduct"(%107, %76, %122) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %122 = "vector.outerproduct"(%106, %74, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %121 = "vector.outerproduct"(%105, %72, %120) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %120 = "vector.outerproduct"(%104, %70, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %119 = "vector.outerproduct"(%103, %68, %118) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %118 = "vector.outerproduct"(%102, %66, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %117 = "vector.outerproduct"(%101, %64, %116) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %116 = "vector.outerproduct"(%100, %62, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %115 = "vector.outerproduct"(%99, %60, %114) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %114 = "vector.outerproduct"(%98, %58, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f530) {
  %113 = "vector.extract_strided_slice"(%97) {offsets = [120], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f3f0) {
  %112 = "vector.extract_strided_slice"(%97) {offsets = [112], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f2b0) {
  %111 = "vector.extract_strided_slice"(%97) {offsets = [104], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f170) {
  %110 = "vector.extract_strided_slice"(%97) {offsets = [96], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3caf0) {
  %109 = "vector.extract_strided_slice"(%97) {offsets = [88], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c9b0) {
  %108 = "vector.extract_strided_slice"(%97) {offsets = [80], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c870) {
  %107 = "vector.extract_strided_slice"(%97) {offsets = [72], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c730) {
  %106 = "vector.extract_strided_slice"(%97) {offsets = [64], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2d0b0) {
  %105 = "vector.extract_strided_slice"(%97) {offsets = [56], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2c3f0) {
  %104 = "vector.extract_strided_slice"(%97) {offsets = [48], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2068110) {
  %103 = "vector.extract_strided_slice"(%97) {offsets = [40], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2ac20) {
  %102 = "vector.extract_strided_slice"(%97) {offsets = [32], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b22a30) {
  %101 = "vector.extract_strided_slice"(%97) {offsets = [24], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b22840) {
  %100 = "vector.extract_strided_slice"(%97) {offsets = [16], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2e8bf80) {
  %99 = "vector.extract_strided_slice"(%97) {offsets = [8], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2d3a0) {
  %98 = "vector.extract_strided_slice"(%97) {offsets = [0], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x3b2d4c0) {
  %97 = "vector.shuffle"(%96, %96) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3c7c0) {
  %96 = "vector.insert_strided_slice"(%57, %95) {offsets = [112], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f5c0) {
  %95 = "vector.insert_strided_slice"(%56, %94) {offsets = [96], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f480) {
  %94 = "vector.insert_strided_slice"(%55, %93) {offsets = [80], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f340) {
  %93 = "vector.insert_strided_slice"(%54, %92) {offsets = [64], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f200) {
  %92 = "vector.insert_strided_slice"(%53, %91) {offsets = [48], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3cb80) {
  %91 = "vector.insert_strided_slice"(%52, %90) {offsets = [32], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3ca40) {
  %90 = "vector.insert_strided_slice"(%51, %89) {offsets = [16], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3c900) {
  %89 = "vector.insert_strided_slice"(%50, %0) {offsets = [0], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %88 = "vector.load"(%16, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %86 = "vector.load"(%16, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %84 = "vector.load"(%16, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %82 = "vector.load"(%16, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %80 = "vector.load"(%16, %79, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %79 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %78 = "vector.load"(%16, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %76 = "vector.load"(%16, %75, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %75 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %74 = "vector.load"(%16, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %72 = "vector.load"(%16, %71, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %71 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %70 = "vector.load"(%16, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %68 = "vector.load"(%16, %67, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %67 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %66 = "vector.load"(%16, %65, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %65 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %64 = "vector.load"(%16, %63, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %63 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %62 = "vector.load"(%16, %61, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %61 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %60 = "vector.load"(%16, %59, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %59 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %58 = "vector.load"(%16, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %57 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %56 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %55 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %54 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %53 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %52 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %51 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %50 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %40 = "vector.insert"(%39, %38) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %39 = "vector.load"(%17, %24, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %38 = "vector.insert"(%37, %36) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %37 = "vector.load"(%17, %23, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %36 = "vector.insert"(%35, %34) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %35 = "vector.load"(%17, %22, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %34 = "vector.insert"(%33, %32) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %33 = "vector.load"(%17, %21, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %32 = "vector.insert"(%31, %30) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %31 = "vector.load"(%17, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %30 = "vector.insert"(%29, %28) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %29 = "vector.load"(%17, %19, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %28 = "vector.insert"(%27, %26) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %27 = "vector.load"(%17, %18, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %26 = "vector.insert"(%25, %1) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %25 = "vector.load"(%17, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %17 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2cd90) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<128xf32>} : () -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst_0 [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %39 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %41 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %43 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %45 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %46 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %47 = vector.load %subview_1[%46, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %48 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %49 = vector.load %subview_1[%48, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %50 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %51 = vector.load %subview_1[%50, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %52 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %53 = vector.load %subview_1[%52, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = vector.insert_strided_slice %37, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %77 = vector.insert_strided_slice %38, %76 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %78 = vector.insert_strided_slice %39, %77 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %79 = vector.insert_strided_slice %40, %78 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %80 = vector.insert_strided_slice %41, %79 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %81 = vector.insert_strided_slice %42, %80 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %82 = vector.insert_strided_slice %43, %81 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %83 = vector.insert_strided_slice %44, %82 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %84 = vector.shuffle %83, %83 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %85 = vector.extract_strided_slice %84 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.extract_strided_slice %84 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %87 = vector.extract_strided_slice %84 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %88 = vector.extract_strided_slice %84 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %89 = vector.extract_strided_slice %84 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %90 = vector.extract_strided_slice %84 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %91 = vector.extract_strided_slice %84 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %92 = vector.extract_strided_slice %84 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %93 = vector.extract_strided_slice %84 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %94 = vector.extract_strided_slice %84 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %95 = vector.extract_strided_slice %84 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %96 = vector.extract_strided_slice %84 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %97 = vector.extract_strided_slice %84 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %98 = vector.extract_strided_slice %84 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %99 = vector.extract_strided_slice %84 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %100 = vector.extract_strided_slice %84 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %101 = vector.outerproduct %85, %45, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.outerproduct %86, %47, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.outerproduct %87, %49, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %104 = vector.outerproduct %88, %51, %103 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.outerproduct %89, %53, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %106 = vector.outerproduct %90, %55, %105 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.outerproduct %91, %57, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %108 = vector.outerproduct %92, %59, %107 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.outerproduct %93, %61, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %110 = vector.outerproduct %94, %63, %109 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.outerproduct %95, %65, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %112 = vector.outerproduct %96, %67, %111 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.outerproduct %97, %69, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %114 = vector.outerproduct %98, %71, %113 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.outerproduct %99, %73, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %116 = vector.outerproduct %100, %75, %115 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgStrategyEnablePass (iree-linalg-strategy-enable-pass) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst_0 [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %39 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %41 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %43 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %45 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %46 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %47 = vector.load %subview_1[%46, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %48 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %49 = vector.load %subview_1[%48, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %50 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %51 = vector.load %subview_1[%50, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %52 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %53 = vector.load %subview_1[%52, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = vector.insert_strided_slice %37, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %77 = vector.insert_strided_slice %38, %76 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %78 = vector.insert_strided_slice %39, %77 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %79 = vector.insert_strided_slice %40, %78 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %80 = vector.insert_strided_slice %41, %79 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %81 = vector.insert_strided_slice %42, %80 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %82 = vector.insert_strided_slice %43, %81 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %83 = vector.insert_strided_slice %44, %82 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %84 = vector.shuffle %83, %83 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %85 = vector.extract_strided_slice %84 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.extract_strided_slice %84 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %87 = vector.extract_strided_slice %84 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %88 = vector.extract_strided_slice %84 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %89 = vector.extract_strided_slice %84 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %90 = vector.extract_strided_slice %84 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %91 = vector.extract_strided_slice %84 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %92 = vector.extract_strided_slice %84 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %93 = vector.extract_strided_slice %84 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %94 = vector.extract_strided_slice %84 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %95 = vector.extract_strided_slice %84 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %96 = vector.extract_strided_slice %84 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %97 = vector.extract_strided_slice %84 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %98 = vector.extract_strided_slice %84 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %99 = vector.extract_strided_slice %84 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %100 = vector.extract_strided_slice %84 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %101 = vector.outerproduct %85, %45, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.outerproduct %86, %47, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.outerproduct %87, %49, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %104 = vector.outerproduct %88, %51, %103 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.outerproduct %89, %53, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %106 = vector.outerproduct %90, %55, %105 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.outerproduct %91, %57, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %108 = vector.outerproduct %92, %59, %107 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.outerproduct %93, %61, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %110 = vector.outerproduct %94, %63, %109 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.outerproduct %95, %65, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %112 = vector.outerproduct %96, %67, %111 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.outerproduct %97, %69, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %114 = vector.outerproduct %98, %71, %113 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.outerproduct %99, %73, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %116 = vector.outerproduct %100, %75, %115 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LinalgVectorLowering (linalg-vector-lowering) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst_0 [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %39 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %41 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %43 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %45 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %46 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %47 = vector.load %subview_1[%46, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %48 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %49 = vector.load %subview_1[%48, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %50 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %51 = vector.load %subview_1[%50, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %52 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %53 = vector.load %subview_1[%52, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = vector.insert_strided_slice %37, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %77 = vector.insert_strided_slice %38, %76 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %78 = vector.insert_strided_slice %39, %77 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %79 = vector.insert_strided_slice %40, %78 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %80 = vector.insert_strided_slice %41, %79 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %81 = vector.insert_strided_slice %42, %80 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %82 = vector.insert_strided_slice %43, %81 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %83 = vector.insert_strided_slice %44, %82 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %84 = vector.shuffle %83, %83 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %85 = vector.extract_strided_slice %84 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.extract_strided_slice %84 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %87 = vector.extract_strided_slice %84 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %88 = vector.extract_strided_slice %84 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %89 = vector.extract_strided_slice %84 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %90 = vector.extract_strided_slice %84 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %91 = vector.extract_strided_slice %84 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %92 = vector.extract_strided_slice %84 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %93 = vector.extract_strided_slice %84 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %94 = vector.extract_strided_slice %84 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %95 = vector.extract_strided_slice %84 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %96 = vector.extract_strided_slice %84 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %97 = vector.extract_strided_slice %84 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %98 = vector.extract_strided_slice %84 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %99 = vector.extract_strided_slice %84 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %100 = vector.extract_strided_slice %84 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %101 = vector.outerproduct %85, %45, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.outerproduct %86, %47, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.outerproduct %87, %49, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %104 = vector.outerproduct %88, %51, %103 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.outerproduct %89, %53, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %106 = vector.outerproduct %90, %55, %105 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.outerproduct %91, %57, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %108 = vector.outerproduct %92, %59, %107 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.outerproduct %93, %61, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %110 = vector.outerproduct %94, %63, %109 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.outerproduct %95, %65, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %112 = vector.outerproduct %96, %67, %111 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.outerproduct %97, %69, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %114 = vector.outerproduct %98, %71, %113 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.outerproduct %99, %73, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %116 = vector.outerproduct %100, %75, %115 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}


//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2cd90) {
  %0 = "arith.constant"() {value = dense<0.000000e+00> : vector<128xf32>} : () -> vector<128xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3b2e750) {
  %1 = "arith.constant"() {value = dense<0.000000e+00> : vector<8x32xf32>} : () -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x339a650) {
  %2 = "arith.constant"() {value = 16 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396460) {
  %3 = "arith.constant"() {value = 8 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x33963a0) {
  %4 = "arith.constant"() {value = 32 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396520) {
  %5 = "arith.constant"() {value = 256 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x3396660) {
  %6 = "arith.constant"() {value = 128 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x1e5e3e0) {
  %7 = "arith.constant"() {value = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x3b1fbb0) {
  %8 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 0 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x256xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x34c52c0) {
  "memref.assume_alignment"(%8) {alignment = 64 : i32} : (memref<512x256xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x34bbaa0) {
  %9 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 1 : index, descriptor_flags = 1 : i32, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<256x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206bae0) {
  "memref.assume_alignment"(%9) {alignment = 64 : i32} : (memref<256x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.binding.subspan'(0x2e8bef0) {
  %10 = "hal.interface.binding.subspan"(%7) {alignment = 64 : index, binding = 2 : index, descriptor_type = #hal.descriptor_type<storage_buffer>, operand_segment_sizes = array<i32: 1, 0>, set = 0 : index} : (index) -> memref<512x1024xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.assume_alignment'(0x206e830) {
  "memref.assume_alignment"(%10) {alignment = 64 : i32} : (memref<512x1024xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068940) {
  %11 = "hal.interface.workgroup.id"() {dimension = 0 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'hal.interface.workgroup.id'(0x2068a00) {
  %12 = "hal.interface.workgroup.id"() {dimension = 1 : index} : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x20787e0) {
  %13 = "affine.apply"(%12) {map = affine_map<()[s0] -> (s0 * 256)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x2068080) {
  %14 = "affine.apply"(%11) {map = affine_map<()[s0] -> (s0 * 128)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x1e5a0a0) {
  %15 = "memref.subview"(%8, %13) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: -9223372036854775808, 0>, static_sizes = array<i64: 256, 256>, static_strides = array<i64: 1, 1>} : (memref<512x256xf32>, index) -> memref<256x256xf32, strided<[256, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3399040) {
  %16 = "memref.subview"(%9, %14) {operand_segment_sizes = array<i32: 1, 1, 0, 0>, static_offsets = array<i64: 0, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<256x1024xf32>, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x3b1fa30) {
  %17 = "memref.subview"(%10, %13, %14) {operand_segment_sizes = array<i32: 1, 2, 0, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: 256, 128>, static_strides = array<i64: 1, 1>} : (memref<512x1024xf32>, index, index) -> memref<256x128xf32, strided<[1024, 1], offset: ?>>


  * Pattern mlir::OpWithOffsetSizesAndStridesConstantArgumentFolder<mlir::memref::SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer> : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SubViewOpMemRefCastFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::TrivialSubViewOpFolder : 'memref.subview -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x3b22530) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2aa30) {
  %18 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a840) {
  %19 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2a650) {
  %20 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c330) {
  %21 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339c140) {
  %22 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2b000) {
  %23 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x339bd60) {
  %24 = "affine.apply"(%arg0) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x34c2170) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b37910) {
  %25 = "vector.load"(%17, %arg0, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3395b40) {
  %26 = "vector.insert"(%25, %1) {position = [0]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a970) {
  %27 = "vector.load"(%17, %18, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x1e5a150) {
  %28 = "vector.insert"(%27, %26) {position = [1]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a8a0) {
  %29 = "vector.load"(%17, %19, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x33a2540) {
  %30 = "vector.insert"(%29, %28) {position = [2]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a7d0) {
  %31 = "vector.load"(%17, %20, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3398040) {
  %32 = "vector.insert"(%31, %30) {position = [3]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a700) {
  %33 = "vector.load"(%17, %21, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a1b0) {
  %34 = "vector.insert"(%33, %32) {position = [4]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a630) {
  %35 = "vector.load"(%17, %22, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a260) {
  %36 = "vector.insert"(%35, %34) {position = [5]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a560) {
  %37 = "vector.load"(%17, %23, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a310) {
  %38 = "vector.insert"(%37, %36) {position = [6]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b3a0e0) {
  %39 = "vector.load"(%17, %24, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert'(0x3b3a4b0) {
  %40 = "vector.insert"(%39, %38) {position = [7]} : (vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>


  * Pattern (anonymous namespace)::InsertToBroadcast : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertSplatToSplat : 'vector.insert -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertOpConstantFolder : 'vector.insert -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x339a790) {

  * Pattern (anonymous namespace)::ForOpIterArgsFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::SimplifyTrivialLoops : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::LastTensorLoadCanonicalization : 'scf.for -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ForOpTensorCastFolder : 'scf.for -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b36c40) {
  %50 = "vector.load"(%15, %arg0, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b39000) {
  %51 = "vector.load"(%15, %18, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38f30) {
  %52 = "vector.load"(%15, %19, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38e60) {
  %53 = "vector.load"(%15, %20, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38d90) {
  %54 = "vector.load"(%15, %21, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38cc0) {
  %55 = "vector.load"(%15, %22, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2e180) {
  %56 = "vector.load"(%15, %23, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c530) {
  %57 = "vector.load"(%15, %24, %arg2) : (memref<256x256xf32, strided<[256, 1], offset: ?>>, index, index) -> vector<16xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x34c53f0) {
  %58 = "vector.load"(%16, %arg2, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c480) {
  %59 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 1)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3396d40) {
  %60 = "vector.load"(%16, %59, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c510) {
  %61 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 2)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e5e440) {
  %62 = "vector.load"(%16, %61, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c5a0) {
  %63 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 3)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e2c3e0) {
  %64 = "vector.load"(%16, %63, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2c630) {
  %65 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 4)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1e112b0) {
  %66 = "vector.load"(%16, %65, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2dfd0) {
  %67 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 5)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x1dce9a0) {
  %68 = "vector.load"(%16, %67, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e060) {
  %69 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 6)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b25970) {
  %70 = "vector.load"(%16, %69, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2e0f0) {
  %71 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 7)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b258a0) {
  %72 = "vector.load"(%16, %71, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25810) {
  %73 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 8)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b2cbf0) {
  %74 = "vector.load"(%16, %73, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b25aa0) {
  %75 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 9)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38bf0) {
  %76 = "vector.load"(%16, %75, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b2cdf0) {
  %77 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 10)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38b20) {
  %78 = "vector.load"(%16, %77, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36bb0) {
  %79 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 11)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38a50) {
  %80 = "vector.load"(%16, %79, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b36de0) {
  %81 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 12)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b38980) {
  %82 = "vector.load"(%16, %81, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b37880) {
  %83 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 13)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b388b0) {
  %84 = "vector.load"(%16, %83, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b38320) {
  %85 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 14)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b387e0) {
  %86 = "vector.load"(%16, %85, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x3b385b0) {
  %87 = "affine.apply"(%arg2) {map = affine_map<(d0) -> (d0 + 15)>} : (index) -> index


  * Pattern (anonymous namespace)::SimplifyAffineOp<mlir::AffineApplyOp> : 'affine.apply -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.load'(0x3b32980) {
  %88 = "vector.load"(%16, %87, %arg1) : (memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> vector<32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3c900) {
  %89 = "vector.insert_strided_slice"(%50, %0) {offsets = [0], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3ca40) {
  %90 = "vector.insert_strided_slice"(%51, %89) {offsets = [16], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3cb80) {
  %91 = "vector.insert_strided_slice"(%52, %90) {offsets = [32], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f200) {
  %92 = "vector.insert_strided_slice"(%53, %91) {offsets = [48], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f340) {
  %93 = "vector.insert_strided_slice"(%54, %92) {offsets = [64], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f480) {
  %94 = "vector.insert_strided_slice"(%55, %93) {offsets = [80], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3f5c0) {
  %95 = "vector.insert_strided_slice"(%56, %94) {offsets = [96], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.insert_strided_slice'(0x3b3c7c0) {
  %96 = "vector.insert_strided_slice"(%57, %95) {offsets = [112], strides = [1]} : (vector<16xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::FoldInsertStridedSliceSplat : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldInsertStridedSliceOfExtract : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::InsertStridedSliceConstantFolder : 'vector.insert_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.shuffle'(0x3b2d4c0) {
  %97 = "vector.shuffle"(%96, %96) {mask = [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127]} : (vector<128xf32>, vector<128xf32>) -> vector<128xf32>


  * Pattern (anonymous namespace)::ShuffleSplat : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::Canonicalize0DShuffleOp : 'vector.shuffle -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2d3a0) {
  %98 = "vector.extract_strided_slice"(%97) {offsets = [0], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2e8bf80) {
  %99 = "vector.extract_strided_slice"(%97) {offsets = [8], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b22840) {
  %100 = "vector.extract_strided_slice"(%97) {offsets = [16], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b22a30) {
  %101 = "vector.extract_strided_slice"(%97) {offsets = [24], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2ac20) {
  %102 = "vector.extract_strided_slice"(%97) {offsets = [32], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x2068110) {
  %103 = "vector.extract_strided_slice"(%97) {offsets = [40], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2c3f0) {
  %104 = "vector.extract_strided_slice"(%97) {offsets = [48], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b2d0b0) {
  %105 = "vector.extract_strided_slice"(%97) {offsets = [56], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c730) {
  %106 = "vector.extract_strided_slice"(%97) {offsets = [64], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c870) {
  %107 = "vector.extract_strided_slice"(%97) {offsets = [72], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3c9b0) {
  %108 = "vector.extract_strided_slice"(%97) {offsets = [80], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3caf0) {
  %109 = "vector.extract_strided_slice"(%97) {offsets = [88], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f170) {
  %110 = "vector.extract_strided_slice"(%97) {offsets = [96], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f2b0) {
  %111 = "vector.extract_strided_slice"(%97) {offsets = [104], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f3f0) {
  %112 = "vector.extract_strided_slice"(%97) {offsets = [112], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract_strided_slice'(0x3b3f530) {
  %113 = "vector.extract_strided_slice"(%97) {offsets = [120], sizes = [8], strides = [1]} : (vector<128xf32>) -> vector<8xf32>


  * Pattern (anonymous namespace)::StridedSliceConstantMaskFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceNonSplatConstantFolder : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceBroadcast : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::StridedSliceSplat : 'vector.extract_strided_slice -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x207f600) {
  %114 = "vector.outerproduct"(%98, %58, %arg3) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x34c3240) {
  %115 = "vector.outerproduct"(%99, %60, %114) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b226e0) {
  %116 = "vector.outerproduct"(%100, %62, %115) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b228d0) {
  %117 = "vector.outerproduct"(%101, %64, %116) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b22ac0) {
  %118 = "vector.outerproduct"(%102, %66, %117) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bc00) {
  %119 = "vector.outerproduct"(%103, %68, %118) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bdf0) {
  %120 = "vector.outerproduct"(%104, %70, %119) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339bfe0) {
  %121 = "vector.outerproduct"(%105, %72, %120) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x339c1d0) {
  %122 = "vector.outerproduct"(%106, %74, %121) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a4f0) {
  %123 = "vector.outerproduct"(%107, %76, %122) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a6e0) {
  %124 = "vector.outerproduct"(%108, %78, %123) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2a8d0) {
  %125 = "vector.outerproduct"(%109, %80, %124) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aac0) {
  %126 = "vector.outerproduct"(%110, %82, %125) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2acb0) {
  %127 = "vector.outerproduct"(%111, %84, %126) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2aea0) {
  %128 = "vector.outerproduct"(%112, %86, %127) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.outerproduct'(0x3b2b090) {
  %129 = "vector.outerproduct"(%113, %88, %128) {kind = #vector.kind<add>} : (vector<8xf32>, vector<32xf32>, vector<8x32xf32>) -> vector<8x32xf32>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x2e86680) {
  "scf.yield"(%129) : (vector<8x32xf32>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3395fe0) {
  %42 = "vector.extract"(%41) {position = [0]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e5ec00) {
  "vector.store"(%42, %17, %arg0, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b26450) {
  %43 = "vector.extract"(%41) {position = [1]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e6cd70) {
  "vector.store"(%43, %17, %18, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d570) {
  %44 = "vector.extract"(%41) {position = [2]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d53430) {
  "vector.store"(%44, %17, %19, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d690) {
  %45 = "vector.extract"(%41) {position = [3]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d52ce0) {
  "vector.store"(%45, %17, %20, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d240) {
  %46 = "vector.extract"(%41) {position = [4]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d47190) {
  "vector.store"(%46, %17, %21, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2d430) {
  %47 = "vector.extract"(%41) {position = [5]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1d494b0) {
  "vector.store"(%47, %17, %22, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b2a310) {
  %48 = "vector.extract"(%41) {position = [6]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x3b32890) {
  "vector.store"(%48, %17, %23, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.extract'(0x3b32810) {
  %49 = "vector.extract"(%41) {position = [7]} : (vector<8x32xf32>) -> vector<32xf32>


  * Pattern (anonymous namespace)::ExtractOpSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpNonSplatConstantFolder : 'vector.extract -> ()' {
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::ExtractOpFromBroadcast : 'vector.extract -> ()' {
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'vector.store'(0x1e7bc10) {
  "vector.store"(%49, %17, %24, %arg1) : (vector<32xf32>, memref<256x128xf32, strided<[1024, 1], offset: ?>>, index, index) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b22430) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x3b224d0) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x1e5ed60) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//
// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst_0 [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %39 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %41 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %43 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %45 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %46 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %47 = vector.load %subview_1[%46, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %48 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %49 = vector.load %subview_1[%48, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %50 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %51 = vector.load %subview_1[%50, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %52 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %53 = vector.load %subview_1[%52, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = vector.insert_strided_slice %37, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %77 = vector.insert_strided_slice %38, %76 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %78 = vector.insert_strided_slice %39, %77 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %79 = vector.insert_strided_slice %40, %78 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %80 = vector.insert_strided_slice %41, %79 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %81 = vector.insert_strided_slice %42, %80 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %82 = vector.insert_strided_slice %43, %81 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %83 = vector.insert_strided_slice %44, %82 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %84 = vector.shuffle %83, %83 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %85 = vector.extract_strided_slice %84 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.extract_strided_slice %84 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %87 = vector.extract_strided_slice %84 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %88 = vector.extract_strided_slice %84 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %89 = vector.extract_strided_slice %84 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %90 = vector.extract_strided_slice %84 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %91 = vector.extract_strided_slice %84 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %92 = vector.extract_strided_slice %84 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %93 = vector.extract_strided_slice %84 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %94 = vector.extract_strided_slice %84 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %95 = vector.extract_strided_slice %84 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %96 = vector.extract_strided_slice %84 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %97 = vector.extract_strided_slice %84 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %98 = vector.extract_strided_slice %84 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %99 = vector.extract_strided_slice %84 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %100 = vector.extract_strided_slice %84 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %101 = vector.outerproduct %85, %45, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.outerproduct %86, %47, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.outerproduct %87, %49, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %104 = vector.outerproduct %88, %51, %103 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.outerproduct %89, %53, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %106 = vector.outerproduct %90, %55, %105 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.outerproduct %91, %57, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %108 = vector.outerproduct %92, %59, %107 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.outerproduct %93, %61, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %110 = vector.outerproduct %94, %63, %109 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.outerproduct %95, %65, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %112 = vector.outerproduct %96, %67, %111 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.outerproduct %97, %69, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %114 = vector.outerproduct %98, %71, %113 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.outerproduct %99, %73, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %116 = vector.outerproduct %100, %75, %115 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After CSE (cse) //----- //
func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
  %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
  %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
  %c16 = arith.constant 16 : index
  %c8 = arith.constant 8 : index
  %c32 = arith.constant 32 : index
  %c256 = arith.constant 256 : index
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
  memref.assume_alignment %0, 64 : memref<512x256xf32>
  %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
  memref.assume_alignment %1, 64 : memref<256x1024xf32>
  %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
  memref.assume_alignment %2, 64 : memref<512x1024xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
  %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
  %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
  %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
  scf.for %arg0 = %c0 to %c256 step %c8 {
    %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
    %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
    %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
    %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
    %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
    %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
    scf.for %arg1 = %c0 to %c128 step %c32 {
      %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %13 = vector.insert %12, %cst_0 [0] : vector<32xf32> into vector<8x32xf32>
      %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
      %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
      %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
      %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
      %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
      %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
      %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
      %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
        %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %38 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %39 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %40 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %41 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %42 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %43 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %44 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
        %45 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %46 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
        %47 = vector.load %subview_1[%46, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %48 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
        %49 = vector.load %subview_1[%48, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %50 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
        %51 = vector.load %subview_1[%50, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %52 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
        %53 = vector.load %subview_1[%52, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %54 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
        %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %56 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
        %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %58 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
        %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %60 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
        %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %62 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
        %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %64 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
        %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %66 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
        %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %68 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
        %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %70 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
        %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %72 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
        %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %74 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
        %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        %76 = vector.insert_strided_slice %37, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
        %77 = vector.insert_strided_slice %38, %76 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
        %78 = vector.insert_strided_slice %39, %77 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
        %79 = vector.insert_strided_slice %40, %78 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
        %80 = vector.insert_strided_slice %41, %79 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
        %81 = vector.insert_strided_slice %42, %80 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
        %82 = vector.insert_strided_slice %43, %81 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
        %83 = vector.insert_strided_slice %44, %82 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
        %84 = vector.shuffle %83, %83 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
        %85 = vector.extract_strided_slice %84 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %86 = vector.extract_strided_slice %84 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %87 = vector.extract_strided_slice %84 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %88 = vector.extract_strided_slice %84 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %89 = vector.extract_strided_slice %84 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %90 = vector.extract_strided_slice %84 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %91 = vector.extract_strided_slice %84 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %92 = vector.extract_strided_slice %84 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %93 = vector.extract_strided_slice %84 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %94 = vector.extract_strided_slice %84 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %95 = vector.extract_strided_slice %84 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %96 = vector.extract_strided_slice %84 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %97 = vector.extract_strided_slice %84 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %98 = vector.extract_strided_slice %84 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %99 = vector.extract_strided_slice %84 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %100 = vector.extract_strided_slice %84 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
        %101 = vector.outerproduct %85, %45, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %102 = vector.outerproduct %86, %47, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %103 = vector.outerproduct %87, %49, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %104 = vector.outerproduct %88, %51, %103 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %105 = vector.outerproduct %89, %53, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %106 = vector.outerproduct %90, %55, %105 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %107 = vector.outerproduct %91, %57, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %108 = vector.outerproduct %92, %59, %107 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %109 = vector.outerproduct %93, %61, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %110 = vector.outerproduct %94, %63, %109 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %111 = vector.outerproduct %95, %65, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %112 = vector.outerproduct %96, %67, %111 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %113 = vector.outerproduct %97, %69, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %114 = vector.outerproduct %98, %71, %113 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %115 = vector.outerproduct %99, %73, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        %116 = vector.outerproduct %100, %75, %115 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
        scf.yield %116 : vector<8x32xf32>
      }
      %29 = vector.extract %28[0] : vector<8x32xf32>
      vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %30 = vector.extract %28[1] : vector<8x32xf32>
      vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %31 = vector.extract %28[2] : vector<8x32xf32>
      vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %32 = vector.extract %28[3] : vector<8x32xf32>
      vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %33 = vector.extract %28[4] : vector<8x32xf32>
      vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %34 = vector.extract %28[5] : vector<8x32xf32>
      vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %35 = vector.extract %28[6] : vector<8x32xf32>
      vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
      %36 = vector.extract %28[7] : vector<8x32xf32>
      vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
    }
  }
  return
}

// -----// IR Dump After LLVMCPULowerExecutableTarget (iree-llvmcpu-lower-executable-target) //----- //
hal.executable.variant public @embedded_elf_x86_64, target = <"llvm-cpu", "embedded-elf-x86_64", {cpu = "generic", cpu_features = "", data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", native_vector_size = 16 : index, target_triple = "x86_64-unknown-unknown-eabi-elf"}> {
  hal.executable.export public @matmul_static_dispatch_0_matmul_512x1024x256 ordinal(0) layout(#hal.pipeline.layout<push_constants = 0, sets = [<0, bindings = [<0, storage_buffer, ReadOnly>, <1, storage_buffer, ReadOnly>, <2, storage_buffer>]>]>) attributes {translation_info = #iree_codegen.translation_info<CPUDoubleTilingPadExpert>} {
  ^bb0(%arg0: !hal.device, %arg1: index, %arg2: index, %arg3: index):
    %c8 = arith.constant 8 : index
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    hal.return %c8, %c2, %c1 : index, index, index
  }
  builtin.module {
    func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
      %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
      %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
      %c16 = arith.constant 16 : index
      %c8 = arith.constant 8 : index
      %c32 = arith.constant 32 : index
      %c256 = arith.constant 256 : index
      %c128 = arith.constant 128 : index
      %c0 = arith.constant 0 : index
      %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
      memref.assume_alignment %0, 64 : memref<512x256xf32>
      %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
      memref.assume_alignment %1, 64 : memref<256x1024xf32>
      %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
      memref.assume_alignment %2, 64 : memref<512x1024xf32>
      %workgroup_id_x = hal.interface.workgroup.id[0] : index
      %workgroup_id_y = hal.interface.workgroup.id[1] : index
      %3 = affine.apply affine_map<()[s0] -> (s0 * 256)>()[%workgroup_id_y]
      %4 = affine.apply affine_map<()[s0] -> (s0 * 128)>()[%workgroup_id_x]
      %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
      %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
      %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
      scf.for %arg0 = %c0 to %c256 step %c8 {
        %5 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg0)
        %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg0)
        %7 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg0)
        %8 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg0)
        %9 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg0)
        %10 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg0)
        %11 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg0)
        scf.for %arg1 = %c0 to %c128 step %c32 {
          %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %13 = vector.insert %12, %cst_0 [0] : vector<32xf32> into vector<8x32xf32>
          %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
          %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
          %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
          %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
          %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
          %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
          %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
          %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
            %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %38 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %39 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %40 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %41 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %42 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %43 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %44 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
            %45 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %46 = affine.apply affine_map<(d0) -> (d0 + 1)>(%arg2)
            %47 = vector.load %subview_1[%46, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %48 = affine.apply affine_map<(d0) -> (d0 + 2)>(%arg2)
            %49 = vector.load %subview_1[%48, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %50 = affine.apply affine_map<(d0) -> (d0 + 3)>(%arg2)
            %51 = vector.load %subview_1[%50, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %52 = affine.apply affine_map<(d0) -> (d0 + 4)>(%arg2)
            %53 = vector.load %subview_1[%52, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %54 = affine.apply affine_map<(d0) -> (d0 + 5)>(%arg2)
            %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %56 = affine.apply affine_map<(d0) -> (d0 + 6)>(%arg2)
            %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %58 = affine.apply affine_map<(d0) -> (d0 + 7)>(%arg2)
            %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %60 = affine.apply affine_map<(d0) -> (d0 + 8)>(%arg2)
            %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %62 = affine.apply affine_map<(d0) -> (d0 + 9)>(%arg2)
            %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %64 = affine.apply affine_map<(d0) -> (d0 + 10)>(%arg2)
            %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %66 = affine.apply affine_map<(d0) -> (d0 + 11)>(%arg2)
            %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %68 = affine.apply affine_map<(d0) -> (d0 + 12)>(%arg2)
            %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %70 = affine.apply affine_map<(d0) -> (d0 + 13)>(%arg2)
            %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %72 = affine.apply affine_map<(d0) -> (d0 + 14)>(%arg2)
            %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %74 = affine.apply affine_map<(d0) -> (d0 + 15)>(%arg2)
            %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            %76 = vector.insert_strided_slice %37, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
            %77 = vector.insert_strided_slice %38, %76 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
            %78 = vector.insert_strided_slice %39, %77 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
            %79 = vector.insert_strided_slice %40, %78 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
            %80 = vector.insert_strided_slice %41, %79 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
            %81 = vector.insert_strided_slice %42, %80 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
            %82 = vector.insert_strided_slice %43, %81 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
            %83 = vector.insert_strided_slice %44, %82 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
            %84 = vector.shuffle %83, %83 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
            %85 = vector.extract_strided_slice %84 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %86 = vector.extract_strided_slice %84 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %87 = vector.extract_strided_slice %84 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %88 = vector.extract_strided_slice %84 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %89 = vector.extract_strided_slice %84 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %90 = vector.extract_strided_slice %84 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %91 = vector.extract_strided_slice %84 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %92 = vector.extract_strided_slice %84 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %93 = vector.extract_strided_slice %84 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %94 = vector.extract_strided_slice %84 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %95 = vector.extract_strided_slice %84 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %96 = vector.extract_strided_slice %84 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %97 = vector.extract_strided_slice %84 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %98 = vector.extract_strided_slice %84 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %99 = vector.extract_strided_slice %84 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %100 = vector.extract_strided_slice %84 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
            %101 = vector.outerproduct %85, %45, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %102 = vector.outerproduct %86, %47, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %103 = vector.outerproduct %87, %49, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %104 = vector.outerproduct %88, %51, %103 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %105 = vector.outerproduct %89, %53, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %106 = vector.outerproduct %90, %55, %105 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %107 = vector.outerproduct %91, %57, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %108 = vector.outerproduct %92, %59, %107 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %109 = vector.outerproduct %93, %61, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %110 = vector.outerproduct %94, %63, %109 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %111 = vector.outerproduct %95, %65, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %112 = vector.outerproduct %96, %67, %111 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %113 = vector.outerproduct %97, %69, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %114 = vector.outerproduct %98, %71, %113 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %115 = vector.outerproduct %99, %73, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            %116 = vector.outerproduct %100, %75, %115 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
            scf.yield %116 : vector<8x32xf32>
          }
          %29 = vector.extract %28[0] : vector<8x32xf32>
          vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %30 = vector.extract %28[1] : vector<8x32xf32>
          vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %31 = vector.extract %28[2] : vector<8x32xf32>
          vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %32 = vector.extract %28[3] : vector<8x32xf32>
          vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %33 = vector.extract %28[4] : vector<8x32xf32>
          vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %34 = vector.extract %28[5] : vector<8x32xf32>
          vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %35 = vector.extract %28[6] : vector<8x32xf32>
          vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
          %36 = vector.extract %28[7] : vector<8x32xf32>
          vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
        }
      }
      return
    }
  }
}

#executable_target_embedded_elf_x86_64_ = #hal.executable.target<"llvm-cpu", "embedded-elf-x86_64", {cpu = "generic", cpu_features = "", data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", native_vector_size = 16 : index, target_triple = "x86_64-unknown-unknown-eabi-elf"}>
#map = affine_map<()[s0] -> (s0 * 256)>
#map1 = affine_map<()[s0] -> (s0 * 128)>
#map2 = affine_map<(d0) -> (d0 + 1)>
#map3 = affine_map<(d0) -> (d0 + 2)>
#map4 = affine_map<(d0) -> (d0 + 3)>
#map5 = affine_map<(d0) -> (d0 + 4)>
#map6 = affine_map<(d0) -> (d0 + 5)>
#map7 = affine_map<(d0) -> (d0 + 6)>
#map8 = affine_map<(d0) -> (d0 + 7)>
#map9 = affine_map<(d0) -> (d0 + 8)>
#map10 = affine_map<(d0) -> (d0 + 9)>
#map11 = affine_map<(d0) -> (d0 + 10)>
#map12 = affine_map<(d0) -> (d0 + 11)>
#map13 = affine_map<(d0) -> (d0 + 12)>
#map14 = affine_map<(d0) -> (d0 + 13)>
#map15 = affine_map<(d0) -> (d0 + 14)>
#map16 = affine_map<(d0) -> (d0 + 15)>
#pipeline_layout = #hal.pipeline.layout<push_constants = 0, sets = [<0, bindings = [<0, storage_buffer, ReadOnly>, <1, storage_buffer, ReadOnly>, <2, storage_buffer>]>]>
#translation = #iree_codegen.translation_info<CPUDoubleTilingPadExpert>
#device_target_llvm_cpu = #hal.device.target<"llvm-cpu", {executable_targets = [#executable_target_embedded_elf_x86_64_]}>
module attributes {hal.device.targets = [#device_target_llvm_cpu]} {
  hal.executable private @matmul_static_dispatch_0 {
    hal.executable.variant public @embedded_elf_x86_64, target = #executable_target_embedded_elf_x86_64_ {
      hal.executable.export public @matmul_static_dispatch_0_matmul_512x1024x256 ordinal(0) layout(#pipeline_layout) attributes {translation_info = #translation} {
      ^bb0(%arg0: !hal.device, %arg1: index, %arg2: index, %arg3: index):
        %c8 = arith.constant 8 : index
        %c2 = arith.constant 2 : index
        %c1 = arith.constant 1 : index
        hal.return %c8, %c2, %c1 : index, index, index
      }
      builtin.module {
        func.func @matmul_static_dispatch_0_matmul_512x1024x256() {
          %cst = arith.constant dense<0.000000e+00> : vector<128xf32>
          %cst_0 = arith.constant dense<0.000000e+00> : vector<8x32xf32>
          %c16 = arith.constant 16 : index
          %c8 = arith.constant 8 : index
          %c32 = arith.constant 32 : index
          %c256 = arith.constant 256 : index
          %c128 = arith.constant 128 : index
          %c0 = arith.constant 0 : index
          %0 = hal.interface.binding.subspan set(0) binding(0) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<512x256xf32>
          memref.assume_alignment %0, 64 : memref<512x256xf32>
          %1 = hal.interface.binding.subspan set(0) binding(1) type(storage_buffer) alignment(64) offset(%c0) flags(ReadOnly) : memref<256x1024xf32>
          memref.assume_alignment %1, 64 : memref<256x1024xf32>
          %2 = hal.interface.binding.subspan set(0) binding(2) type(storage_buffer) alignment(64) offset(%c0) : memref<512x1024xf32>
          memref.assume_alignment %2, 64 : memref<512x1024xf32>
          %workgroup_id_x = hal.interface.workgroup.id[0] : index
          %workgroup_id_y = hal.interface.workgroup.id[1] : index
          %3 = affine.apply #map()[%workgroup_id_y]
          %4 = affine.apply #map1()[%workgroup_id_x]
          %subview = memref.subview %0[%3, 0] [256, 256] [1, 1] : memref<512x256xf32> to memref<256x256xf32, strided<[256, 1], offset: ?>>
          %subview_1 = memref.subview %1[0, %4] [256, 128] [1, 1] : memref<256x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
          %subview_2 = memref.subview %2[%3, %4] [256, 128] [1, 1] : memref<512x1024xf32> to memref<256x128xf32, strided<[1024, 1], offset: ?>>
          scf.for %arg0 = %c0 to %c256 step %c8 {
            %5 = affine.apply #map2(%arg0)
            %6 = affine.apply #map3(%arg0)
            %7 = affine.apply #map4(%arg0)
            %8 = affine.apply #map5(%arg0)
            %9 = affine.apply #map6(%arg0)
            %10 = affine.apply #map7(%arg0)
            %11 = affine.apply #map8(%arg0)
            scf.for %arg1 = %c0 to %c128 step %c32 {
              %12 = vector.load %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %13 = vector.insert %12, %cst_0 [0] : vector<32xf32> into vector<8x32xf32>
              %14 = vector.load %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %15 = vector.insert %14, %13 [1] : vector<32xf32> into vector<8x32xf32>
              %16 = vector.load %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %17 = vector.insert %16, %15 [2] : vector<32xf32> into vector<8x32xf32>
              %18 = vector.load %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %19 = vector.insert %18, %17 [3] : vector<32xf32> into vector<8x32xf32>
              %20 = vector.load %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %21 = vector.insert %20, %19 [4] : vector<32xf32> into vector<8x32xf32>
              %22 = vector.load %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %23 = vector.insert %22, %21 [5] : vector<32xf32> into vector<8x32xf32>
              %24 = vector.load %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %25 = vector.insert %24, %23 [6] : vector<32xf32> into vector<8x32xf32>
              %26 = vector.load %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %27 = vector.insert %26, %25 [7] : vector<32xf32> into vector<8x32xf32>
              %28 = scf.for %arg2 = %c0 to %c256 step %c16 iter_args(%arg3 = %27) -> (vector<8x32xf32>) {
                %37 = vector.load %subview[%arg0, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %38 = vector.load %subview[%5, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %39 = vector.load %subview[%6, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %40 = vector.load %subview[%7, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %41 = vector.load %subview[%8, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %42 = vector.load %subview[%9, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %43 = vector.load %subview[%10, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %44 = vector.load %subview[%11, %arg2] : memref<256x256xf32, strided<[256, 1], offset: ?>>, vector<16xf32>
                %45 = vector.load %subview_1[%arg2, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %46 = affine.apply #map2(%arg2)
                %47 = vector.load %subview_1[%46, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %48 = affine.apply #map3(%arg2)
                %49 = vector.load %subview_1[%48, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %50 = affine.apply #map4(%arg2)
                %51 = vector.load %subview_1[%50, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %52 = affine.apply #map5(%arg2)
                %53 = vector.load %subview_1[%52, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %54 = affine.apply #map6(%arg2)
                %55 = vector.load %subview_1[%54, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %56 = affine.apply #map7(%arg2)
                %57 = vector.load %subview_1[%56, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %58 = affine.apply #map8(%arg2)
                %59 = vector.load %subview_1[%58, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %60 = affine.apply #map9(%arg2)
                %61 = vector.load %subview_1[%60, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %62 = affine.apply #map10(%arg2)
                %63 = vector.load %subview_1[%62, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %64 = affine.apply #map11(%arg2)
                %65 = vector.load %subview_1[%64, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %66 = affine.apply #map12(%arg2)
                %67 = vector.load %subview_1[%66, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %68 = affine.apply #map13(%arg2)
                %69 = vector.load %subview_1[%68, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %70 = affine.apply #map14(%arg2)
                %71 = vector.load %subview_1[%70, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %72 = affine.apply #map15(%arg2)
                %73 = vector.load %subview_1[%72, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %74 = affine.apply #map16(%arg2)
                %75 = vector.load %subview_1[%74, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
                %76 = vector.insert_strided_slice %37, %cst {offsets = [0], strides = [1]} : vector<16xf32> into vector<128xf32>
                %77 = vector.insert_strided_slice %38, %76 {offsets = [16], strides = [1]} : vector<16xf32> into vector<128xf32>
                %78 = vector.insert_strided_slice %39, %77 {offsets = [32], strides = [1]} : vector<16xf32> into vector<128xf32>
                %79 = vector.insert_strided_slice %40, %78 {offsets = [48], strides = [1]} : vector<16xf32> into vector<128xf32>
                %80 = vector.insert_strided_slice %41, %79 {offsets = [64], strides = [1]} : vector<16xf32> into vector<128xf32>
                %81 = vector.insert_strided_slice %42, %80 {offsets = [80], strides = [1]} : vector<16xf32> into vector<128xf32>
                %82 = vector.insert_strided_slice %43, %81 {offsets = [96], strides = [1]} : vector<16xf32> into vector<128xf32>
                %83 = vector.insert_strided_slice %44, %82 {offsets = [112], strides = [1]} : vector<16xf32> into vector<128xf32>
                %84 = vector.shuffle %83, %83 [0, 16, 32, 48, 64, 80, 96, 112, 1, 17, 33, 49, 65, 81, 97, 113, 2, 18, 34, 50, 66, 82, 98, 114, 3, 19, 35, 51, 67, 83, 99, 115, 4, 20, 36, 52, 68, 84, 100, 116, 5, 21, 37, 53, 69, 85, 101, 117, 6, 22, 38, 54, 70, 86, 102, 118, 7, 23, 39, 55, 71, 87, 103, 119, 8, 24, 40, 56, 72, 88, 104, 120, 9, 25, 41, 57, 73, 89, 105, 121, 10, 26, 42, 58, 74, 90, 106, 122, 11, 27, 43, 59, 75, 91, 107, 123, 12, 28, 44, 60, 76, 92, 108, 124, 13, 29, 45, 61, 77, 93, 109, 125, 14, 30, 46, 62, 78, 94, 110, 126, 15, 31, 47, 63, 79, 95, 111, 127] : vector<128xf32>, vector<128xf32>
                %85 = vector.extract_strided_slice %84 {offsets = [0], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %86 = vector.extract_strided_slice %84 {offsets = [8], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %87 = vector.extract_strided_slice %84 {offsets = [16], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %88 = vector.extract_strided_slice %84 {offsets = [24], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %89 = vector.extract_strided_slice %84 {offsets = [32], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %90 = vector.extract_strided_slice %84 {offsets = [40], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %91 = vector.extract_strided_slice %84 {offsets = [48], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %92 = vector.extract_strided_slice %84 {offsets = [56], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %93 = vector.extract_strided_slice %84 {offsets = [64], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %94 = vector.extract_strided_slice %84 {offsets = [72], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %95 = vector.extract_strided_slice %84 {offsets = [80], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %96 = vector.extract_strided_slice %84 {offsets = [88], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %97 = vector.extract_strided_slice %84 {offsets = [96], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %98 = vector.extract_strided_slice %84 {offsets = [104], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %99 = vector.extract_strided_slice %84 {offsets = [112], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %100 = vector.extract_strided_slice %84 {offsets = [120], sizes = [8], strides = [1]} : vector<128xf32> to vector<8xf32>
                %101 = vector.outerproduct %85, %45, %arg3 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %102 = vector.outerproduct %86, %47, %101 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %103 = vector.outerproduct %87, %49, %102 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %104 = vector.outerproduct %88, %51, %103 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %105 = vector.outerproduct %89, %53, %104 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %106 = vector.outerproduct %90, %55, %105 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %107 = vector.outerproduct %91, %57, %106 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %108 = vector.outerproduct %92, %59, %107 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %109 = vector.outerproduct %93, %61, %108 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %110 = vector.outerproduct %94, %63, %109 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %111 = vector.outerproduct %95, %65, %110 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %112 = vector.outerproduct %96, %67, %111 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %113 = vector.outerproduct %97, %69, %112 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %114 = vector.outerproduct %98, %71, %113 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %115 = vector.outerproduct %99, %73, %114 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                %116 = vector.outerproduct %100, %75, %115 {kind = #vector.kind<add>} : vector<8xf32>, vector<32xf32>
                scf.yield %116 : vector<8x32xf32>
              }
              %29 = vector.extract %28[0] : vector<8x32xf32>
              vector.store %29, %subview_2[%arg0, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %30 = vector.extract %28[1] : vector<8x32xf32>
              vector.store %30, %subview_2[%5, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %31 = vector.extract %28[2] : vector<8x32xf32>
              vector.store %31, %subview_2[%6, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %32 = vector.extract %28[3] : vector<8x32xf32>
              vector.store %32, %subview_2[%7, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %33 = vector.extract %28[4] : vector<8x32xf32>
              vector.store %33, %subview_2[%8, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %34 = vector.extract %28[5] : vector<8x32xf32>
              vector.store %34, %subview_2[%9, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %35 = vector.extract %28[6] : vector<8x32xf32>
              vector.store %35, %subview_2[%10, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
              %36 = vector.extract %28[7] : vector<8x32xf32>
              vector.store %36, %subview_2[%11, %arg1] : memref<256x128xf32, strided<[1024, 1], offset: ?>>, vector<32xf32>
            }
          }
          return
        }
      }
    }
  }
}

